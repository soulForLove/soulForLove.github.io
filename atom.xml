<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林林总总</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.linzhongtai.cn/"/>
  <updated>2018-08-08T09:33:42.000Z</updated>
  <id>http://blog.linzhongtai.cn/</id>
  
  <author>
    <name>Soul</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>当我们说线程安全时，到底在说什么</title>
    <link href="http://blog.linzhongtai.cn/2018/08/%E5%BD%93%E6%88%91%E4%BB%AC%E8%AF%B4%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%97%B6%EF%BC%8C%E5%88%B0%E5%BA%95%E5%9C%A8%E8%AF%B4%E4%BB%80%E4%B9%88/"/>
    <id>http://blog.linzhongtai.cn/2018/08/当我们说线程安全时，到底在说什么/</id>
    <published>2018-08-08T09:33:42.000Z</published>
    <updated>2018-08-08T09:33:42.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>本文转发自技术世界，原文链接　<a href="http://www.jasongj.com/java/thread_safe/" target="_blank" rel="noopener">http://www.jasongj.com/java/thread_safe/</a></p></blockquote><h2 id="多线程编程中的三个核心概念"><a href="#多线程编程中的三个核心概念" class="headerlink" title="多线程编程中的三个核心概念"></a>多线程编程中的三个核心概念</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>这一点，跟数据库事务的原子性概念差不多，即一个操作（有可能包含有多个子操作）要么全部执行（生效），要么全部都不执行（都不生效）。</p><p>关于原子性，一个非常经典的例子就是银行转账问题：比如A和B同时向C转账10万元。如果转账操作不具有原子性，A在向C转账时，读取了C的余额为20万，然后加上转账的10万，计算出此时应该有30万，但还未来及将30万写回C的账户，此时B的转账请求过来了，B发现C的余额为20万，然后将其加10万并写回。然后A的转账操作继续——将30万写回C的余额。这种情况下C的最终余额为30万，而非预期的40万。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>可见性是指，当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。可见性问题是好多人忽略或者理解错误的一点。</p><p>CPU从主内存中读数据的效率相对来说不高，现在主流的计算机中，都有几级缓存。每个线程读取共享变量时，都会将该变量加载进其对应CPU的高速缓存里，修改该变量后，CPU会立即更新该缓存，但并不一定会立即将其写回主内存（实际上写回主内存的时间不可预期）。此时其它线程（尤其是不在同一个CPU上执行的线程）访问该变量时，从主内存中读到的就是旧的数据，而非第一个线程更新后的数据。</p><p>这一点是操作系统或者说是硬件层面的机制，所以很多应用开发人员经常会忽略。</p><h3 id="顺序性"><a href="#顺序性" class="headerlink" title="顺序性"></a>顺序性</h3><p>顺序性指的是，程序执行的顺序按照代码的先后顺序执行。</p><p>以下面这段代码为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">boolean started = false; // 语句1</span><br><span class="line">long counter = 0L; // 语句2</span><br><span class="line">counter = 1; // 语句3</span><br><span class="line">started = true; // 语句4</span><br></pre></td></tr></table></figure><p>从代码顺序上看，上面四条语句应该依次执行，但实际上JVM真正在执行这段代码时，并不保证它们一定完全按照此顺序执行。</p><p>处理器为了提高程序整体的执行效率，可能会对代码进行优化，其中的一项优化方式就是调整代码顺序，按照更高效的顺序执行代码。</p><p>讲到这里，有人要着急了——什么，CPU不按照我的代码顺序执行代码，那怎么保证得到我们想要的效果呢？实际上，大家大可放心，CPU虽然并不保证完全按照代码顺序执行，但它会保证程序最终的执行结果和代码顺序执行时的结果一致。</p><h2 id="Java如何解决多线程并发问题"><a href="#Java如何解决多线程并发问题" class="headerlink" title="Java如何解决多线程并发问题"></a>Java如何解决多线程并发问题</h2><h3 id="Java如何保证原子性"><a href="#Java如何保证原子性" class="headerlink" title="Java如何保证原子性"></a>Java如何保证原子性</h3><h4 id="锁和同步"><a href="#锁和同步" class="headerlink" title="锁和同步"></a>锁和同步</h4><p>常用的保证Java操作原子性的工具是锁和同步方法（或者同步代码块）。使用锁，可以保证同一时间只有一个线程能拿到锁，也就保证了同一时间只有一个线程能执行申请锁和释放锁之间的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void testLock () &#123;</span><br><span class="line">  lock.lock();</span><br><span class="line">  try&#123;</span><br><span class="line">    int j = i;</span><br><span class="line">    i = j + 1;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与锁类似的是同步方法或者同步代码块。使用非静态同步方法时，锁住的是当前实例；使用静态同步方法时，锁住的是该类的Class对象；使用静态代码块时，锁住的是synchronized关键字后面括号内的对象。下面是同步代码块示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void testLock () &#123;</span><br><span class="line">  synchronized (anyObject)&#123;</span><br><span class="line">    int j = i;</span><br><span class="line">    i = j + 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论使用锁还是synchronized，本质都是一样，通过锁来实现资源的排它性，从而实际目标代码段同一时间只会被一个线程执行，进而保证了目标代码段的原子性。这是一种以牺牲性能为代价的方法。</p><h4 id="CAS（compare-and-swap）"><a href="#CAS（compare-and-swap）" class="headerlink" title="CAS（compare and swap）"></a>CAS（compare and swap）</h4><p>基础类型变量自增（i++）是一种常被新手误以为是原子操作而实际不是的操作。Java中提供了对应的原子操作类来实现该操作，并保证原子性，其本质是利用了CPU级别的CAS指令。由于是CPU级别的指令，其开销比需要操作系统参与的锁的开销小。AtomicInteger使用方法如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger atomicInteger = new AtomicInteger();</span><br><span class="line">for(int b = 0; b &lt; numThreads; b++) &#123;</span><br><span class="line">  new Thread(() -&gt; &#123;</span><br><span class="line">    for(int a = 0; a &lt; iteration; a++) &#123;</span><br><span class="line">      atomicInteger.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java如何保证可见性"><a href="#Java如何保证可见性" class="headerlink" title="Java如何保证可见性"></a>Java如何保证可见性</h3><p>Java提供了volatile关键字来保证可见性。当使用volatile修饰某个变量时，它会保证对该变量的修改会立即被更新到内存中，并且将其它缓存中对该变量的缓存设置成无效，因此其它线程需要读取该值时必须从主内存中读取，从而得到最新的值。</p><h3 id="Java如何保证顺序性"><a href="#Java如何保证顺序性" class="headerlink" title="Java如何保证顺序性"></a>Java如何保证顺序性</h3><p>上文讲过编译器和处理器对指令进行重新排序时，会保证重新排序后的执行结果和代码顺序执行的结果一致，所以重新排序过程并不会影响单线程程序的执行，却可能影响多线程程序并发执行的正确性。</p><p>Java中可通过volatile在一定程序上保证顺序性，另外还可以通过synchronized和锁来保证顺序性。</p><p>synchronized和锁保证顺序性的原理和保证原子性一样，都是通过保证同一时间只会有一个线程执行目标代码段来实现的。</p><p>除了从应用层面保证目标代码段执行的顺序性外，JVM还通过被称为happens-before原则隐式地保证顺序性。两个操作的执行顺序只要可以通过happens-before推导出来，则JVM会保证其顺序性，反之JVM对其顺序性不作任何保证，可对其进行任意必要的重新排序以获取高效率。</p><h3 id="happens-before原则（先行发生原则）"><a href="#happens-before原则（先行发生原则）" class="headerlink" title="happens-before原则（先行发生原则）"></a>happens-before原则（先行发生原则）</h3><ul><li>传递规则：如果操作1在操作2前面，而操作2在操作3前面，则操作1肯定会在操作3前发生。该规则说明了happens-before原则具有传递性</li><li>锁定规则：一个unlock操作肯定会在后面对同一个锁的lock操作前发生。这个很好理解，锁只有被释放了才会被再次获取</li><li>volatile变量规则：对一个被volatile修饰的写操作先发生于后面对该变量的读操作</li><li>程序次序规则：一个线程内，按照代码顺序执行</li><li>线程启动规则：Thread对象的start()方法先发生于此线程的其它动作</li><li>线程终结原则：线程的终止检测后发生于线程中其它的所有操作</li><li>线程中断规则： 对线程interrupt()方法的调用先发生于对该中断异常的获取</li><li>对象终结规则：一个对象构造先于它的finalize发生</li></ul><h2 id="volatile适用场景"><a href="#volatile适用场景" class="headerlink" title="volatile适用场景"></a>volatile适用场景</h2><p>volatile适用于不需要保证原子性，但却需要保证可见性的场景。一种典型的使用场景是用它修饰用于停止线程的状态标记。如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">boolean isRunning = false;</span><br><span class="line">public void start () &#123;</span><br><span class="line">  new Thread( () -&gt; &#123;</span><br><span class="line">    while(isRunning) &#123;</span><br><span class="line">      someOperation();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">public void stop () &#123;</span><br><span class="line">  isRunning = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种实现方式下，即使其它线程通过调用stop()方法将isRunning设置为false，循环也不一定会立即结束。可以通过volatile关键字，保证while循环及时得到isRunning最新的状态从而及时停止循环，结束线程。</p><h2 id="线程安全十万个为什么"><a href="#线程安全十万个为什么" class="headerlink" title="线程安全十万个为什么"></a>线程安全十万个为什么</h2><p>问：平时项目中使用锁和synchronized比较多，而很少使用volatile，难道就没有保证可见性？<br>答：锁和synchronized即可以保证原子性，也可以保证可见性。都是通过保证同一时间只有一个线程执行目标代码段来实现的。</p><p>问：锁和synchronized为何能保证可见性？<br>答：根据JDK 7的Java doc中对concurrent包的说明，一个线程的写结果保证对另外线程的读操作可见，只要该写操作可以由happen-before原则推断出在读操作之前发生。</p><p>The results of a write by one thread are guaranteed to be visible to a read by another thread only if the write operation happens-before the read operation. The synchronized and volatile constructs, as well as the Thread.start() and Thread.join() methods, can form happens-before relationships.</p><p>问：既然锁和synchronized即可保证原子性也可保证可见性，为何还需要volatile？<br>答：synchronized和锁需要通过操作系统来仲裁谁获得锁，开销比较高，而volatile开销小很多。因此在只需要保证可见性的条件下，使用volatile的性能要比使用锁和synchronized高得多。</p><p>问：既然锁和synchronized可以保证原子性，为什么还需要AtomicInteger这种的类来保证原子操作？<br>答：锁和synchronized需要通过操作系统来仲裁谁获得锁，开销比较高，而AtomicInteger是通过CPU级的CAS操作来保证原子性，开销比较小。所以使用AtomicInteger的目的还是为了提高性能。</p><p>问：还有没有别的办法保证线程安全？<br>答：有。尽可能避免引起非线程安全的条件——共享变量。如果能从设计上避免共享变量的使用，即可避免非线程安全的发生，也就无须通过锁或者synchronized以及volatile解决原子性、可见性和顺序性的问题。</p><p>问：synchronized即可修饰非静态方式，也可修饰静态方法，还可修饰代码块，有何区别？<br>答：synchronized修饰非静态同步方法时，锁住的是当前实例；synchronized修饰静态同步方法时，锁住的是该类的Class对象；synchronized修饰静态代码块时，锁住的是synchronized关键字后面括号内的对象。</p>]]></content>
    
    <summary type="html">
    
      原子性/可见性/顺序性......
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>HashMap的ReHash图解</title>
    <link href="http://blog.linzhongtai.cn/2018/07/HashMap%E7%9A%84ReHash%E5%9B%BE%E8%A7%A3/"/>
    <id>http://blog.linzhongtai.cn/2018/07/HashMap的ReHash图解/</id>
    <published>2018-07-20T09:30:57.000Z</published>
    <updated>2018-07-20T09:30:57.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><ul><li>resize方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void resize(intnewCapacity)</span><br><span class="line">&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    intoldCapacity = oldTable.length;</span><br><span class="line">    ......</span><br><span class="line">    //创建一个新的Hash Table</span><br><span class="line">    Entry[] newTable =new Entry[newCapacity];</span><br><span class="line">    //将Old Hash Table上的数据迁移到New Hash Table上</span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (int)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>transfer方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] newTable)</span><br><span class="line">&#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    intnewCapacity = newTable.length;</span><br><span class="line">    //下面这段代码的意思是：</span><br><span class="line">    //  从OldTable里摘一个元素出来，然后放到NewTable中</span><br><span class="line">    for(intj = 0; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        if(e != null) &#123;</span><br><span class="line">            src[j] =null;</span><br><span class="line">            do&#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                inti = indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125;while (e != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单线程下的ReHash"><a href="#单线程下的ReHash" class="headerlink" title="单线程下的ReHash"></a>单线程下的ReHash</h2><ul><li>用key mod 一下表的大小（也就是数组的长度）。</li><li>最上面的是old hash 表，其中的Hash表的size=2, 所以key = 3, 7, 5，在mod 2以后都冲突在table[1]这里了。</li><li>接下来的三个步骤是Hash表 resize成4，然后所有的&lt;key,value&gt; 重新rehash的过程</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/5937589-5a476e5b596cbb98.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>详细描述可以看下面这张图：</p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-9731276c6b9937dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="并发下的Rehash"><a href="#并发下的Rehash" class="headerlink" title="并发下的Rehash"></a>并发下的Rehash</h2><ol><li>假设我们有两个线程。我用红色和浅蓝色标注了一下。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">    Entry&lt;K,V&gt; next = e.next;// &lt;--假设线程一执行到这里就被调度挂起了</span><br><span class="line">    inti = indexFor(e.hash, newCapacity);</span><br><span class="line">    e.next = newTable[i];</span><br><span class="line">    newTable[i] = e;</span><br><span class="line">    e = next;</span><br><span class="line">&#125;while (e != null);</span><br></pre></td></tr></table></figure><p>而我们的线程二执行完成了。于是我们有下面的这个样子。</p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-1a6fd03cdcee139e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>注意，因为Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。我们可以看到链表的顺序被反转后。</p><ol start="2"><li>线程一被调度回来执行。</li></ol><ul><li>先是执行 newTalbe[i] = e;</li><li>然后是e = next，导致了e指向了key(7)，</li><li>而下一次循环的next = e.next导致了next指向了key(3)</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/5937589-63a70821341b4cb2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><ol start="3"><li>线程一继续执行</li></ol><p>把key(7)摘下来，放到newTable[i]的第一个，然后把e和next往下移</p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-ee96974bcac48192.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><ol start="4"><li>环形链接出现</li></ol><p>e.next = newTable[i] 导致  key(3).next 指向了 key(7)<br>注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-508820052916f668.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>当我们的线程一调用到HashTable.get(11)时，悲剧就出现了——Infinite Loop</p>]]></content>
    
    <summary type="html">
    
      HashMap的ReHash
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>缓存与数据库一致性之缓存更新设计</title>
    <link href="http://blog.linzhongtai.cn/2018/06/%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7%E4%B9%8B%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E8%AE%BE%E8%AE%A1/"/>
    <id>http://blog.linzhongtai.cn/2018/06/缓存与数据库一致性之缓存更新设计/</id>
    <published>2018-06-25T09:28:02.000Z</published>
    <updated>2018-06-25T09:28:02.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="缓存更新场景介绍"><a href="#缓存更新场景介绍" class="headerlink" title="缓存更新场景介绍"></a>缓存更新场景介绍</h2><p>缓存是一种提高系统读性能的常见技术，对于读多写少的应用场景，我们经常使用缓存来进行优化.</p><p>例如对于用户的余额信息表account(uid, money)，业务上的需求是：</p><p>（1）查询用户的余额，SELECT money FROM account WHERE uid=XXX，占99%的请求</p><p>（2）更改用户余额，UPDATE account SET money=XXX WHERE uid=XXX，占1%的请求</p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-6ed7ba23bc14ce22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>由于大部分的请求是查询，我们在缓存中建立uid到money的键值对，能够极大降低数据库的压力。</p><h3 id="读操作流程"><a href="#读操作流程" class="headerlink" title="读操作流程"></a>读操作流程</h3><p>有了数据库和缓存两个地方存放数据之后（uid-&gt;money），每当需要读取相关数据时（money），操作流程一般是这样的：<br>（1）读取缓存中是否有相关数据，uid-&gt;money<br>（2）如果缓存中有相关数据money，则返回【这就是所谓的数据命中“hit”】<br>（3）如果缓存中没有相关数据money，则从数据库读取相关数据money【这就是所谓的数据未命中“miss”】，放入缓存中uid-&gt;money，再返回缓存的命中率 = 命中缓存请求个数/总缓存访问请求个数 = hit/(hit+miss)上面举例的余额场景，99%的读，1%的写，这个缓存的命中率是非常高的，会在95%以上。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>当数据money发生变化的时候：<br>（1）是更新缓存中的数据，还是淘汰缓存中的数据呢？<br>（2）是先操纵数据库中的数据再操纵缓存中的数据，还是先操纵缓存中的数据再操纵数据库中的数据呢？<br>（3）缓存与数据库的操作，在架构上是否有优化的空间呢？</p><h2 id="更新缓存-VS-淘汰缓存"><a href="#更新缓存-VS-淘汰缓存" class="headerlink" title="更新缓存 VS 淘汰缓存"></a>更新缓存 VS 淘汰缓存</h2><ul><li><p>更新缓存：数据不但写入数据库，还会写入缓存<br>优点：缓存不会增加一次miss，命中率高</p></li><li><p>淘汰缓存：数据只会写入数据库，不会写入缓存，只会把数据淘汰掉<br>优点：简单</p></li></ul><p>那到底是选择更新缓存还是淘汰缓存呢？<strong>主要取决于“更新缓存的复杂度”。</strong></p><p>例如，上述场景，只是简单的把余额money设置成一个值，那么：<br>（1）淘汰缓存的操作为deleteCache(uid)<br>（2）更新缓存的操作为setCache(uid, money)<br>更新缓存的代价很小，此时我们应该更倾向于更新缓存，以保证更高的缓存命中率。<br>如果余额是通过很复杂的数据计算得出来的，更新缓存的代价很大，此时我们应该更倾向于淘汰缓存。<br><strong>淘汰缓存操作简单，并且带来的副作用只是增加了一次cache miss，建议作为通用的处理方式。</strong></p><h2 id="先操作数据库-vs-先操作缓存"><a href="#先操作数据库-vs-先操作缓存" class="headerlink" title="先操作数据库 vs 先操作缓存"></a>先操作数据库 vs 先操作缓存</h2><p>当写操作发生时，假设淘汰缓存作为对缓存通用的处理方式，又面临两种抉择：<br>（1）先写数据库，再淘汰缓存<br>（2）先淘汰缓存，再写数据库</p><p>对于一个不能保证事务性的操作，一定涉及“哪个任务先做，哪个任务后做”的问题，解决这个问题的方向是：<br><strong>如果出现不一致，谁先做对业务的影响较小，就谁先执行。</strong><br>由于写数据库与淘汰缓存不能保证原子性，谁先谁后同样要遵循上述原则。</p><ul><li><strong>假设先写数据库，再淘汰缓存</strong><br>第一步写数据库操作成功，第二步淘汰缓存失败，则会出现DB中是新数据，Cache中是旧数据，数据不一致。<br><img src="http://upload-images.jianshu.io/upload_images/5937589-046e99f7e1f7ddad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li><li><strong>假设先淘汰缓存，再写数据库</strong><br>第一步淘汰缓存成功，第二步写数据库失败，则只会引发一次Cache miss。</li></ul><blockquote><p><strong>结论：数据和缓存的操作时序，结论是清楚的：先淘汰缓存，再写数据库。</strong></p></blockquote><h2 id="缓存架构优化"><a href="#缓存架构优化" class="headerlink" title="缓存架构优化"></a>缓存架构优化</h2><p><img src="http://upload-images.jianshu.io/upload_images/5937589-9b00c88b809a05f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>上述缓存架构有一个缺点：业务方需要同时关注缓存与DB，有没有进一步的优化空间呢？有两种常见的方案，一种主流方案(服务化)，一种非主流方案（异步缓存更新）</p><h3 id="服务化"><a href="#服务化" class="headerlink" title="服务化"></a>服务化</h3><p>加入一个服务层，向上游提供帅气的数据访问接口，向上游屏蔽底层数据存储的细节，这样业务线不需要关注数据是来自于cache还是DB</p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-e390cf4a5779b2e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="异步缓存更新"><a href="#异步缓存更新" class="headerlink" title="异步缓存更新"></a>异步缓存更新</h3><p>业务线所有的写操作都走数据库，所有的读操作都总缓存，由一个异步的工具来做数据库与缓存之间数据的同步</p><ol><li>要有一个init cache的过程，将需要缓存的数据全量写入cache</li><li>如果DB有写操作，异步更新程序读取binlog，更新cache</li></ol><p>在（1）和（2）的合作下，cache中有全部的数据，这样：<br>（a）业务线读cache，一定能够hit（很短的时间内，可能有脏数据），无需关注数据库<br>（b）业务线写DB，cache中能得到异步更新，无需关注缓存</p><blockquote><p>将大大简化业务线的调用逻辑，存在的缺点是，如果缓存的数据业务逻辑比较复杂，async-update异步更新的逻辑可能也会比较复杂</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>淘汰缓存是一种通用的缓存处理方式</li><li>先淘汰缓存，再写数据库的时序是毋庸置疑的</li><li>服务化是向业务方屏蔽底层数据库与缓存复杂性的一种通用方式</li></ol><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>我们在项目中使用缓存通常都是先检查缓存中是否存在，如果存在直接返回缓存内容，如果不存在就直接查询数据库然后再缓存查询结果返回。<br>这个时候如果我们查询的某一个数据在缓存中一直不存在，就会造成每一次请求都查询DB，这样缓存就失去了意义，在流量大时，可能DB就挂掉了。<br>要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。</p><p><strong>解决方案：</strong><br>（1）缓存空对象，设置短暂的过期时间<br>（2）布隆过滤器拦截</p><p>有一个比较巧妙的作法是，可以将这个不存在的key预先设定一个值，比如，”key” , “&amp;&amp;”。在返回这个&amp;&amp;值的时候，我们的应用就可以认为这是不存在的key，那我们的应用就可以决定是否继续等待继续访问，还是放弃掉这次操作。如果继续等待访问，过一个时间轮询点后，再次请求这个key，如果取到的值不再是&amp;&amp;，则可以认为这时候key有值了，从而避免了透传到数据库，从而把大量的类似请求挡在了缓存之中。</p><h3 id="缓存并发-缓存击穿"><a href="#缓存并发-缓存击穿" class="headerlink" title="缓存并发-缓存击穿"></a>缓存并发-缓存击穿</h3><p>有时候如果网站并发访问高，一个缓存如果失效，可能出现多个进程同时查询DB，同时设置缓存的情况，如果并发确实很大，这也可能造成DB压力过大，还有缓存频繁更新的问题。</p><p><strong>解决方案：</strong><br>锁、互斥锁</p><h3 id="缓存失效-缓存雪崩"><a href="#缓存失效-缓存雪崩" class="headerlink" title="缓存失效-缓存雪崩"></a>缓存失效-缓存雪崩</h3><p>引起这个问题的主要原因还是高并发的时候，平时我们设定一个缓存的过期时间时，可能有一些会设置1分钟啊，5分钟这些，并发很高时可能会出在某一个时间同时生成了很多的缓存，并且过期时间都一样，这个时候就可能引发一当过期时间到后，这些缓存同时失效，请求全部转发到DB，DB可能会压力过重。</p><p><strong>解决方案：</strong><br>随机过期时间，降低过期时间的重复率</p>]]></content>
    
    <summary type="html">
    
      先更新缓存中的数据，还是淘汰缓存中的数据呢
    
    </summary>
    
      <category term="缓存" scheme="http://blog.linzhongtai.cn/categories/%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="缓存" scheme="http://blog.linzhongtai.cn/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构</title>
    <link href="http://blog.linzhongtai.cn/2018/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://blog.linzhongtai.cn/2018/06/Redis底层数据结构/</id>
    <published>2018-06-22T09:20:40.000Z</published>
    <updated>2018-06-22T09:20:40.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="Redis底层数据结构类型"><a href="#Redis底层数据结构类型" class="headerlink" title="Redis底层数据结构类型"></a>Redis底层数据结构类型</h2><h3 id="简单动态字符串（simple-dynamic-string）SDS"><a href="#简单动态字符串（simple-dynamic-string）SDS" class="headerlink" title="简单动态字符串（simple dynamic string）SDS"></a>简单动态字符串（simple dynamic string）SDS</h3><blockquote><p>Redis 没有直接使用C语言传统的字符串表示，而是自己构建了一种名为简单动态字符串（simple dynamic string SDS）的抽象类型，并将SDS用作Redis 的默认字符串表示;<br>除了用来保存字符串以外，SDS还被用作缓冲区（buffer）AOF(<a href="http://blog.linzhongtai.cn/2018/05/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/">持久化</a>)模块中的AOF缓冲区</p></blockquote><h4 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h4><blockquote><p>区别于C语言字符串，具有良好的伸缩性，在获取字符串长度，字符串修改，防止缓存区溢出等性能都比C语言字符串好</p></blockquote><p>Redis 中定义动态字符串的结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*  </span><br><span class="line"> * 保存字符串对象的结构  </span><br><span class="line"> */  </span><br><span class="line">struct sdshdr &#123;  </span><br><span class="line">      </span><br><span class="line">    // buf 中已占用空间的长度  </span><br><span class="line">    int len;  </span><br><span class="line">  </span><br><span class="line">    // buf 中剩余可用空间的长度(初次分配空间，一般没有空余，在对字符串修改的时候，会有剩余空间出现)-预分配  </span><br><span class="line">    int free;  </span><br><span class="line">  </span><br><span class="line">    // 数据空间  </span><br><span class="line">    char buf[];  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="SDS-与-C-字符串的区别"><a href="#SDS-与-C-字符串的区别" class="headerlink" title="SDS 与 C 字符串的区别"></a>SDS 与 C 字符串的区别</h4><ul><li>获取字符串长度（<strong>SDS O（1）/C 字符串 O(n)</strong>）<br>  <strong>传统的C字符串</strong>: 使用长度为N+1 的字符串数组来表示长度为N 的字符串，所以为了获取一个长度为C字符串的长度，必须遍历整个字符串。<br>  <strong>SDS</strong>：SDS 的数据结构中，有专门用于保存字符串长度的变量，我们可以通过获取len 属性的值，直接知道字符串长度</li></ul><h4 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h4><blockquote><p>C 字符串 不记录字符串长度，除了获取的时候复杂度高以外，还容易忘了为字符串重新分配足够的空间，从而导致缓冲区溢出</p></blockquote><p> Redis 中SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性：<br> 当我们需要对一个SDS进行修改的时候，redis会在执行拼接操作之前，预先检查给定SDS空间是否足够，如果不够，会先拓展SDS 的空间，然后再执行拼接操作</p><h4 id="减少修改字符串时带来的内存重分配次数"><a href="#减少修改字符串时带来的内存重分配次数" class="headerlink" title="减少修改字符串时带来的内存重分配次数"></a>减少修改字符串时带来的内存重分配次数</h4><blockquote><p>C语言字符串在进行字符串的扩充和收缩的时候，都会面临着内存空间的重新分配问题</p></blockquote><ol><li>字符串拼接会产生字符串的内存空间的扩充，在拼接的过程中，原来的字符串的大小很可能小于拼接后的字符串的大小，那么这样的话，就会导致一旦忘记申请分配空间，就会导致内存的溢出。</li><li>字符串在进行收缩的时候，内存空间会相应的收缩，而如果在进行字符串的切割的时候，没有对内存的空间进行一个重新分配，那么这部分多出来的空间就成为了内存泄露</li></ol><p><strong>SDS</strong>：对SDS进行拓展，则需要进行空间的拓展，这时候redis 会将SDS的长度修改为N字节，并且将未使用空间同样修改为N字节，此时如果再次进行修改，因为在上一次修改字符串的时候已经拓展了空间，再次进行修改字符串的时候如果发现空间足够使用，因此无须进行空间拓展<br><strong>通过这种预分配策略，SDS将连续增长N次字符串所需的内存重分配次数从必定N次降低为最多N次</strong></p><h4 id="惰性空间释放"><a href="#惰性空间释放" class="headerlink" title="惰性空间释放"></a>惰性空间释放</h4><p>SDS 提供了相应的API，让我们可以在有需要的时候，自行释放SDS的空余空间<br>通过惰性空间释放，SDS避免了缩短字符串时所需的内存重分配操作，并未将来可能有的增长操作提供了优化</p><h4 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h4><ul><li><p>C 字符串中的字符必须符合某种编码，并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存想图片，音频，视频，压缩文件这样的二进制数据</p></li><li><p>在Redis中，不是靠空字符来判断字符串的结束的，而是通过len这个属性。那么，即便是中间出现了空字符对于SDS来说，读取该字符仍然是可以的</p></li></ul><h4 id="兼容部分C字符串函数"><a href="#兼容部分C字符串函数" class="headerlink" title="兼容部分C字符串函数"></a>兼容部分C字符串函数</h4><p>虽然SDS 的API 都是二进制安全的，但他们一样遵循C字符串以空字符串结尾的惯例</p><h4 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h4><table><thead><tr><th style="text-align:center">C 字符串</th><th style="text-align:center">SDS</th></tr></thead><tbody><tr><td style="text-align:center">获取字符串长度的复杂度为O（N)</td><td style="text-align:center">获取字符串长度的复杂度为O(1)</td></tr><tr><td style="text-align:center">API 是不安全的，可能会造成缓冲区溢出</td><td style="text-align:center">API 是安全的，不会造成缓冲区溢出</td></tr><tr><td style="text-align:center">修改字符串长度N次必然需要执行N次内存重分配</td><td style="text-align:center">修改字符串长度N次最多执行N次内存重分配</td></tr><tr><td style="text-align:center">只能保存文本数据</td><td style="text-align:center">可以保存二进制数据和文本文数据</td></tr><tr><td style="text-align:center">可以使用所有&lt;String.h&gt;库中的函数</td><td style="text-align:center">可以使用一部分&lt;string.h&gt;库中的函数</td></tr></tbody></table><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><blockquote><p><strong>顺序存储对象信息，有用于缓存链表长度的属性，在插入删除对象功能中有良好性能，避免环的产生</strong></p></blockquote><blockquote><p>链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。链表在Redis 中的应用非常广泛，比如<strong>列表键的底层实现之一就是链表</strong>。当一个列表键包含了数量较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis 就会使用链表作为列表键的底层实现。</p></blockquote><h4 id="链表的数据结构"><a href="#链表的数据结构" class="headerlink" title="链表的数据结构"></a>链表的数据结构</h4><p>每个链表节点使用一个 listNode结构表示（adlist.h/listNode）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct listNode&#123;</span><br><span class="line">      struct listNode *prev;</span><br><span class="line">      struct listNode * next;</span><br><span class="line">      void * value;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>多个链表节点组成的双端链表：<br><img src="http://upload-images.jianshu.io/upload_images/5937589-919359a5901757d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>通过直接操作list 来操作链表会更加方便:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct list&#123;</span><br><span class="line">    //表头节点</span><br><span class="line">    listNode  * head;</span><br><span class="line">    //表尾节点</span><br><span class="line">    listNode  * tail;</span><br><span class="line">    //链表长度</span><br><span class="line">    unsigned long len;</span><br><span class="line">    //节点值复制函数</span><br><span class="line">    void *(*dup) (void *ptr);</span><br><span class="line">    //节点值释放函数</span><br><span class="line">    void (*free) (void *ptr);</span><br><span class="line">    //节点值对比函数</span><br><span class="line">    int (*match)(void *ptr, void *key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>dup 函数用于复制链表节点所保存的值；</li><li>free 函数用于释放链表节点所保存的值；</li><li>match 函数则用于对比链表节点所保存的值和另一个输入值是否相等。<br>list 组成的结构图：<br><img src="http://upload-images.jianshu.io/upload_images/5937589-a0fe4b6fd64e90e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li></ul><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>双端：链表节点带有prev 和next 指针，获取某个节点的前置节点和后置节点的时间复杂度都是O（N）</li><li>无环：表头节点的 prev 指针和表尾节点的next 都指向NULL，对立案表的访问时以NULL为截止</li><li>表头和表尾：因为链表带有head指针和tail 指针，程序获取链表头结点和尾节点的时间复杂度为O(1)</li><li>长度计数器：链表中存有记录链表长度的属性 len</li><li>多态：链表节点使用 void* 指针来保存节点值，并且可以通过list 结构的dup 、 free、 match三个属性为节点值设置类型特定函数。</li></ul><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><blockquote><p><strong>key-value 存储方式，通过hash值计算，判断key的存储，当容量过大，会通过rehash重新分配字典大小</strong></p></blockquote><blockquote><p>字典，又称为符号表（symbol table）、关联数组（associative array）或映射（map），是一种用于保存键值对的抽象数据结构。<br>在字典中，一个键（key）可以和一个值（value）进行关联，字典中的每个键都是独一无二的。在C语言中，并没有这种数据结构，但是Redis 中构建了自己的字典实现</p></blockquote><h4 id="字典的定义"><a href="#字典的定义" class="headerlink" title="字典的定义"></a>字典的定义</h4><ol><li>哈希表<br>Redis 字典所使用的哈希表由 dict.h/dictht 结构定义：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictht &#123;</span><br><span class="line">   //哈希表数组</span><br><span class="line">   dictEntry **table;</span><br><span class="line">   //哈希表大小</span><br><span class="line">   unsigned long size;</span><br><span class="line"></span><br><span class="line">   //哈希表大小掩码，用于计算索引值</span><br><span class="line">   unsigned long sizemask;</span><br><span class="line">   //该哈希表已有节点的数量</span><br><span class="line">   unsigned long used;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>一个空的字典的结构图如下：<br><img src="http://upload-images.jianshu.io/upload_images/5937589-c140f7cef2dc39a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>可以看到，在结构中存有指向dictEntry 数组的指针，而我们用来存储数据的空间既是dictEntry</p><ol start="2"><li>哈希表节点（ dictEntry ）<br>dictEntry 结构定义：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typeof struct dictEntry&#123;</span><br><span class="line">   //键</span><br><span class="line">   void *key;</span><br><span class="line">   //值</span><br><span class="line">   union&#123;</span><br><span class="line">      void *val;</span><br><span class="line">      uint64_tu64;</span><br><span class="line">      int64_ts64;</span><br><span class="line">   &#125;</span><br><span class="line">   struct dictEntry *next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在数据结构中，我们清楚key 是唯一的，但是我们存入里面的key 并不是直接的字符串，而是一个hash 值，通过hash 算法，将字符串转换成对应的hash 值，然后在dictEntry 中找到对应的位置。<br>这时候我们会发现一个问题，如果出现hash 值相同的情况怎么办？Redis 采用了链地址法：<br><img src="http://upload-images.jianshu.io/upload_images/5937589-b8c796e3bf89ab8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>当k1 和k0 的hash 值相同时，将k1中的next 指向k0 想成一个链表。</p><ol start="3"><li>字典<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dict &#123;</span><br><span class="line">    // 类型特定函数</span><br><span class="line">    dictType *type;</span><br><span class="line">    // 私有数据</span><br><span class="line">    void *privedata;</span><br><span class="line">    // 哈希表</span><br><span class="line">    dictht  ht[2];</span><br><span class="line">    // rehash 索引</span><br><span class="line">    in trehashidx;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>type 属性 和privdata 属性是针对不同类型的键值对，为创建多态字典而设置的。<br>ht 属性是一个包含两个项（两个哈希表）的数组</p><p>普通状态下的字典：<br><img src="http://upload-images.jianshu.io/upload_images/5937589-c8a06ee0e7857e24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h4 id="解决哈希冲突"><a href="#解决哈希冲突" class="headerlink" title="解决哈希冲突"></a>解决哈希冲突</h4><blockquote><p>在上述分析哈希节点的时候我们有讲到：在插入一条新的数据时，会进行哈希值的计算，如果出现了hash值相同的情况，Redis 中采用了连地址法（separate chaining）来解决键冲突。每个哈希表节点都有一个next 指针，多个哈希表节点可以使用next 构成一个单向链表，被分配到同一个索引上的多个节点可以使用这个单向链表连接起来解决hash值冲突的问题。</p></blockquote><p><strong>举个栗子：</strong><br>现在哈希表中有以下的数据：k0 和k1<br><img src="http://upload-images.jianshu.io/upload_images/5937589-f6f397286303a9fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>我们现在要插入k2，通过hash 算法计算到k2 的hash 值为2，即我们需要将k2 插入到dictEntry[2]中：</p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-29dba56d52905787.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>在插入后我们可以看到，dictEntry指向了k2，k2的next指向了k1，从而完成了一次插入操作（这里选择表头插入是因为哈希表节点中没有记录链表尾节点位置）</p><h4 id="Rehash"><a href="#Rehash" class="headerlink" title="Rehash"></a>Rehash</h4><blockquote><p>随着对哈希表的不断操作，哈希表保存的键值对会逐渐的发生改变，为了让哈希表的负载因子维持在一个合理的范围之内，我们需要对哈希表的大小进行相应的扩展或者压缩，这时候，我们可以通过 rehash（重新散列）操作来完成</p></blockquote><ol><li>目前的哈希表状态<br>我们可以看到，哈希表中的每个节点都已经使用到了，这时候我们需要对哈希表进行拓展<br><img src="http://upload-images.jianshu.io/upload_images/5937589-0bfcc5304648688b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li><li>为哈希表分配空间<br>哈希表空间分配规则：<br> 如果执行的是拓展操作，那么ht[1] 的大小为第一个大于等于ht[0] 的2的n次幂<br> 如果执行的是收缩操作，那么ht[1] 的大小为第一个大于等于ht[0] 的2的n次幂<br>因此这里我们为ht[1] 分配 空间为8，<br><img src="http://upload-images.jianshu.io/upload_images/5937589-511688a5cc08ff3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li><li>数据转移<br>将ht[0]中的数据转移到ht[1]中，在转移的过程中，需要对哈希表节点的数据重新进行哈希值计算<br>数据转移后的结果：<br><img src="http://upload-images.jianshu.io/upload_images/5937589-9426b397abe01e6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li><li>释放ht[0]<br>将ht[0]释放，然后将ht[1]设置成ht[0]，最后为ht[1]分配一个空白哈希表：<br><img src="http://upload-images.jianshu.io/upload_images/5937589-afa38b7543e6afc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li><li>渐进式 rehash<br>上面我们说到，在进行拓展或者压缩的时候，可以直接将所有的键值对rehash 到ht[1]中，这是因为数据量比较小。在实际开发过程中，这个rehash 操作并不是一次性、集中式完成的，而是分多次、渐进式地完成的。<br>渐进式rehash 的详细步骤：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、为ht[1] 分配空间，让字典同时持有ht[0]和ht[1]两个哈希表</span><br><span class="line">2、在几点钟维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash 开始</span><br><span class="line">3、在rehash 进行期间，每次对字典执行CRUD操作时，程序除了执行指定的操作以外，</span><br><span class="line">还会将ht[0]中的数据rehash 到ht[1]表中，并且将rehashidx加一</span><br><span class="line">4、当ht[0]中所有数据转移到ht[1]中时，将rehashidx 设置成-1，表示rehash 结束</span><br></pre></td></tr></table></figure></li></ol><p>采用渐进式rehash 的好处在于它采取分而治之的方式，避免了集中式rehash 带来的庞大计算量</p><blockquote><p><strong>哈希表的扩展与收缩</strong></p></blockquote><p><strong>当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1 ；</span><br><span class="line">服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5 ；</span><br></pre></td></tr></table></figure></p><p>其中哈希表的负载因子可以通过公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 负载因子 = 哈希表已保存节点数量 / 哈希表大小</span><br><span class="line">load_factor = ht[0].used / ht[0].size</span><br></pre></td></tr></table></figure></p><h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。跳跃表是一种随机化的数据,跳跃表以有序的方式在层次化的链表中保存元素，效率和平衡树媲美——查找、删除、添加等操作都可以在对数期望时间下完成，并且比起平衡树来说，跳跃表的实现要简单直观得多。</p><blockquote><p>Redis 只在两个地方用到了跳跃表，一个是<strong>实现有序集合键</strong>，另外一个是<strong>在集群节点中用作内部数据结构</strong></p></blockquote><h4 id="跳跃表的定义"><a href="#跳跃表的定义" class="headerlink" title="跳跃表的定义"></a>跳跃表的定义</h4><p>跳跃表的完整结构：<br><img src="http://upload-images.jianshu.io/upload_images/5937589-e7c686894349d1d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><center>Redis 的跳跃表 主要由两部分组成：zskiplist（链表）和zskiplistNode （节点）</center><ol><li>zskiplistNode（节点） 数据结构：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplistNode&#123;</span><br><span class="line">　　　//层</span><br><span class="line">     struct zskiplistLevel&#123;</span><br><span class="line">　　　　　//前进指针</span><br><span class="line">        struct zskiplistNode *forward;</span><br><span class="line">　　　　//跨度</span><br><span class="line">        unsigned int span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">　　//后退指针</span><br><span class="line">    struct zskiplistNode *backward;</span><br><span class="line">　　//分值</span><br><span class="line">    double score;</span><br><span class="line">　　//成员对象</span><br><span class="line">    robj *obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>层：level 数组可以包含多个元素，每个元素都包含一个指向其他节点的指针。</li><li>前进指针：用于指向表尾方向的前进指针</li><li>跨度：用于记录两个节点之间的距离</li><li>后退指针：用于从表尾向表头方向访问节点</li><li>分值和成员：跳跃表中的所有节点都按分值从小到大排序。成员对象指向一个字符串，这个字符串对象保存着一个SDS值</li></ul><ol start="2"><li>zskiplist 数据结构：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplist &#123;</span><br><span class="line">     //表头节点和表尾节点</span><br><span class="line">     structz skiplistNode *header,*tail;</span><br><span class="line">     //表中节点数量</span><br><span class="line">     unsigned long length;</span><br><span class="line">     //表中层数最大的节点的层数</span><br><span class="line">     int level;</span><br><span class="line"></span><br><span class="line">&#125;zskiplist;</span><br></pre></td></tr></table></figure></li></ol><p><img src="http://upload-images.jianshu.io/upload_images/5937589-b7b5a0611ccbae2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>从结构图中我们可以清晰的看到，header，tail分别指向跳跃表的头结点和尾节点。level 用于记录最大的层数，length 用于记录我们的节点数量。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>跳跃表是有序集合的底层实现之一</li><li>主要有zskiplist 和zskiplistNode两个结构组成</li><li>每个跳跃表节点的层高都是1至32之间的随机数</li><li>在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的对象必须是唯一的</li><li>节点按照分值的大小从大到小排序，如果分值相同，则按成员对象大小排序</li></ol><h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><blockquote><p>整数集合是集合建的底层实现之一，当一个集合中只包含整数，且这个集合中的元素数量不多时，redis就会使用整数集合intset作为集合的底层实现</p></blockquote><p>【其实就是一个特殊的集合，里面存储的数据只能够是整数，并且数据量不能过大】</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset&#123;</span><br><span class="line">    //编码方式</span><br><span class="line">    uint32_t enconding;</span><br><span class="line">   // 集合包含的元素数量</span><br><span class="line">    uint32_t length;</span><br><span class="line">    //保存元素的数组    </span><br><span class="line">    int8_t contents[];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">1、encoding：用于定义整数集合的编码方式</span><br><span class="line">2、length：用于记录整数集合中变量的数量</span><br><span class="line">3、contents：用于保存元素的数组，虽然我们在数据结构图中看到，intset将数组定义为int8_t，</span><br><span class="line">但实际上数组保存的元素类型取决于encoding</span><br></pre></td></tr></table></figure><h4 id="整数集合的升级"><a href="#整数集合的升级" class="headerlink" title="整数集合的升级"></a>整数集合的升级</h4><blockquote><p>intset 在默认情况下会帮我们设定整数集合中的编码方式，但是当我们存入的整数不符合整数集合中的编码格式时，就需要使用到Redis 中的升级策略来解决</p></blockquote><ul><li>Intset 中升级整数集合并添加新元素共分为三步进行：</li></ul><ol><li>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间</li><li>将底层数组现有的所有元素都转换成新的编码格式，重新分配空间</li><li>将新元素加入到底层数组中</li></ol><ul><li>整数集合升级的好处</li></ul><ol><li>提升灵活性</li><li>节约内存</li></ol><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li>整数集合是集合建的底层实现之一</li><li>整数集合的底层实现为数组，这个数组以有序，无重复的范式保存集合元素，在有需要时，程序会根据新添加的元素类型改变这个数组的类型</li><li>升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存</li><li>整数集合只支持升级操作，不支持降级操作</li></ul><h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><blockquote><p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值， 要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p></blockquote><h4 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h4><p>压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。<br>一个压缩列表可以包含任意多个节点（entry）， 每个节点可以保存一个字节数组或者一个整数值。<br><img src="http://upload-images.jianshu.io/upload_images/5937589-3389fa57757200cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">类型</th><th style="text-align:center">长度</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center">zlbytes</td><td style="text-align:center">uint32_t</td><td style="text-align:center">4 字节</td><td style="text-align:center">记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 zlend 的位置时使用。</td></tr><tr><td style="text-align:center">zltail</td><td style="text-align:center">uint32_t</td><td style="text-align:center">4 字节</td><td style="text-align:center">记录压缩列表表尾节点距离压缩列表的起始地址有多少字节： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。</td></tr><tr><td style="text-align:center">zllen</td><td style="text-align:center">uint16_t</td><td style="text-align:center">2 字节</td><td style="text-align:center">记录了压缩列表包含的节点数量： 当这个属性的值小于 UINT16_MAX （65535）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 UINT16_MAX 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。</td></tr><tr><td style="text-align:center">entryX</td><td style="text-align:center">列表节点</td><td style="text-align:center">不定</td><td style="text-align:center">压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td></tr><tr><td style="text-align:center">zlend</td><td style="text-align:center">uint8_t</td><td style="text-align:center">1 字节</td><td style="text-align:center">特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端。</td></tr></tbody></table><h4 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h4><blockquote><p>添加新节点可能会引发连锁更新之外， 删除节点也可能会引发连锁更新</p></blockquote><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul><li>压缩列表是一种为了节约内存而开发的顺序型数据结构</li><li>压缩列表被用作列表键和哈希键的底层实现之一</li><li>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值</li><li>添加新节点到压缩列表，可能会引发连锁更新操作，删除节点也可能会引发连锁更新</li></ul><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><p>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于39字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值</p><p>embstr 编码是专门用于保存短字符串的一种优化编码方式， 这种编码和 raw 编码一样， 都使用 redisObject 结构和 sdshdr 结构来表示字符串对象， 但 raw 编码会调用两次内存分配函数来分别创建 redisObject 结构和 sdshdr 结构， 而 embstr 编码则通过调用一次内存分配函数来分配一块连续的空间， 空间中依次包含 redisObject 和 sdshdr 两个结构</p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-54293d165d3a29d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>embstr 编码的字符串对象在执行命令时， 产生的效果和 raw 编码的字符串对象执行命令时产生的效果是相同的，但使用embstr 编码的字符串对象来保存短字符串值有以下好处：</p><ul><li>embstr 编码将创建字符串对象所需的内存分配次数从 raw 编码的两次降低为一次。</li><li>释放 embstr 编码的字符串对象只需要调用一次内存释放函数， 而释放 raw 编码的字符串对象需要调用两次内存释放函数。</li><li>因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码的字符串对象能够更好地利用缓存带来的优势。</li></ul><p><strong>字符串对象保存各类型值的编码方式：</strong></p><table><thead><tr><th style="text-align:center">值</th><th style="text-align:center">编码</th></tr></thead><tbody><tr><td style="text-align:center">可以用 long 类型保存的整数。</td><td style="text-align:center">int</td></tr><tr><td style="text-align:center">可以用 long double 类型保存的浮点数。</td><td style="text-align:center">embstr 或者 raw</td></tr><tr><td style="text-align:center">字符串值， 或者因为长度太大而没办法用 long 类型表示的整数， 又或者因为长度太大而没办法用 long double 类型表示的浮点数。</td><td style="text-align:center">embstr 或者 raw</td></tr></tbody></table><p>int 编码的字符串对象和 embstr 编码的字符串对象在条件满足的情况下， 会被转换为 raw 编码的字符串对象。<br>对于 int 编码的字符串对象来说， 如果我们向对象执行了一些命令， 使得这个对象保存的不再是整数值， 而是一个字符串值， 那么字符串对象的编码将从 int 变为 raw 。</p><h4 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h4><blockquote><p>列表对象的编码可以是 ziplist 或者 linkedlist 。</p></blockquote><ol><li>ziplist 编码的列表对象使用压缩列表作为底层实现， 每个压缩列表节点（entry）保存了一个列表元素</li><li>linkedlist 编码的列表对象使用双端链表作为底层实现， 每个双端链表节点（node）都保存了一个字符串对象， 而每个字符串对象都保存了一个列表元素</li></ol><p>当列表对象可以同时满足以下两个条件时， 列表对象使用 ziplist 编码：</p><ul><li>列表对象保存的所有字符串元素的长度都小于 64 字节；</li><li>列表对象保存的元素数量小于 512 个；</li></ul><blockquote><p>以上两个条件的上限值是可以修改的， 具体请看配置文件中关于 list-max-ziplist-value 选项和 list-max-ziplist-entries 选项的说明</p></blockquote><p>不能满足这两个条件的列表对象需要使用 linkedlist 编码。</p><h4 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h4><blockquote><p>哈希对象的编码可以是 ziplist 或者 hashtable </p></blockquote><ol><li>ziplist 编码的哈希对象使用压缩列表作为底层实现， 每当有新的键值对要加入到哈希对象时， 程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾， 因此：</li></ol><ul><li>保存了同一键值对的两个节点总是紧挨在一起， 保存键的节点在前， 保存值的节点在后；</li><li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向， 而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li></ul><ol start="2"><li>hashtable 编码的哈希对象使用字典作为底层实现， 哈希对象中的每个键值对都使用一个字典键值对来保存</li></ol><p>当哈希对象可以同时满足以下两个条件时， 哈希对象使用 ziplist 编码：</p><ul><li>哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；</li><li>哈希对象保存的键值对数量小于 512 个；</li></ul><blockquote><p>这两个条件的上限值是可以修改的， 具体请看配置文件中关于 hash-max-ziplist-value 选项和 hash-max-ziplist-entries 选项的说明</p></blockquote><p>不能满足这两个条件的哈希对象需要使用 hashtable 编码。</p><h4 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h4><blockquote><p>集合对象的编码可以是 intset 或者 hashtable </p></blockquote><ol><li>intset 编码的集合对象使用整数集合作为底层实现， 集合对象包含的所有元素都被保存在整数集合里面</li><li>hashtable 编码的集合对象使用字典作为底层实现， 字典的每个键都是一个字符串对象， 每个字符串对象包含了一个集合元素， 而字典的值则全部被设置为 NULL </li></ol><p>当集合对象可以同时满足以下两个条件时， 对象使用 intset 编码：</p><ul><li>集合对象保存的所有元素都是整数值；</li><li>集合对象保存的元素数量不超过 512 个；</li></ul><blockquote><p>第二个条件的上限值是可以修改的， 具体请看配置文件中关于 set-max-intset-entries 选项的说明。</p></blockquote><p>不能满足这两个条件的集合对象需要使用 hashtable 编码。</p><h4 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h4><blockquote><p>有序集合的编码可以是 ziplist 或者 skiplist</p></blockquote><ol><li><p>ziplist 编码的有序集合对象使用压缩列表作为底层实现<br>每个集合元素使用两个紧挨在一起的压缩列表节点来保存， 第一个节点保存元素的成员（member）， 而第二个元素则保存元素的分值（score）<br>压缩列表内的集合元素按分值从小到大进行排序， 分值较小的元素被放置在靠近表头的方向， 而分值较大的元素则被放置在靠近表尾的方向</p></li><li><p>skiplist 编码的有序集合对象使用 zset 结构作为底层实现<br>一个 zset 结构同时包含一个字典和一个跳跃表</p></li></ol><h4 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h4><p>因为 C 语言并不具备自动的内存回收功能， 所以 Redis 在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制， 通过这一机制， 程序可以通过跟踪对象的引用计数信息， 在适当的时候自动释放对象并进行内存回收</p><p>对象的引用计数信息会随着对象的使用状态而不断变化：</p><ul><li>在创建一个新对象时， 引用计数的值会被初始化为 1 ；</li><li>当对象被一个新程序使用时， 它的引用计数值会被增一；</li><li>当对象不再被一个程序使用时， 它的引用计数值会被减一；</li><li>当对象的引用计数值变为 0 时， 对象所占用的内存会被释放。</li></ul><p>对象的整个生命周期可以划分为创建对象、操作对象、释放对象三个阶段。</p><h4 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h4><p>除了用于实现引用计数内存回收机制之外， 对象的引用计数属性还带有对象共享的作用</p><p>在 Redis 中， 让多个键共享同一个值对象需要执行以下两个步骤：</p><ol><li>将数据库键的值指针指向一个现有的值对象；</li><li>将被共享的值对象的引用计数增一。</li></ol><p>目前来说， Redis 会在初始化服务器时， 创建一万个字符串对象， 这些对象包含了从 0 到 9999 的所有整数值， 当服务器需要用到值为 0 到 9999 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象</p><blockquote><p>创建共享字符串对象的数量可以通过修改 redis.h/REDIS_SHARED_INTEGERS 常量来修改</p></blockquote><p>如果我们创建一个值为 100 的键 A ， 并使用 OBJECT REFCOUNT 命令查看键 A 的值对象的引用计数， 我们会发现值对象的引用计数为 2 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET A 100</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT REFCOUNT A</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></p><p>引用这个值对象的两个程序分别是持有这个值对象的服务器程序， 以及共享这个值对象的键 A </p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-7574de56cd896183.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>如果这时我们再创建一个值为 100 的键 B ， 那么键 B 也会指向包含整数值 100 的共享对象， 使得共享对象的引用计数值变为 3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET B 100</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT REFCOUNT A</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT REFCOUNT B</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-ee362ddaba231709.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这些共享对象不单单只有字符串键可以使用， 那些在数据结构中嵌套了字符串对象的对象（linkedlist 编码的列表对象、 hashtable 编码的哈希对象、 hashtable 编码的集合对象、以及 zset 编码的有序集合对象）都可以使用这些共享对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">为什么 Redis 不共享包含字符串的对象？</span><br><span class="line"></span><br><span class="line">当服务器考虑将一个共享对象设置为键的值对象时， 程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同， </span><br><span class="line">只有在共享对象和目标对象完全相同的情况下， 程序才会将共享对象用作键的值对象，</span><br><span class="line"> 而一个共享对象保存的值越复杂， 验证共享对象和目标对象是否相同所需的复杂度就会越高， 消耗的 CPU 时间也会越多：</span><br><span class="line"></span><br><span class="line">  如果共享对象是保存整数值的字符串对象， 那么验证操作的复杂度为 O(1) ；</span><br><span class="line">  如果共享对象是保存字符串值的字符串对象， 那么验证操作的复杂度为 O(N) ；</span><br><span class="line">  如果共享对象是包含了多个值（或者对象的）对象， 比如列表对象或者哈希对象， 那么验证操作的复杂度将会是 O(N^2) 。</span><br><span class="line">因此， 尽管共享更复杂的对象可以节约更多的内存， 但受到 CPU 时间的限制， Redis 只对包含整数值的字符串对象进行共享。</span><br></pre></td></tr></table></figure><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><ul><li>Redis 数据库中的每个键值对的键和值都是一个对象。</li><li>Redis 共有字符串、列表、哈希、集合、有序集合五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率。</li><li>服务器在执行某些命令之前， 会先检查给定键的类型能否执行指定的命令， 而检查一个键的类型就是检查键的值对象的类型。</li><li>Redis 的对象系统带有引用计数实现的内存回收机制， 当一个对象不再被使用时， 该对象所占用的内存就会被自动释放。</li><li>Redis 会共享值为 0 到 9999 的字符串对象。</li><li>对象会记录自己的最后一次被访问的时间， 这个时间可以用于计算对象的空转时间</li></ul><center><a href="http://redisbook.com/index.html" target="_blank" rel="noopener">参考文档传送门</a></center>]]></content>
    
    <summary type="html">
    
      SDS/链表/字典/跳跃表/整数集合/压缩列表...
    
    </summary>
    
      <category term="redis" scheme="http://blog.linzhongtai.cn/categories/redis/"/>
    
    
      <category term="redis" scheme="http://blog.linzhongtai.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>maven依赖关系中Scope的作用</title>
    <link href="http://blog.linzhongtai.cn/2018/06/maven%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E4%B8%ADScope%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://blog.linzhongtai.cn/2018/06/maven依赖关系中Scope的作用/</id>
    <published>2018-06-22T09:17:05.000Z</published>
    <updated>2018-06-22T09:17:05.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在POM 4中，中还引入了，它主要管理依赖的部署。目前可以使用5个值：</p><ul><li>compile，缺省值，适用于所有阶段，会随着项目一起发布。 </li><li>provided，类似compile，期望JDK、容器或使用者会提供这个依赖。如servlet.jar。 </li><li>runtime，只在运行时使用，如JDBC驱动，适用运行和测试阶段。 </li><li>test，只在测试时使用，用于编译和运行测试代码。不会随项目发布。 </li><li>system，类似provided，需要显式提供包含依赖的jar，Maven不会在Repository中查找它。</li></ul><h2 id="compile-（编译范围）"><a href="#compile-（编译范围）" class="headerlink" title="compile （编译范围）"></a>compile （编译范围）</h2><p>compile是默认的范围；如果没有提供一个范围，那该依赖的范围就是编译范围。编译范围依赖在所有的classpath 中可用,同时它们也会被打包</p><h2 id="provided-（已提供范围）"><a href="#provided-（已提供范围）" class="headerlink" title="provided （已提供范围）"></a>provided （已提供范围）</h2><p>provided 依赖只有在当JDK 或者一个容器已提供该依赖之后才使用。例如， 如果你开发了一个web 应用，你可能在编译classpath 中需要可用的Servlet API 来编译一个servlet，但是你不会想要在打包好的WAR 中包含这个Servlet API；这个Servlet API JAR 由你的应用服务器或者servlet 容器提供。已提供范围的依赖在编译classpath （不是运行时）可用。它们不是传递性的，也不会被打包</p><h2 id="runtime-（运行时范围）"><a href="#runtime-（运行时范围）" class="headerlink" title="runtime （运行时范围）"></a>runtime （运行时范围）</h2><p>runtime依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如，你可能在编译的时候只需要JDBC API JAR，而只有在运行的时候才需要JDBC驱动实现。</p><h2 id="test-（测试范围）"><a href="#test-（测试范围）" class="headerlink" title="test （测试范围）"></a>test （测试范围）</h2><p>test范围依赖 在一般的编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用</p><h2 id="system-（系统范围）"><a href="#system-（系统范围）" class="headerlink" title="system （系统范围）"></a>system （系统范围）</h2><p>system范围依赖与provided 类似，但是你必须显式的提供一个对于本地系统中JAR 文件的路径。这么做是为了允许基于本地对象编译，而这些对象是系统类库的一部分。这样的构件应该是一直可用的，Maven也不会在仓库中去寻找它。如果你将一个依赖范围设置成系统范围，你必须同时提供一个 systemPath 元素。注意该范围是不推荐使用的（你应该一直尽量去从公共或定制的 Maven 仓库中引用依赖）</p>]]></content>
    
    <summary type="html">
    
      compile/system/test/runtime/provided
    
    </summary>
    
      <category term="Maven" scheme="http://blog.linzhongtai.cn/categories/Maven/"/>
    
    
      <category term="小知识" scheme="http://blog.linzhongtai.cn/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
      <category term="Maven" scheme="http://blog.linzhongtai.cn/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>cron表达式</title>
    <link href="http://blog.linzhongtai.cn/2018/06/cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://blog.linzhongtai.cn/2018/06/cron表达式/</id>
    <published>2018-06-15T09:10:33.000Z</published>
    <updated>2018-06-15T09:10:33.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><p>1、Seconds Minutes Hours DayofMonth Month DayofWeek Year<br>2、Seconds Minutes Hours DayofMonth Month DayofWeek</p><h2 id="对应的含义"><a href="#对应的含义" class="headerlink" title="对应的含义"></a>对应的含义</h2><p>Seconds:可出现”, - <em> /“四个字符，有效范围为0-59的整数<br>Minutes:可出现”, - </em> /“四个字符，有效范围为0-59的整数<br>Hours:可出现”, - <em> /“四个字符，有效范围为0-23的整数<br>DayofMonth:可出现”, - </em> / ? L W C”八个字符，有效范围为0-31的整数<br>Month:可出现”, - <em> /“四个字符，有效范围为1-12的整数或JAN-DEc<br>DayofWeek:可出现”, - </em> / ? L C #”八个字符，有效范围为1-7的整数或SUN-SAT两个范围。<br>1表示星期天，2表示星期一， 依次类推<br>Year:可出现”, - * /“四个字符，有效范围为1970-2099年</p><h2 id="特殊字符含义"><a href="#特殊字符含义" class="headerlink" title="特殊字符含义"></a>特殊字符含义</h2><ul><li>* 表示所有值</li><li>? 表示未说明的值，即不关心它为何值</li><li>- 表示一个指定的范围</li><li>, 表示附加一个可能值</li><li>/ 符号前表示开始时间，符号后表示每次递增的值</li><li>L</li></ul><p>用在day-of-month字段意思是 “这个月最后一天”；<br>用在 day-of-week字段, 它简单意思是 “7” or “SAT”。 如果在day-of-week字段里和数字联合使用，<br>它的意思就是 “这个月的最后一个星期几” – 例如： “6L” means “这个月的最后一个星期五”. 当我们用“L”时，不指明一个列表值或者范围是很重要的，不然的话，我们会得到一些意想不到的结果</p><ul><li><p>W<br>只能用在day-of-month字段。用来描叙最接近指定天的工作日（周一到周五）。<br>例如：在day-of-month字段用“15W”指“最接近这个 月第15天的工作日”，即如果这个月第15天是周六，<br>那么触发器将会在这个月第14天即周五触发；<br>如果这个月第15天是周日，那么触发器将会在这个月第16天即周一触发；<br>如果这个月第15天是周二，那么就在触发器这天触发。注意一点：这个用法只会在当前月计算值，不会越过当前月。<br>“W”字符仅能在 day-of-month指明一天，不能是一个范围或列表。也可以用“LW”来指定这个月的最后一个工作日。</p></li><li><p>#</p></li></ul><p>只能用在day-of-week字段。用来指定这个月的第几个周几。<br>例：在day-of-week字段用”6#3”指这个月第3个周五（6指周五，3指第3个）。如果指定的日期不存在，触发器就不会触发</p><ul><li>C<br>指和calendar联系后计算过的值。<br>例：在day-of-month字段用“5C”指在这个月第5天或之后包括calendar的第一天；<br>在day-of-week字段用“1C”指在这周日或之后包括calendar的第一天</li></ul><h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">每隔5秒执行一次：*/5 * * * * ?</span><br><span class="line"></span><br><span class="line">每隔1分钟执行一次：0 */1 * * * ?</span><br><span class="line"></span><br><span class="line">每天23点执行一次：0 0 23 * * ?</span><br><span class="line"></span><br><span class="line">每天凌晨1点执行一次：0 0 1 * * ?</span><br><span class="line"></span><br><span class="line">每月1号凌晨1点执行一次：0 0 1 1 * ?</span><br><span class="line"></span><br><span class="line">每月最后一天23点执行一次：0 0 23 L * ?</span><br><span class="line"></span><br><span class="line">每周星期天凌晨1点实行一次：0 0 1 ? * L</span><br><span class="line"></span><br><span class="line">在26分、29分、33分执行一次：0 26,29,33 * * * ?</span><br><span class="line"></span><br><span class="line">每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ?</span><br><span class="line"></span><br><span class="line">每隔5分钟执行一次：0 0/5 * * * ?</span><br><span class="line"></span><br><span class="line">每天中午12点触发 ：0 0 12 * * ?</span><br><span class="line"></span><br><span class="line">每天上午10:15触发 :0 15 10 ? * *</span><br><span class="line"></span><br><span class="line">每天上午10:15触发 :0 15 10 * * ?</span><br><span class="line"></span><br><span class="line">每天上午10:15触发：0 15 10 * * ? *</span><br><span class="line"></span><br><span class="line">2005年的每天上午10:15触发 ：0 15 10 * * ? 2005</span><br><span class="line"></span><br><span class="line">在每天下午2点到下午2:59期间的每1分钟触发 ：0 * 14 * * ?</span><br><span class="line"></span><br><span class="line">在每天下午2点到下午2:55期间的每5分钟触发 ：0 0/5 14 * * ?</span><br><span class="line"></span><br><span class="line">在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 ：0 0/5 14,18 * * ?</span><br><span class="line"></span><br><span class="line">在每天下午2点到下午2:05期间的每1分钟触发 ：0 0-5 14 * * ?</span><br><span class="line"></span><br><span class="line">每年三月的星期三的下午2:10和2:44触发 ：0 10,44 14 ? 3 WED</span><br><span class="line"></span><br><span class="line">周一至周五的上午10:15触发 ：0 15 10 ? * MON-FRI</span><br><span class="line"></span><br><span class="line">每月15日上午10:15触发 ：0 15 10 15 * ?</span><br><span class="line"></span><br><span class="line">每月最后一日的上午10:15触发 ：0 15 10 L * ?</span><br><span class="line"></span><br><span class="line">每月的最后一个星期五上午10:15触发 ：0 15 10 ? * 6L</span><br><span class="line"></span><br><span class="line">2002年至2005年的每月的最后一个星期五上午10:15触发 ：0 15 10 ? * 6L 2002-2005</span><br><span class="line"></span><br><span class="line">每月的第三个星期五上午10:15触发 ：0 15 10 ? * 6#3</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      cron表达式语法以及范例
    
    </summary>
    
      <category term="cron" scheme="http://blog.linzhongtai.cn/categories/cron/"/>
    
    
      <category term="小知识" scheme="http://blog.linzhongtai.cn/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
      <category term="cron" scheme="http://blog.linzhongtai.cn/tags/cron/"/>
    
  </entry>
  
  <entry>
    <title>Liquibase小知识</title>
    <link href="http://blog.linzhongtai.cn/2018/06/Liquibase%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <id>http://blog.linzhongtai.cn/2018/06/Liquibase小知识/</id>
    <published>2018-06-15T08:30:13.000Z</published>
    <updated>2018-06-15T08:30:13.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="liquibase相关"><a href="#liquibase相关" class="headerlink" title="liquibase相关"></a>liquibase相关</h2><ul><li>不依赖于特定的数据库，目前支持包括Oracle/Sql Server/DB2/MySql/Sybase/PostgreSQL/Caché等12种数据库，<br>这样在数据库的部署和升级环节可帮助应用系统支持多数据库</li><li>提供数据库比较功能，比较结果保存在XML中，基于该XML你可用Liquibase轻松部署或升级数据库</li><li>以XML存储数据库变化，其中以作者和ID唯一标识一个变化（ChangSet），支持数据库变化的合并，因此支持多开发人员同时工作</li><li>在数据库中保存数据库修改历史（DatabaseChangeHistory），在数据库升级时自动跳过已应用的变化（ChangSet）<br>提供变化应用的回滚功能，可按时间、数量或标签（tag）回滚已应用的变化。通过这种方式，开发人员可轻易的还原数据库在任何时间点的状态</li><li>可生成数据库修改文档（HTML格式）</li><li>提供数据重构的独立的IDE和Eclipse插件</li></ul><h2 id="目录以及文件解释"><a href="#目录以及文件解释" class="headerlink" title="目录以及文件解释"></a>目录以及文件解释</h2><ul><li>data<br>  存放初始化数据文件</li><li>schemas<br>存放数据结构变动脚本</li><li>changelog.xml<br>主要执行文件，引入相关数据变动脚本</li><li>liquibase.properties<br>数据库配置文件</li><li>pom.xml<br>引入数据库依赖以及liquibase插件</li></ul><h2 id="liquibase常用命令"><a href="#liquibase常用命令" class="headerlink" title="liquibase常用命令"></a>liquibase常用命令</h2><p>changelogSync : 將changelog中未套用至db的change logs标识成已同步<br>changelogSyncSQL : 同changelogSync，但只產生sql，而不執行同步到db<br>generateChangeLog : 將目前数据库的结构(默认不包含数据)生成 xml<br>dbDoc : 產生像java doc的文件<br>diff : 比對兩個数据库間的差異<br>status : 顯示目前change set有那些change log會被套用到db<br>rollbackSql:根据回滚版本生成回滚sql<br>rollback:根据回滚版本生成回滚sql，并在数据库中执行<br>update : 将changeLog.xml中的数据变动changeset脚本转化为sql语句，直接在数据库中执行<br>updateSQL : 将changeLog.xml中的数据变动changeset脚本转化为sql语句，并输出到对应的文件中</p><h2 id="Flyway-VS-Liquibase"><a href="#Flyway-VS-Liquibase" class="headerlink" title="Flyway VS Liquibase"></a>Flyway VS Liquibase</h2><ul><li>Flyway<br>简单，直接写sql保存文件<br>不支持回滚<br>数据库迁移问题(SQL语句并不是一个广泛兼容的语言，有些关键字是独有的，如果flyway就需要兼容写两套sql脚本)</li><li>Liquibase<br>支持多种格式（xml/json/yaml/sql）<br>支持多种数据库迁移<br>可读性强<br>支持回滚</li></ul><p><a href="https://gitee.com/Soulll/dbtest" target="_blank" rel="noopener">传送门</a></p>]]></content>
    
    <summary type="html">
    
      数据库管理工具
    
    </summary>
    
      <category term="liquibase" scheme="http://blog.linzhongtai.cn/categories/liquibase/"/>
    
    
      <category term="liquibase" scheme="http://blog.linzhongtai.cn/tags/liquibase/"/>
    
  </entry>
  
  <entry>
    <title>Redis常见数据类型操作命令</title>
    <link href="http://blog.linzhongtai.cn/2018/05/Redis%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.linzhongtai.cn/2018/05/Redis常见数据类型操作命令/</id>
    <published>2018-05-17T02:46:25.000Z</published>
    <updated>2018-05-17T02:46:25.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h2><ul><li>keys *—查询所有key</li><li>exists key—判断key是否存在</li><li>move key db—移除当前库的key值</li><li>expire key  秒钟—设定过期时间</li><li>ttl key —查看多少秒后过期，-1永不过期，-2已过期</li><li>type key —查看key类型</li><li>FLUSHALL—清空所有数据库<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2></li><li>set/get/del/append（追加）/strlen（获取key长度）</li><li>incr（递增1）/decr（递减1）/incrby（指定递增多少）/decrby（指定递减多少）—数字才行</li><li>getrange（区间范围内取值）/setrange（区间范围内覆盖设值）</li><li>setex（set with expire）设值以及过期时间/setnx（set if not exist 不存在则写入）</li><li>mset（多值设置）/mget（多值获取）/msetnx（全部不存在才进行插入）</li><li>getset 先获取再设值<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2></li><li>hset/hget/hmset/hmget/hgetall/hdel</li><li>hlen获取键值个数</li><li>hexist key keyname 判断keyname是否在key中 </li><li>hkeys（获取所有key）/hvals（获取所有values）</li><li>hincrby/hincrbyfloat（指定递增）</li><li>hsetnx（键值不存在则进行设值）<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2></li><li>lpush（添加左边元素）/rpush（添加右边元素）/lrange（LRANGE key start stop 获取列表片段，0 -1 返回整个列表）</li><li>lindex （返回索引的元素值，-1表示从最右边的第一位）</li><li>llen（获取list长度）</li><li>lrem（LREM key count value，返回被删除的个数）<br>count&gt;0，从左边开始删除前count个值为value的元素<br>count&lt;0，从右边开始删除前|count|个值为value的元素<br>count=0，删除所有值为value的元素</li><li>ltrim （根据传入索引截取保留对应列表片段）</li><li>rpoplpush（一个列表右移除转移另一个列表左插入）</li><li>lset（设值元素值）</li><li>linsert key  before/after val01 val02 （在val01之前或者之后插入val02）<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2></li><li>sadd（新增set元素，去重）/smembers（获取set集合）/sismember（判断是否set里的值）</li><li>scard（返回集合元素个数）</li><li>srem（ 删除集合中一个或多个元素，返回成功删除的个数）</li><li>srandmember（SRANDMEMBER key [count]）<br>根据count不同有不同结果，count大于元素总数时返回全部元素<br>count&gt;0 ，返回集合中count不重复的元素<br>count&lt;0，返回集合中count的绝对值个元素，但元素可能会重复</li><li>spop（随机出栈）</li><li>smove（smove k1 k2 val -&gt;将k1的val剪切到k2上）</li><li>sdiff【差集】（sdiff A B —-&gt;集合A和集合B，差集表示A-B，在A里有的元素B里没有，返回差集合；多个集合(A-B)-C）</li><li>sinter【交集】</li><li>sunion【并集】<h2 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h2></li><li>zadd（不存在添加，存在更新）</li><li>zscore（获取元素分数）</li><li>zrange（元素从小到大:加上withscores 返回带元素，即元素，分数，当分数一样时，按元素排序）</li><li>zrevrange（元素从大到小）</li><li>zrangebyscore（指定分数范围元素）<br>返回从小到大的在min和max之间的元素，( 左括号表示不包含，例如：80-100—&gt;(80 100<br>withscore返回带分数<br>limit offest count 向左偏移offest个元素，并获取前count个元素</li><li>zrevrangebyscore（从大到小排序）</li><li>zrem（删除元素）</li><li>zcard（计算集合内个数）</li><li>zcount（计算对应范围内个数）<br>eg：ZCOUNT salary 2000 5000          —-&gt;计算薪水在 2000-5000 之间的人数</li><li>zrank（获取下标值）</li><li>zrevrank（逆序获取下标值）</li><li>zscore（获取对应的分数）</li></ul>]]></content>
    
    <summary type="html">
    
      redis常用五种数据类型:string,hash,list,set,zset(sorted set).
    
    </summary>
    
      <category term="redis" scheme="http://blog.linzhongtai.cn/categories/redis/"/>
    
    
      <category term="redis" scheme="http://blog.linzhongtai.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程之synchronized、Lock、volatile</title>
    <link href="http://blog.linzhongtai.cn/2018/05/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8Bsynchronized%E3%80%81Lock%E3%80%81volatile/"/>
    <id>http://blog.linzhongtai.cn/2018/05/Java多线程之synchronized、Lock、volatile/</id>
    <published>2018-05-16T08:36:25.000Z</published>
    <updated>2018-05-16T08:36:25.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><blockquote><p>Java的关键字，是Java的内置特性，在JVM层面实现了对临界资源的同步互斥访问，通过对对象的头文件来操作，从而达到加锁和释放锁的目的</p></blockquote><ul><li>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生</li><li>不能响应中断</li><li>同一时刻不管是读还是写都只能有一个线程对共享资源操作，其他线程只能等待，性能不高</li></ul><blockquote><p>synchronized是Java中的关键字，是一种同步锁：</p></blockquote><ol><li>无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁对应的是类，该类所有的对象同一把锁。 </li><li>每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。 </li><li>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制</li></ol><h2 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h2><ul><li>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现</li><li>Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁</li><li>Lock可以让等待锁的线程响应中断，synchronized不可以</li><li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到</li><li>Lock可以提高多个线程进行读操作的效率<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public interface Lock &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 获取锁，如果锁被其他线程获取，则进行等待</span><br><span class="line">     */</span><br><span class="line">    void lock();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，</span><br><span class="line">     * 即中断线程的等待状态。也就是说，</span><br><span class="line">     * 当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，</span><br><span class="line">     * 假若此时线程A获取到了锁，而线程B只有在等待，</span><br><span class="line">     * 那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。</span><br><span class="line">     *</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     */</span><br><span class="line">    void lockInterruptibly() throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成</span><br><span class="line">     * 功，则返回true，如果获取失败（即锁已被其他线程获取），则返回</span><br><span class="line">     * false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</span><br><span class="line">     */</span><br><span class="line">    boolean tryLock();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，</span><br><span class="line">     * 只不过区别在于这个方法在拿不到锁时会等待一定的时间，</span><br><span class="line">     * 在时间期限之内如果还拿不到锁，就返回false。</span><br><span class="line">     * 如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</span><br><span class="line">     *</span><br><span class="line">     * @param time</span><br><span class="line">     * @param unit</span><br><span class="line">     * @return</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     */</span><br><span class="line">    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    void unlock(); //释放锁</span><br><span class="line"></span><br><span class="line">    Condition newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul><li>可见性：保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的</li><li>有序性：禁止进行指令重排序</li></ul><p>加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p><ol><li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成</li><li>它会强制将对缓存的修改操作立即写入主存</li><li>如果是写操作，它会导致其他CPU中对应的缓存行无效</li></ol><h2 id="lock和synchronized的区别"><a href="#lock和synchronized的区别" class="headerlink" title="lock和synchronized的区别"></a>lock和synchronized的区别</h2><ol><li>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</li><li>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</li><li>Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</li><li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</li><li>Lock可以提高多个线程进行读操作的效率。<br>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized</li></ol><h2 id="volatile和synchronized区别"><a href="#volatile和synchronized区别" class="headerlink" title="volatile和synchronized区别"></a>volatile和synchronized区别</h2><ol><li>volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取,synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住.</li><li>volatile仅能使用在变量级别,synchronized则可以使用在变量,方法.</li><li>volatile仅能实现变量的修改可见性,而synchronized则可以保证变量的修改可见性和原子性.<blockquote><p>《Java编程思想》上说，定义long或double变量时，如果使用volatile关键字，就会获得（简单的赋值与返回操作）原子性。 </p></blockquote></li><li>volatile不会造成线程的阻塞,而synchronized可能会造成线程的阻塞.</li><li>当一个域的值依赖于它之前的值时，volatile就无法工作了，如n=n+1,n++等。如果某个域的值受到其他域的值的限制，那么volatile也无法工作，如Range类的lower和upper边界，必须遵循lower&lt;=upper的限制。</li><li>使用volatile而不是synchronized的唯一安全的情况是类中只有一个可变的域</li></ol><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>如果锁具备可重入性，则称作为可重入锁。像<strong>synchronized和ReentrantLock（唯一实现了Lock接口的类）都是可重入锁</strong>，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2</p><h3 id="可中断锁"><a href="#可中断锁" class="headerlink" title="可中断锁"></a>可中断锁</h3><p><strong>在Java中，synchronized就不是可中断锁，而Lock是可中断锁</strong><br>如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁</p><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。<br>非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。<br><strong>在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序</strong>。<br>而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁</p><p>参考：<a href="https://blog.csdn.net/ztchun/article/details/60778950" target="_blank" rel="noopener">java中volatile、synchronized和lock解析</a>、<a href="http://www.cnblogs.com/dolphin0520/p/3923167.html" target="_blank" rel="noopener">Java并发编程：Lock</a></p>]]></content>
    
    <summary type="html">
    
      synchronized、Lock、volatile 特点以及区别
    
    </summary>
    
      <category term="JAVA" scheme="http://blog.linzhongtai.cn/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://blog.linzhongtai.cn/tags/JAVA/"/>
    
      <category term="多线程" scheme="http://blog.linzhongtai.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Springboot学习之禁用数据库自动配置</title>
    <link href="http://blog.linzhongtai.cn/2018/05/Springboot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%A6%81%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.linzhongtai.cn/2018/05/Springboot学习之禁用数据库自动配置/</id>
    <published>2018-05-15T07:16:45.000Z</published>
    <updated>2018-05-15T07:16:45.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>SpringBoot默认会自动配置数据库，如果业务不需要，就要手动禁用数据库自动配置,在Application的SpringBootApplication注解里加上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication(exclude = &#123;</span><br><span class="line">DataSourceAutoConfiguration.class,</span><br><span class="line">DataSourceTransactionManagerAutoConfiguration.class,</span><br><span class="line">HibernateJpaAutoConfiguration.class</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      springboot项目启动时，如果没有配置数据库配置，启动时会抛出异常...
    
    </summary>
    
      <category term="SpringBoot" scheme="http://blog.linzhongtai.cn/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://blog.linzhongtai.cn/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>JAVA集合总结</title>
    <link href="http://blog.linzhongtai.cn/2018/05/JAVA%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.linzhongtai.cn/2018/05/JAVA集合总结/</id>
    <published>2018-05-12T02:49:27.000Z</published>
    <updated>2018-05-12T02:49:27.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>Collection接口是集合类的根接口，Java中没有提供这个接口的直接的实现类。但是却让其被继承产生了两个接口，就是Set和List。Set中不能包含重复的元素。List是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式</p></blockquote><p>Map是Java.util包中的另一个接口，它和Collection接口没有关系，是相互独立的，但是都属于集合类的一部分。Map包含了key-value对。Map不能包含重复的key，但是可以包含相同的value</p><p>Iterator，所有的集合类，都实现了Iterator接口，这是一个用于遍历集合中元素的接口，主要包含以下三种方法：</p><ul><li>hasNext()是否还有下一个元素。</li><li>next()返回下一个元素。</li><li>remove()删除当前元素</li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><blockquote><p>List里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。</p></blockquote><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li>ArrayList在内存不够时默认是扩展50% + 1个，Vector是默认扩展1倍。</li><li>Vector属于线程安全级别的，但是大多数情况下不使用Vector，因为线程安全需要更大的系统开销。</li><li>一般使用ArrayList和LinkedList比较多，LinkedList不存在get()的操作，不能单个定位，ArrayList是顺序存储结构，LinkedList是链表存储结构</li><li>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针</li><li>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据</li></ul><h3 id="ArrayList（常用、数组实现，对元素快速随机访问）"><a href="#ArrayList（常用、数组实现，对元素快速随机访问）" class="headerlink" title="ArrayList（常用、数组实现，对元素快速随机访问）"></a>ArrayList（常用、数组实现，对元素快速随机访问）</h3><p>ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除</p><h3 id="Vector（数组实现、线程同步、需高花费）"><a href="#Vector（数组实现、线程同步、需高花费）" class="headerlink" title="Vector（数组实现、线程同步、需高花费）"></a>Vector（数组实现、线程同步、需高花费）</h3><p>Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢</p><h3 id="LinkedList（链表结构、Queue）"><a href="#LinkedList（链表结构、Queue）" class="headerlink" title="LinkedList（链表结构、Queue）"></a>LinkedList（链表结构、Queue）</h3><p>LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用</p><blockquote><p>ArrayList和LinkedList在用法上没有区别，但是在功能上还是有区别的。LinkedList经常用在增删操作较多而查询操作很少的情况下，ArrayList则相反</p></blockquote><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><blockquote><p>Set集合不允许出现重复数据<br>允许包含值为null的元素，但最多只能有一个null元素。</p></blockquote><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><ul><li>HashSet中不能有重复的元素</li><li>HashSet是无序的</li><li>HashSet也是基于HashMap实现</li></ul><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><ul><li>TreeSet中不能有重复的元素；</li><li>TreeSet具有排序功能，缺省是按照自然排序进行排列</li><li>TreeSet中的元素必须实现Comparable接口并重写compareTo()方法，TreeSet判断元素是否重复 、以及确定元素的顺序靠的都是这个方法</li><li>基于TreeMap实现</li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><blockquote><p>Map集合中存储的是键值对，键不能重复，值可以重复。根据键得到值，对map集合遍历时先得到键的set集合，对set集合进行遍历，得到相应的值</p></blockquote><p>Map遍历：KeySet()、entrySet()<br>keySet其实是遍历了2次，一次是转为iterator，一次就是从HashMap中取出key所对于的value。而entryset只是遍历了第一次，它把key和value都放到了entry中，所以<strong>entrySet效率较高</strong></p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap是最常用的Map，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。因为键对象不可以重复，所以HashMap最多只允许一条记录的键为Null，允许多条记录的值为Null，是非同步的</p><ul><li>HashMap是无序的散列映射表；</li><li>HashMap通过Hash 算法来决定存储位置</li><li>底层实现是哈希表</li></ul><h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>Hashtable与HashMap类似，是HashMap的线程安全版，它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢，它继承自Dictionary类，不同的是它不允许记录的键或者值为null，同时效率较低</p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序（自然顺序），也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。不允许key值为空，非同步的</p><ul><li>适用于按自然顺序或自定义顺序遍历键(key)。</li><li>底层是二叉树</li><li>提供compareTo，可以定义排序方法</li></ul><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>LinkedHashMap保存了记录的插入顺序，在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢，有HashMap的全部特性。</p><h3 id="ConcurrentHashMap-线程安全"><a href="#ConcurrentHashMap-线程安全" class="headerlink" title="ConcurrentHashMap 线程安全"></a>ConcurrentHashMap 线程安全</h3><ul><li>JDK1.7分析：ConcurrentHashMap采用 分段锁的机制，实现并发的更新操作，底层采用数组+链表的存储结构</li><li>JDK1.8分析：1.8的实现已经抛弃了Segment分段锁机制，利用CAS+Synchronized来保证并发更新的安全，底层采用数组+链表+红黑树的存储结构</li><li>CAS的思想：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。</li></ul><h2 id="主要实现类区别"><a href="#主要实现类区别" class="headerlink" title="主要实现类区别"></a>主要实现类区别</h2><h3 id="Vector-VS-ArrayList"><a href="#Vector-VS-ArrayList" class="headerlink" title="Vector VS ArrayList"></a>Vector VS ArrayList</h3><ul><li>vector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用arraylist效率比较高。</li><li>如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%，而arraylist增长率为目前数组长度的50%。如果在集合中使用数据量比较大的数据，用vector有一定的优势。</li><li>如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，如果频繁的访问数据，这个时候使用vector和arraylist都可以。而如果移动一个指定位置会导致后面的元素都发生移动，这个时候就应该考虑到使用linklist,因为它移动一个指定位置的数据时其它元素不移动。</li><li>ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要涉及到数组元素移动等内存操作，所以索引数据快，插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快</li></ul><h3 id="ArrayList-VS-LinkedList"><a href="#ArrayList-VS-LinkedList" class="headerlink" title="ArrayList VS LinkedList"></a>ArrayList VS LinkedList</h3><ul><li>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</li><li>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</li><li>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据</li></ul><h3 id="HashMap-VS-TreeMap"><a href="#HashMap-VS-TreeMap" class="headerlink" title="HashMap VS TreeMap"></a>HashMap VS TreeMap</h3><ul><li>HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。</li><li>在Map 中插入、删除和定位元素，HashMap是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。<br>两个map中的元素一样，但顺序不一样，导致hashCode()不一样。<br>同样做测试：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在HashMap中，同样的值的map,顺序不同，equals时，false;</span><br><span class="line">而在treeMap中，同样的值的map,顺序不同,equals时，true，</span><br><span class="line">说明treeMap在equals()时是整理了顺序了的</span><br></pre></td></tr></table></figure></li></ul><h3 id="HashTable-VS-HashMap"><a href="#HashTable-VS-HashMap" class="headerlink" title="HashTable VS HashMap"></a>HashTable VS HashMap</h3><ul><li>同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的。</li><li>HashMap允许存在一个为null的key，多个为null的value 。</li><li>hashtable的key和value都不允许为null</li></ul><p>参考：<a href="https://www.cnblogs.com/leeplogs/p/5891861.html" target="_blank" rel="noopener">JAVA集合类汇总</a>、<a href="https://blog.csdn.net/initphp/article/details/8264219" target="_blank" rel="noopener">深入理解Java集合</a></p>]]></content>
    
    <summary type="html">
    
      List/Set/Map
    
    </summary>
    
      <category term="JAVA" scheme="http://blog.linzhongtai.cn/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://blog.linzhongtai.cn/tags/JAVA/"/>
    
      <category term="Collection" scheme="http://blog.linzhongtai.cn/tags/Collection/"/>
    
  </entry>
  
  <entry>
    <title>MySQL两种引擎的区别</title>
    <link href="http://blog.linzhongtai.cn/2018/05/MySQL%E4%B8%A4%E7%A7%8D%E5%BC%95%E6%93%8E%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://blog.linzhongtai.cn/2018/05/MySQL两种引擎的区别/</id>
    <published>2018-05-11T02:58:59.000Z</published>
    <updated>2018-05-11T02:58:59.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="Innodb引擎"><a href="#Innodb引擎" class="headerlink" title="Innodb引擎"></a>Innodb引擎</h2><p>Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。</p><h2 id="MyISAM引擎"><a href="#MyISAM引擎" class="headerlink" title="MyISAM引擎"></a>MyISAM引擎</h2><p>MyISAM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，MyISAM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyISAM也是很好的选择。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol><li><p>MyISAM是非事务安全的，而InnoDB是事务安全的</p></li><li><p>MyISAM锁的粒度是表级的，而InnoDB支持行级锁</p></li><li><p>MyISAM支持全文类型索引，而InnoDB不支持全文索引</p></li><li><p>MyISAM相对简单，效率上要优于InnoDB，小型应用可以考虑使用MyISAM</p></li><li><p>MyISAM表保存成文件形式，跨平台使用更加方便</p></li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>MyIASM管理非事务表，提供高速存储和检索以及全文搜索能力，如果再应用中执行大量select操作，应该选择MyIASM</li><li>InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量insert和update操作，应该选择InnoDB</li></ol><p>摘抄：<a href="https://blog.csdn.net/ls5718/article/details/52248040" target="_blank" rel="noopener">MySQL两种引擎的区别</a></p>]]></content>
    
    <summary type="html">
    
      Innodb、MyISAM
    
    </summary>
    
      <category term="Mysql" scheme="http://blog.linzhongtai.cn/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://blog.linzhongtai.cn/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制</title>
    <link href="http://blog.linzhongtai.cn/2018/05/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://blog.linzhongtai.cn/2018/05/Redis主从复制/</id>
    <published>2018-05-10T14:44:20.000Z</published>
    <updated>2018-05-10T14:44:20.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="配置从库，不配主库"><a href="#配置从库，不配主库" class="headerlink" title="配置从库，不配主库"></a>配置从库，不配主库</h2><h2 id="从库配置：slaveof-主库ip-主库端口"><a href="#从库配置：slaveof-主库ip-主库端口" class="headerlink" title="从库配置：slaveof 主库ip 主库端口"></a>从库配置：slaveof <strong>主库ip</strong> <strong>主库端口</strong></h2><p>每次与master断开后，都需要重新连接，除非配置redis.conf文件</p><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><h2 id="常用3招"><a href="#常用3招" class="headerlink" title="常用3招"></a>常用3招</h2><ul><li>一主二仆</li><li>薪火相传</li><li>反客为主（slaveof no one）</li></ul><h2 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h2><p>salve 启动成功连接到master后会发送一个sync命令，master接到命令后启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，进程执行完毕后，master将传送整个数据文件到slave，以完成一次完全同步，也就是<strong>全量复制</strong>，而slave服务在接收到数据后，存盘到内存中；master将新的修改命令依次传给slave，完成同步，此时为<strong>增量复制</strong></p><blockquote><p>只要重新连接master，一次完全同步（全量复制）将被自动执行</p></blockquote><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><blockquote><p>反客为主的自动版本，监控主机是否故障，当主库挂了，根据投票数重新选定master</p></blockquote><ul><li>新建sentinel.conf</li><li><p>配置文件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor 自定义名称 监控库ip 监控库端口 1</span><br></pre></td></tr></table></figure></li><li><p>启动哨兵</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /usr/local/redis/sentinel.conf</span><br></pre></td></tr></table></figure></li></ul><p>自动监控，选好新master后，原master恢复后会变成slave</p><blockquote><p>一组sentinel可以同时监控多个master</p></blockquote><h2 id="复制的缺点"><a href="#复制的缺点" class="headerlink" title="复制的缺点"></a>复制的缺点</h2><p>由于所有的写操作都在master上，然后同步更新到slave上，所以从master同步到slave   机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，slave机器数量的增加也会使得这个问题更加严重</p>]]></content>
    
    <summary type="html">
    
      一主二仆/薪火相传/反客为主...
    
    </summary>
    
      <category term="redis" scheme="http://blog.linzhongtai.cn/categories/redis/"/>
    
    
      <category term="redis" scheme="http://blog.linzhongtai.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化存储</title>
    <link href="http://blog.linzhongtai.cn/2018/05/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/"/>
    <id>http://blog.linzhongtai.cn/2018/05/Redis持久化存储/</id>
    <published>2018-05-09T13:14:11.000Z</published>
    <updated>2018-05-09T13:14:11.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="Redis中数据存储模式"><a href="#Redis中数据存储模式" class="headerlink" title="Redis中数据存储模式"></a>Redis中数据存储模式</h2><blockquote><p>cache-only<br>persistence</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cache-only：只做为“缓存”服务，不持久数据，数据在服务终止后将消失，</span><br><span class="line">此模式下也将不存在“数据恢复”的手段，是一种安全性低/效率高/容易扩展的方式；</span><br><span class="line">persistence：为内存中的数据持久备份到磁盘文件，在服务重启后可以恢复，</span><br><span class="line">此模式下数据相对安全。</span><br></pre></td></tr></table></figure><p>对于persistence持久化存储，Redis提供了两种持久化方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Redis DataBase(简称RDB)</span><br><span class="line">Append-only file (简称AOF)</span><br></pre></td></tr></table></figure></p><blockquote><p>如果同时开启两种持久化，会优先加载AOF进行恢复</p></blockquote><h2 id="RDB持久化：默认开启"><a href="#RDB持久化：默认开启" class="headerlink" title="RDB持久化：默认开启"></a>RDB持久化：默认开启</h2><blockquote><p>指定时间间隔进行快照存储</p></blockquote><p>优点：使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了redis的高性能<br>缺点：RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候</p><ul><li>save：服务器进程进行快照存储（阻塞）</li><li>bgsave：进行异步快照存储（派生子进程处理，非阻塞）</li><li>异常恢复：redis-check-rdb<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#dbfilename：持久化数据存储在本地的文件</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">#dir：持久化数据存储在本地的路径，如果是在/redis/redis-3.0.6/src下</span><br><span class="line">启动的redis-cli，则数据会存储在当前src目录下</span><br><span class="line">dir ./</span><br><span class="line">##snapshot触发的时机，save &lt;seconds&gt; &lt;changes&gt;  </span><br><span class="line">##如下为900秒后，至少有一个变更操作，才会snapshot  </span><br><span class="line">##对于此值的设置，</span><br><span class="line">需要谨慎，评估系统的变更操作密集程度  </span><br><span class="line">##可以通过save “”来关闭snapshot功能  </span><br><span class="line">#持久化(以快照的方式) 策略（默认）</span><br><span class="line">save 900 1       （15分钟变更一次）</span><br><span class="line">save 300 10     （5分钟变更10次）</span><br><span class="line">save 60 10000  （1分钟变更1万次）</span><br><span class="line">##当snapshot时出现错误无法继续时，是否阻塞客户端“变更操作”，</span><br><span class="line">“错误”可能因为磁盘已满/磁盘故障/OS级别异常等  </span><br><span class="line">stop-writes-on-bgsave-error yes  </span><br><span class="line">##是否启用rdb文件压缩，默认为“yes”，压缩往往意味着“额外的cpu消耗”，</span><br><span class="line">同时也意味这较小的文件尺寸以及较短的网络传输时间  </span><br><span class="line">rdbcompression yes</span><br></pre></td></tr></table></figure></li></ul><h2 id="AOF持久化：默认不开启"><a href="#AOF持久化：默认不开启" class="headerlink" title="AOF持久化：默认不开启"></a>AOF持久化：默认不开启</h2><blockquote><p>以日志的形式来记录每个写操作，将redis执行过的所有写指令记录下来（读操作不记录），只许追加但不可以改写文件，redis启动之初会读取改文件进行重新构建数据</p></blockquote><ul><li>AOF通过保存所有修改数据库的写命令请求来记录服务器的数据库状态</li><li><p>AOF文件中的所有命令都会以Redis命令请求协议的格式保存<br>优点：可以保持更高的数据完整性，如果设置追加file的时间是1s，如果redis发生故障，最多会丢失1s的数据（appendfsync—&gt;everysec）；且如果日志写入不完整支持redis-check-aof来进行日志修复；AOF文件没被rewrite之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的flushall）。<br>缺点：AOF文件比RDB文件大，且恢复速度慢，运行效率也比rdb慢。</p><h3 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a>重写机制</h3><blockquote><p>当超过阈值，则启动内容压缩，只保留最小指令集，可使用命令：bgrewriteaof</p></blockquote></li><li><p>定义：AOF采用文件追加的方式持久化数据，所以文件会越来越大，为了避免这种情况发生，增加了重写机制<br>当AOF文件的大小超过了配置所设置的阙值时，Redis就会启动AOF文件压缩，只保留可以恢复数据的最小指令集，可以使用命令bgrewriteaof</p></li><li>原理：当AOF增长过大时，会fork出一条新的进程将文件重写(也是先写临时文件最后rename)，遍历新进程的内存数据，每条记录有一条set语句。<br>重写AOF文件并没有操作旧的AOF文件，而是将整个内存中的数据内容用命令的方式重写了一个新的aof文件（有点类似快照）</li><li>触发机制：Redis会记录上次重写时的AOF文件大小，默认配置时当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100  （一倍）</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure></li></ul><h3 id="持久化策略"><a href="#持久化策略" class="headerlink" title="持久化策略"></a>持久化策略</h3><ul><li>appendfsync always (同步持久化，每次发生数据变更会被立即记录到磁盘，性能差但数据完整性比较好)</li><li>appendfsync everysec (异步操作，每秒记录，如果一秒钟内宕机，有数据丢失)</li><li>appendfsync no  （将缓存回写的策略交给系统，linux 默认是30秒将缓冲区的数据回写硬盘的）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">##此选项为aof功能的开关，默认为“no”，可以通过“yes”来开启aof功能  </span><br><span class="line">##只有在“yes”下，aof重写/文件同步等特性才会生效  </span><br><span class="line">appendonly yes  </span><br><span class="line"></span><br><span class="line">##指定aof文件名称  </span><br><span class="line">appendfilename appendonly.aof  </span><br><span class="line"></span><br><span class="line">##指定aof操作中文件同步策略，有三个合法值：always(记录立即同步，性能较差) everysec(每秒同步，官方推荐) no(将缓存回写的策略交给系统，linux 默认是30秒将缓冲区的数据回写硬盘的)，默认为everysec  </span><br><span class="line">appendfsync everysec  </span><br><span class="line">##在aof-rewrite期间，appendfsync是否暂缓文件同步，&quot;no&quot;表示“不暂缓”，“yes”表示“暂缓”，默认为“no”  </span><br><span class="line">no-appendfsync-on-rewrite no  </span><br><span class="line"></span><br><span class="line">##aof文件rewrite触发的最小文件尺寸(mb,gb),只有大于此aof文件大于此尺寸是才会触发rewrite，默认“64mb”  </span><br><span class="line">auto-aof-rewrite-min-size 64mb  </span><br><span class="line"></span><br><span class="line">##相对于“上一次”rewrite，本次rewrite触发时aof文件应该增长的百分比。  </span><br><span class="line">##每一次rewrite之后，redis都会记录下此时“新aof”文件的大小(例如A)，那么当aof文件增长到A*(1 + p)之后  </span><br><span class="line">##触发下一次rewrite，每一次aof记录的添加，都会检测当前aof文件的尺寸。  </span><br><span class="line">auto-aof-rewrite-percentage 100</span><br></pre></td></tr></table></figure></li></ul><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><ul><li>RDB与AOF同时开启  默认先加载AOF的配置文件</li><li>相同数据集，AOF文件要远大于RDB文件，恢复速度慢于RDB</li><li>AOF运行效率慢于RDB,但是同步策略效率好，不同步效率和RDB相同</li></ul>]]></content>
    
    <summary type="html">
    
      AOF、RDB
    
    </summary>
    
      <category term="redis" scheme="http://blog.linzhongtai.cn/categories/redis/"/>
    
    
      <category term="redis" scheme="http://blog.linzhongtai.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Java常见设计模式</title>
    <link href="http://blog.linzhongtai.cn/2018/04/Java%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.linzhongtai.cn/2018/04/Java常见设计模式/</id>
    <published>2018-04-16T05:30:03.000Z</published>
    <updated>2018-04-16T05:30:03.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点</p></blockquote><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */  </span><br><span class="line">    private static Singleton instance = null;  </span><br><span class="line">  </span><br><span class="line">    /* 私有构造方法，防止被实例化 */  </span><br><span class="line">    private Singleton() &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    /* 1:懒汉式，静态工程方法，创建实例 */  </span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">        if (instance == null) &#123;  </span><br><span class="line">            instance = new Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：<br>Singleton.getInstance().method();<br><strong>优点</strong>：延迟加载（需要的时候才去加载）,适合单线程操作<br><strong>缺点</strong>： 线程不安全，在多线程中很容易出现不同步的情况，如在数据库对象进行的频繁读写操作时。</p><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><blockquote><p>在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class EagerSingleton &#123;</span><br><span class="line">    //饿汉单例模式</span><br><span class="line">    //在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快</span><br><span class="line">    private static EagerSingleton instance = new EagerSingleton();//静态私有成员，已初始化</span><br><span class="line"></span><br><span class="line">    private EagerSingleton() </span><br><span class="line">    &#123;</span><br><span class="line">        //私有构造函数</span><br><span class="line">    &#125;</span><br><span class="line">    public static EagerSingleton getInstance()    //静态，不用同步（类加载时已初始化，不会有多线程的问题）</span><br><span class="line">    &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双重线程检查模式"><a href="#双重线程检查模式" class="headerlink" title="双重线程检查模式"></a>双重线程检查模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonInner &#123;  </span><br><span class="line">    private static volatile SingletonInner sInst = null;  // &lt;&lt;&lt; 这里添加了 volatile  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 私有的构造函数 </span><br><span class="line">     */  </span><br><span class="line">    private SingletonInner() &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    public static SingletonInner getInstance() &#123;  </span><br><span class="line">        SingletonInner inst = sInst;  // &lt;&lt;&lt; 在这里创建临时变量</span><br><span class="line">        if (inst == null) &#123;</span><br><span class="line">            synchronized (SingletonInner.class) &#123;</span><br><span class="line">                inst = sInst;</span><br><span class="line">                if (inst == null) &#123;</span><br><span class="line">                    inst = new SingletonInner();</span><br><span class="line">                    sInst = inst;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return inst;  // &lt;&lt;&lt; 注意这里返回的是临时变量</span><br><span class="line">    &#125;</span><br><span class="line">    protected void method() &#123;  </span><br><span class="line">        System.out.println(&quot;SingletonInner&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>volatile</strong>：<br><strong>可见性</strong>（volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新）<br><strong>防止指令重排序</strong>（赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障）<br>调用：<br>Singleton.getInstance().method();<br><strong>优点</strong>：延迟加载，线程安全<br><strong>缺点</strong>：写法复杂，不简洁</p><h3 id="内部类模式"><a href="#内部类模式" class="headerlink" title="内部类模式"></a>内部类模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonInner &#123;  </span><br><span class="line">    /** </span><br><span class="line">     * 内部类实现单例模式 </span><br><span class="line">     * 延迟加载，减少内存开销   </span><br><span class="line">     */  </span><br><span class="line">    private static class SingletonHolder &#123;  </span><br><span class="line">        private static SingletonInner instance = new SingletonInner();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 私有的构造函数 </span><br><span class="line">     */  </span><br><span class="line">    private SingletonInner() &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    public static SingletonInner getInstance() &#123;  </span><br><span class="line">        return SingletonHolder.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    protected void method() &#123;  </span><br><span class="line">        System.out.println(&quot;SingletonInner&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：<br>Singleton.getInstance().method();<br><strong>优点</strong>：延迟加载，线程安全（java中class加载时互斥的），也减少了内存消耗，推荐使用内部类方式。</p>]]></content>
    
    <summary type="html">
    
      单例/工厂/代理/适配...
    
    </summary>
    
      <category term="JAVA" scheme="http://blog.linzhongtai.cn/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://blog.linzhongtai.cn/tags/JAVA/"/>
    
      <category term="设计模式" scheme="http://blog.linzhongtai.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工作中的代码优化</title>
    <link href="http://blog.linzhongtai.cn/2018/04/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    <id>http://blog.linzhongtai.cn/2018/04/工作中的代码优化/</id>
    <published>2018-04-13T07:24:59.000Z</published>
    <updated>2018-04-13T07:24:59.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="函数式接口改造"><a href="#函数式接口改造" class="headerlink" title="函数式接口改造"></a>函数式接口改造</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private TopModel generateTopDetailModel(TopModel topModel, List&lt;PlayerWithData&gt; playerWithDataList) &#123;</span><br><span class="line">       List&lt;TopDetailModel&gt; shotsTopDetail = playerWithDataList.stream()</span><br><span class="line">               .filter(p -&gt; p.getShots() != null &amp;&amp; p.getShots() != 0)//要过滤掉空值再比较,且要过滤掉0值</span><br><span class="line">               .sorted(Comparator.comparing(PlayerWithData::getShots).reversed()</span><br><span class="line">                       .thenComparing(PlayerWithData::getName)).</span><br><span class="line">                       limit(3).map(StatsPlayer -&gt; &#123;</span><br><span class="line">                   TopDetailModel model = new TopDetailModel();</span><br><span class="line">                   BeanUtils.copyProperties(StatsPlayer, model);</span><br><span class="line">                   model.setDataCount(StatsPlayer.getShots());</span><br><span class="line">                   return model;</span><br><span class="line">               &#125;).collect(Collectors.toList());</span><br><span class="line">       topModel.setShots(shotsTopDetail);</span><br><span class="line"></span><br><span class="line">       List&lt;TopDetailModel&gt; maxDribbSpTopDetail = playerWithDataList.stream().</span><br><span class="line">               filter(p -&gt; p.getMaxDribbSp() != null &amp;&amp; p.getMaxDribbSp() != 0.0)</span><br><span class="line">               .sorted(Comparator.comparing(PlayerWithData::getMaxDribbSp).reversed()</span><br><span class="line">                       .thenComparing(PlayerWithData::getName)).</span><br><span class="line">                       limit(3).map(StatsPlayer -&gt; &#123;</span><br><span class="line">                   TopDetailModel model = new TopDetailModel();</span><br><span class="line">                   BeanUtils.copyProperties(StatsPlayer, model);</span><br><span class="line">                   model.setDataCount(StatsPlayer.getMaxDribbSp());</span><br><span class="line">                   return model;</span><br><span class="line">               &#125;).collect(Collectors.toList());</span><br><span class="line">       topModel.setMaxDribbSp(maxDribbSpTopDetail);</span><br><span class="line">       //省略N个字段的获取设值...</span><br><span class="line">       return topModel;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;TopDetailModel&gt; setIntegerTopModel(List&lt;PlayerWithData&gt; playerWithDataList,</span><br><span class="line">                                                   Function&lt;PlayerWithData, Integer&gt; function, Integer count) &#123;</span><br><span class="line">       return playerWithDataList.stream()</span><br><span class="line">               .filter(p -&gt; function.apply(p) != null &amp;&amp; function.apply(p) != 0)</span><br><span class="line">               .sorted(Comparator.comparing(function).reversed()</span><br><span class="line">                       .thenComparing(PlayerWithData::getName)).</span><br><span class="line">                       limit(count).map(stasPlayer -&gt; &#123;</span><br><span class="line">                   TopDetailModel model = new TopDetailModel();</span><br><span class="line">                   BeanUtils.copyProperties(stasPlayer, model);</span><br><span class="line">                   model.setDataCount(function);</span><br><span class="line">                   return model;</span><br><span class="line">               &#125;).collect(Collectors.toList());</span><br><span class="line">   &#125;</span><br><span class="line"> 之后每个参数传入函数方法调用设值即可：</span><br><span class="line"> topModel.setShots(setIntegerTopModel(playerWithDataList, PlayerWithData::getShots, count));</span><br></pre></td></tr></table></figure><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (PenaltyModel penaltyModel : penaltyModels) &#123;</span><br><span class="line">            String eventType = &quot;PENALTY.&quot;;</span><br><span class="line">            if (penaltyModel.getIsGoal()) &#123;</span><br><span class="line">                eventType = eventType + &quot;TRUE&quot;;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                eventType = eventType + &quot;FALSE&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">            每次循环都会创建新对象，造成内存资源浪费</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，</span><br><span class="line">即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的</span><br><span class="line">String：适用于少量的字符串操作的情况</span><br><span class="line">StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况</span><br><span class="line">StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</span><br></pre></td></tr></table></figure><h2 id="枚举命名"><a href="#枚举命名" class="headerlink" title="枚举命名"></a>枚举命名</h2><p>建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开<br>正例：BallEnum    反例：BallType</p><h2 id="避免在循环中进行数据库操作"><a href="#避免在循环中进行数据库操作" class="headerlink" title="避免在循环中进行数据库操作"></a>避免在循环中进行数据库操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void uploadTeamConfig(List&lt;TeamConfig&gt; teamConfigList, String matchId) &#123;</span><br><span class="line">      if (!CollectionUtils.isEmpty(teamConfigList)) &#123;</span><br><span class="line">          for (TeamConfig teamConfig : teamConfigList) &#123;</span><br><span class="line">              PerMatchTeamConfig perMatchTeamConfig = new PerMatchTeamConfig();</span><br><span class="line">              BeanUtils.copyProperties(teamConfig, perMatchTeamConfig);</span><br><span class="line">              perMatchTeamConfig.setMatchId(matchId);</span><br><span class="line">              perMatchTeamConfigService.saveOrUpdateByMatchIdAndTeamId(perMatchTeamConfig);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      记录一些工作中遇到的可优化的代码片段
    
    </summary>
    
      <category term="优化" scheme="http://blog.linzhongtai.cn/categories/%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="JAVA" scheme="http://blog.linzhongtai.cn/tags/JAVA/"/>
    
      <category term="优化" scheme="http://blog.linzhongtai.cn/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习之actuator</title>
    <link href="http://blog.linzhongtai.cn/2018/04/SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8Bactuator/"/>
    <id>http://blog.linzhongtai.cn/2018/04/SpringBoot学习之actuator/</id>
    <published>2018-04-12T08:50:14.000Z</published>
    <updated>2018-04-12T08:50:14.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="应用配置类"><a href="#应用配置类" class="headerlink" title="应用配置类"></a>应用配置类</h2><h3 id="autoconfig"><a href="#autoconfig" class="headerlink" title="/autoconfig"></a>/autoconfig</h3><p>用来获取应用的自动化配置报告，其中包括所有自动化配置的候选项。该端点可以帮助我们方便找到一些自动化配置为什么没有生效的具体原因。</p><ul><li>positiveMatches：返回条件匹配成功的自动化配置</li><li>negativeMatches：返回条件匹配不成功的自动化配置</li></ul><h3 id="beans"><a href="#beans" class="headerlink" title="/beans"></a>/beans</h3><p>获取应用上下文创建的所有Bean</p><h3 id="configprops"><a href="#configprops" class="headerlink" title="/configprops"></a>/configprops</h3><p>获取应用中配置的属性信息报告。prefix属性代表了属性的配置前缀，properties代表了各个属性的名称和值。如果要关闭该端点，通过使用endpoints.configprops.enabled=false来完成设置</p><h3 id="env"><a href="#env" class="headerlink" title="/env"></a>/env</h3><p>该端点主要是用来获取应用中所有可用的环境属性报告。包括环境变量、JVM属性、应用的配置属性、命令行的参数。该端点会进行隐私保护，对于password、serect、key等关键词会使用*来替代实际的属性值</p><h3 id="mappings"><a href="#mappings" class="headerlink" title="/mappings"></a>/mappings</h3><p>返回所有SpringMVC的控制器映射关系报告</p><h3 id="info"><a href="#info" class="headerlink" title="/info"></a>/info</h3><p>返回自定义的配置信息，该自定义配置信息需要以info为前缀进行配置，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">info.app.name=spring-hello</span><br><span class="line">info.app.version=v0.0.1</span><br></pre></td></tr></table></figure></p><h2 id="度量指标类"><a href="#度量指标类" class="headerlink" title="度量指标类"></a>度量指标类</h2><h3 id="metrics"><a href="#metrics" class="headerlink" title="/metrics"></a>/metrics</h3><p>返回当前应用的各类重要度量指标，比如内存信息、线程信息、垃圾回收信息等。</p><ul><li>系统信息：包括处理器数量processors、运行时间uptime和instance.uptime、系统平均负载systemload.average</li><li>mem.* ：内存概要情况</li><li>heap.* ：堆内存使用情况</li><li>noheap.* ： 非堆内存使用情况</li><li>threads.*：线程使用情况，包括线程数、守护线程数（daemon）、线程峰值（peak）等</li><li>classes.*：应用加载和卸载的类统计</li><li>gc.*：垃圾收集器的详细信息，包括垃圾回收次数gc.ps_scavenge.count、垃圾回收消耗时间gc.ps_scavenge.time、标记-清楚算法的次数gc.ps_marksweep.count、标记-清楚算法的消耗时间gc.ps_marksweep.time</li><li>httpsessions.*：Tomcat容器的会话使用情况，包括最大会话数httpsessions.max和活跃会话数httpsessions.active，该度量指标仅在引入嵌入式Tomcat作为应用容器才会提供</li><li>gauge.* ：HTTP请求的性能指标之一，主要用来反映一个绝对数值，比如gauge.response.hello:5，表示上一次hello请求的延迟时间为5毫秒</li><li>counter.*：HTTP请求的性能指标之一，主要作为计数器使用，记录了增加量和减少量，counter.status.200.hello:11，表示hello请求返回200状态的次数为11</li></ul><blockquote><p>可以通过/metrics/{name}接口来获取更细粒度的度量信息，比如通过/metrics/mem.free来获取当前可用内存数量</p></blockquote><h3 id="health"><a href="#health" class="headerlink" title="/health"></a>/health</h3><p>获取应用的各类健康指标信息</p><h3 id="dump"><a href="#dump" class="headerlink" title="/dump"></a>/dump</h3><p>用来暴露程序运行中的线程信息</p><h3 id="trace"><a href="#trace" class="headerlink" title="/trace"></a>/trace</h3><p>返回基本的HTTP跟踪信息，始终保留最近的100条请求记录</p><h2 id="操作控制类"><a href="#操作控制类" class="headerlink" title="操作控制类"></a>操作控制类</h2><p>在原生端点中，只提供了一个用来关闭应用的端点：/shutdown，通过如下配置开启<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">endpoints.shutdown.enabled=true</span><br></pre></td></tr></table></figure></p><p>配置好了之后，只要访问该端点，就能实现关闭该应用的远程操作，后续Eureka中还会有许多控制端点…</p>]]></content>
    
    <summary type="html">
    
      提供一系列用户监控的端点
    
    </summary>
    
      <category term="SpringBoot" scheme="http://blog.linzhongtai.cn/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://blog.linzhongtai.cn/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>《书单》</title>
    <link href="http://blog.linzhongtai.cn/2018/04/%E3%80%8A%E4%B9%A6%E5%8D%95%E3%80%8B/"/>
    <id>http://blog.linzhongtai.cn/2018/04/《书单》/</id>
    <published>2018-04-09T11:52:33.000Z</published>
    <updated>2018-04-09T11:52:33.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><ul><li>锋利的Jquery</li><li>JavaScript高级程序设计</li><li>Maven</li><li>Spring实战 第四版</li></ul><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><ul><li>Java8实战</li><li>Redis设计与实现</li><li>SpringBoot实战</li><li>深入理解Java虚拟机</li><li>Spring Cloud与Docker微服务架构实战</li><li>SpringCloud微服务实战</li><li>鸟哥的linux私房菜-服务器架设（待定）</li></ul>]]></content>
    
    <summary type="html">
    
      书中自有颜如玉
    
    </summary>
    
      <category term="书单" scheme="http://blog.linzhongtai.cn/categories/%E4%B9%A6%E5%8D%95/"/>
    
    
      <category term="书单" scheme="http://blog.linzhongtai.cn/tags/%E4%B9%A6%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Stream结合RabbitMQ简单实例</title>
    <link href="http://blog.linzhongtai.cn/2018/03/Spring-Cloud-Stream%E7%BB%93%E5%90%88RabbitMQ%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/"/>
    <id>http://blog.linzhongtai.cn/2018/03/Spring-Cloud-Stream结合RabbitMQ简单实例/</id>
    <published>2018-03-27T06:10:18.000Z</published>
    <updated>2018-03-27T06:10:18.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="了解Spring-Cloud-Stream"><a href="#了解Spring-Cloud-Stream" class="headerlink" title="了解Spring Cloud Stream"></a><a href="https://springcloud.cc/spring-cloud-dalston.html#_spring_cloud_stream" target="_blank" rel="noopener">了解Spring Cloud Stream</a></h2><h2 id="了解RabbitMQ"><a href="#了解RabbitMQ" class="headerlink" title="了解RabbitMQ"></a><a href="http://blog.linzhongtai.cn/2018/03/%E4%B9%9D%E6%B5%85%E4%B8%80%E6%B7%B1%E4%B9%8BRabbitMQ/">了解RabbitMQ</a></h2><h2 id="各项目中引入依赖"><a href="#各项目中引入依赖" class="headerlink" title="各项目中引入依赖"></a>各项目中引入依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="生产者A"><a href="#生产者A" class="headerlink" title="生产者A"></a>生产者A</h2><h3 id="A项目中新建一个接口作为通道"><a href="#A项目中新建一个接口作为通道" class="headerlink" title="A项目中新建一个接口作为通道"></a>A项目中新建一个接口作为通道</h3><blockquote><p>NotifyChannelConstant为自定义常量<br>@Output注解代表这是一个输出通道</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public interface PdfNotifyChannel &#123;</span><br><span class="line"></span><br><span class="line">    @Output(NotifyChannelConstant.PDF_NOTIFY_CHANNEL)</span><br><span class="line">    MessageChannel output();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绑定接口-EnableBinding"><a href="#绑定接口-EnableBinding" class="headerlink" title="绑定接口@EnableBinding"></a>绑定接口@EnableBinding</h3><ul><li>进行消息通知的类，需要添加@EnableBinding(PdfNotifyChannel.class)，指定绑定的接口通道</li><li><p>在类中进行初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private PdfNotifyChannel pdfNotifyChannel;</span><br></pre></td></tr></table></figure></li><li><p>业务方法中进行调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pdfNotifyChannel.output().send(MessageBuilder.withPayload(msg).build());</span><br></pre></td></tr></table></figure></li></ul><h2 id="消费者B"><a href="#消费者B" class="headerlink" title="消费者B"></a>消费者B</h2><h3 id="B项目中新建一个接口作为通道"><a href="#B项目中新建一个接口作为通道" class="headerlink" title="B项目中新建一个接口作为通道"></a>B项目中新建一个接口作为通道</h3><blockquote><p>NotifyChannelConstant为自定义常量，此处引用的是A项目中的常量<br>@Input注解代表这是一个输入通道，通道名需要与生产者对应才能接收消息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public interface PdfNotifyChannel &#123;</span><br><span class="line">    @Input(NotifyChannelConstant.PDF_NOTIFY_CHANNEL)</span><br><span class="line">    MessageChannel input();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="绑定接口-EnableBinding-1"><a href="#绑定接口-EnableBinding-1" class="headerlink" title="绑定接口@EnableBinding"></a>绑定接口@EnableBinding</h3><ul><li>进行消息接收的类，需要添加@EnableBinding(PdfNotifyChannel.class)，指定绑定的接口通道</li><li>监听<br>使用@StreamListener进行监听该通道中的信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 监听推送信息</span><br><span class="line">  * @param message</span><br><span class="line">  */</span><br><span class="line"> @StreamListener(NotifyChannelConstant.PDF_NOTIFY_CHANNEL)</span><br><span class="line"> public void receiverPdfNotify(Message&lt;String&gt; message) &#123;</span><br><span class="line">        LOGGER.info(&quot;频道[&#123;&#125;]监听信息为:[&#123;&#125;]&quot;, </span><br><span class="line">        NotifyChannelConstant.PDF_NOTIFY_CHANNEL, message.getPayload());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="配置RabbitMQ"><a href="#配置RabbitMQ" class="headerlink" title="配置RabbitMQ"></a>配置RabbitMQ</h2><blockquote><p>需要AB配置一致<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.host=localhost</span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br><span class="line">#默认5672</span><br><span class="line">spring.rabbitmq.port=5673</span><br><span class="line">#默认/</span><br><span class="line">spring.rabbitmq.virtual-host=/</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="RabbitMQ相关命令"><a href="#RabbitMQ相关命令" class="headerlink" title="RabbitMQ相关命令"></a>RabbitMQ相关命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前所有用户</span><br><span class="line">$ sudo rabbitmqctl list_users</span><br><span class="line"></span><br><span class="line"># 查看默认guest用户的权限</span><br><span class="line">$ sudo rabbitmqctl list_user_permissions guest</span><br><span class="line"></span><br><span class="line"># 由于RabbitMQ默认的账号用户名和密码都是guest。为了安全起见, 先删掉默认用户</span><br><span class="line">$ sudo rabbitmqctl delete_user guest</span><br><span class="line"></span><br><span class="line"># 添加新用户</span><br><span class="line">$ sudo rabbitmqctl add_user username password</span><br><span class="line"></span><br><span class="line"># 设置用户tag</span><br><span class="line">$ sudo rabbitmqctl set_user_tags username administrator</span><br><span class="line"></span><br><span class="line"># 赋予用户默认vhost的全部操作权限</span><br><span class="line">$ sudo rabbitmqctl set_permissions -p / username &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class="line"></span><br><span class="line"># 查看用户的权限</span><br><span class="line">$ sudo rabbitmqctl list_user_permissions username</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Spring Cloud Stream是一个用来为微服务应用构建消息驱动能力的框架。它可以基于Spring Boot 来创建独立的，可用于生产的Spring 应用程序。他通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动。Spring Cloud Stream 为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了发布-订阅、消费组、分区的三个核心概念。目前仅支持RabbitMQ、Kafka。
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://blog.linzhongtai.cn/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.linzhongtai.cn/tags/RabbitMQ/"/>
    
      <category term="Stream" scheme="http://blog.linzhongtai.cn/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>九浅一深之RabbitMQ</title>
    <link href="http://blog.linzhongtai.cn/2018/03/%E4%B9%9D%E6%B5%85%E4%B8%80%E6%B7%B1%E4%B9%8BRabbitMQ/"/>
    <id>http://blog.linzhongtai.cn/2018/03/九浅一深之RabbitMQ/</id>
    <published>2018-03-22T12:41:00.000Z</published>
    <updated>2018-03-22T12:41:00.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>RabbitMQ是一个开源的AMQP实现：AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。 AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。</p></blockquote><hr><blockquote><p>ConnectionFactory、Connection、Channel都是RabbitMQ对外提供的API中最基本的对象。Connection是RabbitMQ的socket链接，它封装了socket协议相关部分逻辑。ConnectionFactory为Connection的制造工厂。 Channel是我们与RabbitMQ打交道的最重要的一个接口，我们大部分的业务操作是在Channel这个接口中完成的，包括定义Queue、定义Exchange、绑定Queue与Exchange、发布消息等。</p></blockquote><p><img src="http://otkzd4sua.bkt.clouddn.com/RabbitMQ.png" alt=""></p><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p>消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</p><h3 id="Publisher"><a href="#Publisher" class="headerlink" title="Publisher"></a>Publisher</h3><p>消息的生产者，也是一个向交换器发布消息的客户端应用程序。</p><h3 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h3><p>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</p><h3 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h3><p>绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</p><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><p>网络连接，比如一个TCP连接。</p><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内地虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</p><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</p><h3 id="Virtual-Host"><a href="#Virtual-Host" class="headerlink" title="Virtual Host"></a>Virtual Host</h3><p>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</p><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>表示消息队列服务器实体。</p><h2 id="AMQP-中的消息路由"><a href="#AMQP-中的消息路由" class="headerlink" title="AMQP 中的消息路由"></a>AMQP 中的消息路由</h2><blockquote><p>AMQP 中消息的路由过程和 Java 开发者熟悉的 JMS 存在一些差别，AMQP 中增加了 Exchange 和 Binding 的角色。生产者把消息发布到 Exchange 上，消息最终到达队列并被消费者接收，而 Binding 决定交换器的消息应该发送到那个队列。</p></blockquote><p><img src="http://otkzd4sua.bkt.clouddn.com/RabbitMQ-1.png" alt=""></p><h2 id="Exchange-类型"><a href="#Exchange-类型" class="headerlink" title="Exchange 类型"></a>Exchange 类型</h2><p>Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键，此外 headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了</p><h3 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h3><p><img src="http://otkzd4sua.bkt.clouddn.com/RabbitMQ-2.png" alt=""><br>消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只转发 routing key 标记为“dog”的消息，不会转发“dog.puppy”，也不会转发“dog.guard”等等。它是完全匹配、单播的模式。</p><h3 id="fanout"><a href="#fanout" class="headerlink" title="fanout"></a>fanout</h3><p><img src="http://otkzd4sua.bkt.clouddn.com/RabbitMQ-3.png" alt=""><br>每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的。</p><h3 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h3><p><img src="http://otkzd4sua.bkt.clouddn.com/RabbitMQ-4.png" alt=""><br><img src="http://otkzd4sua.bkt.clouddn.com/RabbitMQ-5.png" alt=""></p><ul><li>routing key为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit”</li><li>binding key与routing key一样也是句点号“. ”分隔的字符串</li><li>binding key中可以存在两种特殊字符’*’与“#”，用于做模糊匹配，其中“**”用于匹配一个单词，“#”用于匹配多个单词（可以是零个）</li></ul><h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><p>headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。 在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue。</p><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>MQ本身是基于异步的消息处理，前面的示例中所有的生产者（P）将消息发送到RabbitMQ后不会知道消费者（C）处理成功或者失败（甚至连有没有消费者来处理这条消息都不知道）。 但实际的应用场景中，我们很可能需要一些同步处理，需要同步等待服务端将我的消息处理完成后再进行下一步处理。这相当于RPC（Remote Procedure Call，远程过程调用）。在RabbitMQ中也支持RPC。<br><img src="http://otkzd4sua.bkt.clouddn.com/RabbitMQ-6.png" alt=""></p><p>  RabbitMQ  中实现RPC 的机制是：</p><ul><li>客户端发送请求（消息）时，在消息的属性（MessageProperties ，在AMQP 协议中定义了14中properties ，这些属性会随着消息一起发送）中设置两个值replyTo （一个Queue 名称，用于告诉服务器处理完成后将通知我的消息发送到这个Queue 中）和correlationId （此次请求的标识号，服务器处理完成后需要将此属性返还，客户端将根据这个id了解哪条请求被成功执行了或执行失败）</li><li>服务器端收到消息并处理</li><li>服务器端处理完消息后，将生成一条应答消息到replyTo 指定的Queue ，同时带上correlationId 属性</li><li>客户端之前已订阅replyTo 指定的Queue ，从中收到服务器的应答消息后，根据其中的correlationId 属性分析哪条请求被执行了，根据执行结果进行后续业务处理</li></ul><h2 id="RabbitMQ-选型和对比"><a href="#RabbitMQ-选型和对比" class="headerlink" title="RabbitMQ 选型和对比"></a>RabbitMQ 选型和对比</h2><ul><li>从社区活跃度<br>按照目前网络上的资料，RabbitMQ 、activeM 、ZeroMQ 三者中，综合来看，RabbitMQ 是首选。 </li><li>持久化消息比较<br>ZeroMq 不支持，ActiveMq 和RabbitMq 都支持。持久化消息主要是指我们机器在不可抗力因素等情况下挂掉了，消息不会丢失的机制。</li><li>综合技术实现<br>可靠性、灵活的路由、集群、事务、高可用的队列、消息排序、问题追踪、可视化管理工具、插件系统等等。<br>RabbitMq / Kafka 最好，ActiveMq 次之，ZeroMq 最差。当然ZeroMq 也可以做到，不过自己必须手动写代码实现，代码量不小。尤其是可靠性中的：持久性、投递确认、发布者证实和高可用性。</li><li>高并发<br>毋庸置疑，RabbitMQ 最高，原因是它的实现语言是天生具备高并发高可用的erlang 语言。</li><li>比较关注的比较， RabbitMQ 和 Kafka<br>RabbitMq 比Kafka 成熟，在可用性上，稳定性上，可靠性上，  RabbitMq  胜于  Kafka  （理论上）。</li></ul><p>另外，Kafka 的定位主要在日志等方面， 因为Kafka 设计的初衷就是处理日志的，可以看做是一个日志（消息）系统一个重要组件，针对性很强，所以 如果业务方面还是建议选择 RabbitMq 。<br>还有就是，Kafka 的性能（吞吐量、TPS ）比RabbitMq 要高出来很多。</p><p>原文：<a href="https://www.jianshu.com/p/79ca08116d57" target="_blank" rel="noopener">消息队列之 RabbitMQ</a>  、 <a href="https://www.sojson.com/blog/48.html" target="_blank" rel="noopener">我为什么要选择RabbitMQ</a></p>]]></content>
    
    <summary type="html">
    
      RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://blog.linzhongtai.cn/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.linzhongtai.cn/tags/RabbitMQ/"/>
    
  </entry>
  
</feed>
