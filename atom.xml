<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林林总总</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.linzhongtai.cn/"/>
  <updated>2019-04-29T09:13:17.000Z</updated>
  <id>http://blog.linzhongtai.cn/</id>
  
  <author>
    <name>Soul</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis缓存淘汰策略</title>
    <link href="http://blog.linzhongtai.cn/2019/04/Redis%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/"/>
    <id>http://blog.linzhongtai.cn/2019/04/Redis缓存淘汰策略/</id>
    <published>2019-04-29T09:13:17.000Z</published>
    <updated>2019-04-29T09:13:17.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="常用的淘汰算法"><a href="#常用的淘汰算法" class="headerlink" title="常用的淘汰算法"></a>常用的淘汰算法</h2><ul><li>FIFO：First In First Out，先进先出。判断被存储的时间，离目前最远的数据优先被淘汰。</li><li>LRU：Least Recently Used，最近最少使用。判断最近被使用的时间，目前最远的数据优先被淘汰。</li><li>LFU：Least Frequently Used，最不经常使用。在一段时间内，数据被使用次数最少的，优先被淘汰。</li></ul><h2 id="Redis提供的淘汰策略："><a href="#Redis提供的淘汰策略：" class="headerlink" title="Redis提供的淘汰策略："></a>Redis提供的淘汰策略：</h2><ul><li>noeviction：达到内存限额后返回错误，客户尝试可以导致更多内存使用的命令（大部分写命令，但DEL和一些例外）</li><li>allkeys-lru：为了给新增加的数据腾出空间，驱逐键先试图移除一部分最近使用较少的（LRC）。</li><li>volatile-lru：为了给新增加的数据腾出空间，驱逐键先试图移除一部分最近使用较少的（LRC），但只限于过期设置键。</li><li>allkeys-random: 为了给新增加的数据腾出空间，驱逐任意键</li><li>volatile-random: 为了给新增加的数据腾出空间，驱逐任意键，但只限于有过期设置的驱逐键。</li><li>volatile-ttl: 为了给新增加的数据腾出空间，驱逐键只有秘钥过期设置，并且首先尝试缩短存活时间的驱逐键</li></ul>]]></content>
    
    <summary type="html">
    
      LRU
    
    </summary>
    
      <category term="redis" scheme="http://blog.linzhongtai.cn/categories/redis/"/>
    
    
      <category term="redis" scheme="http://blog.linzhongtai.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis中keys与scan特点</title>
    <link href="http://blog.linzhongtai.cn/2019/04/Redis%E4%B8%ADkeys%E4%B8%8Escan%E7%89%B9%E7%82%B9/"/>
    <id>http://blog.linzhongtai.cn/2019/04/Redis中keys与scan特点/</id>
    <published>2019-04-29T09:06:41.000Z</published>
    <updated>2019-04-29T09:06:41.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="keys缺点"><a href="#keys缺点" class="headerlink" title="keys缺点"></a>keys缺点</h2><ol><li>没有offset、limit参数，不能限制查询个数</li><li>keys是遍历算法，复杂度O(n)，数据量大的时候会导致redis卡顿</li></ol><h2 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h2><ol><li>复杂度O(n)，但是scan是通过游标分步进行，不阻塞</li><li>提供limit，可控制返回结果数</li><li>同keys一样，提供模式匹配</li><li>服务器不需要为游标保存状态，唯一状态是scan返回客户端的游标整数</li><li><strong>返回结果可能重复，需要客户端去重</strong></li><li>如果遍历过程中有数据修改，改动后的数据不保证同步</li><li>单次返回结果是空的，不表示遍历结束，而要看返回的游标值是否为0</li></ol>]]></content>
    
    <summary type="html">
    
      keys VS scan
    
    </summary>
    
      <category term="redis" scheme="http://blog.linzhongtai.cn/categories/redis/"/>
    
    
      <category term="redis" scheme="http://blog.linzhongtai.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之多线程并发：阻塞队列</title>
    <link href="http://blog.linzhongtai.cn/2019/04/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%9A%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>http://blog.linzhongtai.cn/2019/04/重温系列之多线程并发：阻塞队列/</id>
    <published>2019-04-01T11:48:51.000Z</published>
    <updated>2019-04-01T11:48:51.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>在阻塞队列中，线程阻塞有这样的两种情况：</p><ol><li>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放<br>入队列。</li><li>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有<br>空的位置，线程被自动唤醒。</li></ol><h2 id="阻塞队列的主要方法"><a href="#阻塞队列的主要方法" class="headerlink" title="阻塞队列的主要方法"></a>阻塞队列的主要方法</h2><table><thead><tr><th>方法类型</th><th>抛出异常</th><th>特殊值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>插入</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td>移除</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time,unit)</td></tr><tr><td>检查</td><td>element()</td><td>peek()</td><td>不可用</td><td>不可用</td></tr></tbody></table><ul><li>抛出异常：抛出一个异常</li><li>特殊值：返回一个特殊值（null 或 false,视情况而定）</li><li>阻塞：在成功操作之前，一直阻塞线程</li><li>超时：放弃前只在最大的时间内阻塞</li></ul><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><ol><li>public abstract boolean add(E paramE)：将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则抛出IllegalStateException。如果该元素是 NULL，则会抛出 NullPointerException 异常。</li><li>public abstract boolean offer(E paramE)：将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则返回false。</li><li><p>public abstract void put(E paramE) throws InterruptedException： 将指定元素插入此队列中，将等待可用的空间（如果有必要）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void put(E paramE) throws InterruptedException &#123;</span><br><span class="line">  checkNotNull(paramE);</span><br><span class="line">  ReentrantLock localReentrantLock = this.lock;</span><br><span class="line">  localReentrantLock.lockInterruptibly();</span><br><span class="line">  try &#123;</span><br><span class="line">    while (this.count == this.items.length)</span><br><span class="line">    this.notFull.await();//如果队列满了，则线程阻塞等待</span><br><span class="line">    enqueue(paramE);</span><br><span class="line">    localReentrantLock.unlock();</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    localReentrantLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入 BlockingQueue，则返回失败。</p></li></ol><h3 id="获取数据操作-："><a href="#获取数据操作-：" class="headerlink" title="获取数据操作 ："></a>获取数据操作 ：</h3><ol><li>poll(time):取走 BlockingQueue 里排在首位的对象,若不能立即取出,则可以等 time 参数规定的时间,取不到时返回 null;</li><li>poll(long timeout, TimeUnit unit)：从 BlockingQueue 取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则直到时间超时还没有数据可取，返回失败。</li><li>take():取走 BlockingQueue 里排在首位的对象,若 BlockingQueue 为空,阻断进入等待状态直到 BlockingQueue 有新的数据被加入。</li><li>drainTo():一次性从 BlockingQueue 获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。</li></ol><h2 id="Java-中的阻塞队列"><a href="#Java-中的阻塞队列" class="headerlink" title="Java 中的阻塞队列"></a>Java 中的阻塞队列</h2><p><img src="https://blog2019.oss-cn-shenzhen.aliyuncs.com/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.jpg" alt=""></p><h3 id="ArrayBlockingQueue-：由数组结构组成的有界阻塞队列"><a href="#ArrayBlockingQueue-：由数组结构组成的有界阻塞队列" class="headerlink" title="ArrayBlockingQueue ：由数组结构组成的有界阻塞队列"></a>ArrayBlockingQueue ：由数组结构组成的有界阻塞队列</h3><blockquote><p>公平、非公平</p></blockquote><p>用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000,true);</span><br></pre></td></tr></table></figure></p><h3 id="LinkedBlockingQueue-：由链表结构组成的有界阻塞队列。"><a href="#LinkedBlockingQueue-：由链表结构组成的有界阻塞队列。" class="headerlink" title="LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。"></a>LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。</h3><blockquote><p>两个独立锁提高并发</p></blockquote><p>基于链表的阻塞队列，同ArrayListBlockingQueue类似，此队列按照先进先出（FIFO）的原则对元素进行排序。而 LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。<br>LinkedBlockingQueue 会默认一个类似无限大小的容量（Integer.MAX_VALUE）。</p><h3 id="PriorityBlockingQueue-：支持优先级排序的无界阻塞队列。"><a href="#PriorityBlockingQueue-：支持优先级排序的无界阻塞队列。" class="headerlink" title="PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。"></a>PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。</h3><blockquote><p>compareTo 排序实现优先</p></blockquote><p>是一个支持优先级的无界队列。默认情况下元素采取自然顺序升序排列。可以自定义实现compareTo()方法来指定元素进行排序规则，或者初始化 PriorityBlockingQueue 时，指定构造参数 Comparator 来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p><h3 id="DelayQueue：使用优先级队列实现的无界阻塞队列。"><a href="#DelayQueue：使用优先级队列实现的无界阻塞队列。" class="headerlink" title="DelayQueue：使用优先级队列实现的无界阻塞队列。"></a>DelayQueue：使用优先级队列实现的无界阻塞队列。</h3><blockquote><p>缓存失效、定时任务</p></blockquote><p>是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现 Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。我们可以将 DelayQueue 运用在以下应用场景：</p><ol><li>缓存系统的设计：可以用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从 DelayQueue 中获取元素时，表示缓存有效期到了。</li><li>定时任务调度：使用 DelayQueue 保存当天将会执行的任务和执行时间，一旦从DelayQueue 中获取到任务就开始执行，从比如 TimerQueue 就是使用 DelayQueue实现的。</li></ol><h3 id="SynchronousQueue：不存储元素的阻塞队列。"><a href="#SynchronousQueue：不存储元素的阻塞队列。" class="headerlink" title="SynchronousQueue：不存储元素的阻塞队列。"></a>SynchronousQueue：不存储元素的阻塞队列。</h3><blockquote><p>不存储数据、可用于传递数据</p></blockquote><p><strong>是一个不存储元素的阻塞队列。每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素</strong>。SynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合于传递性场景,比如在一个线程中使用的数据，传递给另外一个线程使用，SynchronousQueue的吞吐量高于LinkedBlockingQueue 和ArrayBlockingQueue。</p><h3 id="LinkedTransferQueue：由链表结构组成的无界阻塞队列。"><a href="#LinkedTransferQueue：由链表结构组成的无界阻塞队列。" class="headerlink" title="LinkedTransferQueue：由链表结构组成的无界阻塞队列。"></a>LinkedTransferQueue：由链表结构组成的无界阻塞队列。</h3><p>是 一 个 由 链 表 结 构 组 成 的 无 界 阻 塞 TransferQueue 队 列 。 相 对 于 其 他 阻 塞 队 列 ，LinkedTransferQueue 多了 tryTransfer 和 transfer 方法。</p><ol><li>transfer 方法：如果当前有消费者正在等待接收元素（消费者使用 take()方法或带时间限制的poll()方法时），transfer 方法可以把生产者传入的元素立刻 transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer 方法会将元素存放在队列的 tail 节点，并等到该元素被消费者消费了才返回。</li><li>tryTransfer 方法。则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回 false。和 transfer 方法的区别是 tryTransfer 方法无论消费者是否接收，方法立即返回。而 transfer 方法是必须等到消费者消费了才返回。</li></ol><p>对于带有时间限制的 tryTransfer(E e, long timeout, TimeUnit unit)方法，则是试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回 false，如果在超时时间内消费了元素，则返回 true。</p><h3 id="LinkedBlockingDeque：由链表结构组成的双向阻塞队列"><a href="#LinkedBlockingDeque：由链表结构组成的双向阻塞队列" class="headerlink" title="LinkedBlockingDeque：由链表结构组成的双向阻塞队列"></a>LinkedBlockingDeque：由链表结构组成的双向阻塞队列</h3><p><strong>是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素。</strong><br>双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque 多了 addFirst，addLast，offerFirst，offerLast，peekFirst，peekLast 等方法，以 First 单词结尾的方法，表示插入，获取（peek）或移除双端队列的第一个元素。以 Last 单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素。另外插入方法 add 等同于 addLast，移除方法 remove 等效于 removeFirst。但是 take 方法却等同于 takeFirst，不知道是不是 Jdk 的 bug，使用时还是用带有 First 和 Last 后缀的方法更清楚。<br>在初始化 LinkedBlockingDeque 时可以设置容量防止其过渡膨胀。另外双向阻塞队列可以运用在“工作窃取”模式中。</p>]]></content>
    
    <summary type="html">
    
      阻塞、超时、抛出异常...
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之多线程并发：线程池原理</title>
    <link href="http://blog.linzhongtai.cn/2019/04/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/"/>
    <id>http://blog.linzhongtai.cn/2019/04/重温系列之多线程并发：线程池原理/</id>
    <published>2019-04-01T11:45:59.000Z</published>
    <updated>2019-04-01T11:45:59.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量则<strong>超出数量的线程排队等候</strong>，等其它线程执行完毕，再从队列中取出任务来执行。他的主要特点为：<strong>线程复用、控制最大并发数、管理线程</strong>。</p></blockquote><h2 id="线程复用"><a href="#线程复用" class="headerlink" title="线程复用"></a>线程复用</h2><p>每一个 Thread 的类都有一个 start 方法。 当调用 start 启动线程时 Java 虚拟机会调用该类的 run方法。 那么该类的 run() 方法中就是调用了 Runnable 对象的 run() 方法。 <strong>我们可以继承重写Thread 类，在其 start 方法中添加不断循环调用传递过来的 Runnable 对象</strong>。 这就是线程池的实现原理。<strong>循环方法中不断获取 Runnable 是用 Queue 实现的</strong>，在获取下一个 Runnable 之前可以是阻塞的。</p><h2 id="线程池的组成"><a href="#线程池的组成" class="headerlink" title="线程池的组成"></a>线程池的组成</h2><ol><li>线程池管理器：用于创建并管理线程池</li><li>工作线程：线程池中的线程</li><li>任务接口：每个任务必须实现的接口，用于工作线程调度其运行</li><li>任务队列：用于存放待处理的任务，提供一种缓冲机制</li></ol><p>Java 中的线程池是通过 Executor 框架实现的，该框架中用到了 Executor，Executors，ExecutorService，ThreadPoolExecutor ，Callable 和 Future、FutureTask 这几个类。<br><img src="https://blog2019.oss-cn-shenzhen.aliyuncs.com/1554104383%281%29.jpg" alt=""><br>ThreadPoolExecutor 的构造方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize, long keepAliveTime,</span><br><span class="line">                    TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123;</span><br><span class="line">          this(corePoolSize, maximumPoolSize, keepAliveTime, unit, </span><br><span class="line">                workQueue,Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>corePoolSize：指定了线程池中的线程数量。</li><li>maximumPoolSize：指定了线程池中的最大线程数量。</li><li>keepAliveTime：当前线程池数量超过 corePoolSize 时，多余的空闲线程的存活时间，即多次时间内会被销毁。</li><li>unit：keepAliveTime 的单位。</li><li>workQueue：任务队列，被提交但尚未被执行的任务。</li><li>threadFactory：线程工厂，用于创建线程，一般用默认的即可。</li><li>handler：拒绝策略，当任务太多来不及处理，如何拒绝任务。</li></ol><h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><p>线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。JDK 内置的拒绝策略如下：</p><ol><li>AbortPolicy ： 直接抛出异常，阻止系统正常运行。</li><li>CallerRunsPolicy ： 只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。</li><li>DiscardOldestPolicy ： 丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。</li><li>DiscardPolicy ： 该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方案。</li></ol><p>以上内置拒绝策略均实现了 RejectedExecutionHandler 接口，若以上策略仍无法满足实际需要，完全可以自己扩展 RejectedExecutionHandler 接口。</p><h2 id="Java线程池工作过程"><a href="#Java线程池工作过程" class="headerlink" title="Java线程池工作过程"></a>Java线程池工作过程</h2><ol><li>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</li><li>当调用 execute() 方法添加一个任务时，线程池会做如下判断：<br>a)  如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；<br>b) 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；<br>c)  如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；<br>d) 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常 RejectExecutionException。</li><li>当一个线程完成任务时，它会从队列中取下一个任务来执行。</li><li>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。<br><img src="https://blog2019.oss-cn-shenzhen.aliyuncs.com/java%E7%BA%BF%E7%A8%8B%E6%B1%A0.jpg" alt=""></li></ol>]]></content>
    
    <summary type="html">
    
      线程复用、控制最大并发数、管理线程
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之多线程并发：锁的优化</title>
    <link href="http://blog.linzhongtai.cn/2019/04/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%9A%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>http://blog.linzhongtai.cn/2019/04/重温系列之多线程并发：锁的优化/</id>
    <published>2019-04-01T11:44:49.000Z</published>
    <updated>2019-04-01T11:44:49.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="减少锁持有时间"><a href="#减少锁持有时间" class="headerlink" title="减少锁持有时间"></a>减少锁持有时间</h2><blockquote><p>只用在需要线程安全的方法上加锁</p></blockquote><h2 id="减小锁粒度"><a href="#减小锁粒度" class="headerlink" title="减小锁粒度"></a>减小锁粒度</h2><p>将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是ConcurrentHashMap。</p><h2 id="锁分离"><a href="#锁分离" class="headerlink" title="锁分离"></a>锁分离</h2><p>最常见的锁分离就是读写锁 ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如下面的LinkedBlockingQueue 从头部取出，从尾部放数据<br><img src="https://blog2019.oss-cn-shenzhen.aliyuncs.com/%E9%94%81%E5%88%86%E7%A6%BB.png" alt=""></p><h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。但是，凡事都有一个度，<strong>如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void demoMethod()&#123;  </span><br><span class="line">synchronized(lock)&#123;   </span><br><span class="line">//do sth.  </span><br><span class="line">&#125;  </span><br><span class="line">//做其他不需要的同步的工作，但能很快执行完毕  </span><br><span class="line">synchronized(lock)&#123;   </span><br><span class="line">//do sth.  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况，根据锁粗化的思想，应该合并<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void demoMethod()&#123;  </span><br><span class="line">//整合成一次锁请求 </span><br><span class="line">synchronized(lock)&#123;   </span><br><span class="line">//do sth.   </span><br><span class="line">//做其他不需要的同步的工作，但能很快执行完毕  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然这是有前提的，前提就是中间的那些不需要同步的工作是很快执行完成的。</p><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><blockquote><p>在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作。</p></blockquote><p>也许你会觉得奇怪，既然有些对象不可能被多线程访问，那为什么要加锁呢？写代码时直接不加锁不就好了。<br>但是有时，这些锁并不是程序员所写的，有的是JDK实现中就有锁的，比如Vector和StringBuffer这样的类，它们中的很多方法都是有锁的。当我们在一些不会有线程安全的情况下使用这些类的方法时，达到某些条件时，编译器会将锁消除来提高性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000000</span>; i++) &#123;</span><br><span class="line">createStringBuffer(<span class="string">"JVM"</span>, <span class="string">"Diagnosis"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> bufferCost = System.currentTimeMillis() - start;</span><br><span class="line">System.out.println(<span class="string">"craeteStringBuffer: "</span> + bufferCost + <span class="string">" ms"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">sb.append(s1);</span><br><span class="line">sb.append(s2);</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuffer.append是一个同步操作，但是StringBuffer却是一个局部变量，并且方法也并没有把StringBuffer返回，所以不可能会有多线程去访问它，那么此时StringBuffer中的同步操作就是没有意义的。</p><p>开启锁消除是在JVM参数上设置的，当然需要在server模式下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks</span><br></pre></td></tr></table></figure></p><p>并且要开启<strong><a href="http://www.importnew.com/23150.html" target="_blank" rel="noopener">逃逸分析</a></strong>。<br> 逃逸分析的作用呢，就是看看变量是否有可能逃出作用域的范围：<br>比如上述的StringBuffer，上述代码中craeteStringBuffer的返回是一个String，所以这个局部变量StringBuffer在其他地方都不会被使用。如果将craeteStringBuffer改成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static StringBuffer craeteStringBuffer(String s1, String s2) &#123;</span><br><span class="line">StringBuffer sb = new StringBuffer();</span><br><span class="line">sb.append(s1);</span><br><span class="line">sb.append(s2);</span><br><span class="line">return sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么这个 StringBuffer被返回后，是有可能被任何其他地方所使用的（譬如被主函数将返回结果put进map啊等等）。那么JVM的逃逸分析可以分析出，这个局部变量 StringBuffer逃出了它的作用域。<br>所以基于逃逸分析，JVM可以判断，如果这个局部变量StringBuffer并没有逃出它的作用域，那么可以确定这个StringBuffer并不会被多线程所访问，那么就可以把这些多余的锁给去掉来提高性能</p>]]></content>
    
    <summary type="html">
    
      优化路漫漫
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
      <category term="锁" scheme="http://blog.linzhongtai.cn/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之多线程并发：锁分类</title>
    <link href="http://blog.linzhongtai.cn/2019/04/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%9A%E9%94%81%E5%88%86%E7%B1%BB/"/>
    <id>http://blog.linzhongtai.cn/2019/04/重温系列之多线程并发：锁分类/</id>
    <published>2019-04-01T11:42:35.000Z</published>
    <updated>2019-04-01T11:42:35.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><blockquote><p>可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。在 JAVA 环境下 ReentrantLock 和 synchronized 都是 可重入锁。</p></blockquote><h2 id="ReadWriteLock-读写锁"><a href="#ReadWriteLock-读写锁" class="headerlink" title="ReadWriteLock  读写锁"></a>ReadWriteLock  读写锁</h2><p><strong>为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制</strong>，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。</p><h3 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h3><p>如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁</p><h3 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h3><p>如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁。<br>Java中读写锁有个接口：java.util.concurrent.locks.ReadWriteLock，也有具体的实现ReentrantReadWriteLock。</p><h2 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h2><blockquote><p>java 并发包提供的加锁模式分为独占锁和共享锁</p></blockquote><h3 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h3><p>独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。</p><h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><p>共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。</p><ol><li>AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等待线程的锁获取模式。</li><li>java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，或者被一个 写操作访问，但两者不能同时进行。</li></ol><h2 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h2><h3 id="公平锁（-Fair-）"><a href="#公平锁（-Fair-）" class="headerlink" title="公平锁（ Fair ）"></a>公平锁（ Fair ）</h3><blockquote><p>加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得</p></blockquote><h3 id="非公平锁（-Nonfair-）"><a href="#非公平锁（-Nonfair-）" class="headerlink" title="非公平锁（ Nonfair ）"></a>非公平锁（ Nonfair ）</h3><blockquote><p>加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待</p></blockquote><ol><li>非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个队列</li><li>Java 中的 synchronized 是非公平锁，ReentrantLock 默认的 lock()方法采用的是非公平锁。</li></ol><h2 id="偏向锁-轻量级锁-重量级锁"><a href="#偏向锁-轻量级锁-重量级锁" class="headerlink" title="偏向锁/轻量级锁/重量级锁"></a>偏向锁/轻量级锁/重量级锁</h2><blockquote><p>锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀。<br>【但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级】</p></blockquote><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>使用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td>适用于只有一个线程访问同步块场景。</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度。</td><td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td><td>追求响应时间。同步块执行速度非常快。</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU。</td><td>线程阻塞，响应时间缓慢。</td><td>追求吞吐量。同步块执行速度较长。</td></tr></tbody></table><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。<strong>偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。</strong>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，<strong>而偏向锁只需要在置换ThreadID 的时候依赖一次 CAS 原子指令</strong>（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。上面说过，<strong>轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</strong></p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，<strong>轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。</strong></p><h3 id="重量级锁-Mutex-Lock"><a href="#重量级锁-Mutex-Lock" class="headerlink" title="重量级锁(Mutex Lock)"></a>重量级锁(Mutex Lock)</h3><p>Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为“重量级锁”。JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。</p><h2 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h2><blockquote><p>分段锁并非一种实际的锁，而是一种思想<br>ConcurrentHashMap的segment是学习分段锁的最好实践</p></blockquote><p>HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术。<strong>首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问</strong></p>]]></content>
    
    <summary type="html">
    
      可重入锁/读写锁/共享锁独占锁/公平锁非公平锁/ 偏向锁/轻量级锁/重量级锁...
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
      <category term="锁" scheme="http://blog.linzhongtai.cn/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之多线程并发：AtomicInteger</title>
    <link href="http://blog.linzhongtai.cn/2019/04/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%9AAtomicInteger/"/>
    <id>http://blog.linzhongtai.cn/2019/04/重温系列之多线程并发：AtomicInteger/</id>
    <published>2019-04-01T09:42:33.000Z</published>
    <updated>2019-04-01T09:42:33.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>此处 AtomicInteger，一个提供原子操作的 Integer 的类，常见的还有AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference 等，他们的实现原理相同，区别在与运算对象类型的不同。令人兴奋地，还可以通过 AtomicReference<v>将一个对象的所有操作转化成原子操作。</v></p></blockquote><p><strong>在多线程程序中，诸如++i 或 i++等运算不具有原子性，是不安全的线程操作之一。</strong>通常我们会使用 synchronized 将该操作变成一个原子操作，但JVM为此类操作特意提供了一些同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常AtomicInteger的性能是 ReentrantLock 的好几倍。</p>]]></content>
    
    <summary type="html">
    
      AtomicInteger，一个提供原子操作的 Integer 的类
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之多线程并发：Semaphore信号量</title>
    <link href="http://blog.linzhongtai.cn/2019/04/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%9ASemaphore%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    <id>http://blog.linzhongtai.cn/2019/04/重温系列之多线程并发：Semaphore信号量/</id>
    <published>2019-04-01T09:41:54.000Z</published>
    <updated>2019-04-01T09:41:54.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore 可以用来构建一些对象池，资源池之类的，比如数据库连接池。</p></blockquote><h2 id="实现互斥锁（计数器为-1-）"><a href="#实现互斥锁（计数器为-1-）" class="headerlink" title="实现互斥锁（计数器为 1 ）"></a>实现互斥锁（计数器为 1 ）</h2><blockquote><p>我们也可以创建计数为 1 的 Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个计数阈值为 5 的信号量对象</span><br><span class="line">// 只能 5 个线程同时访问</span><br><span class="line">Semaphore semp = new Semaphore(5);</span><br><span class="line">try &#123;  // 申请许可</span><br><span class="line">  semp.acquire();</span><br><span class="line">  try &#123;</span><br><span class="line">    // 业务逻辑</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    // 释放许可</span><br><span class="line">    semp.release();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Semaphore-与-ReentrantLock"><a href="#Semaphore-与-ReentrantLock" class="headerlink" title="Semaphore  与 ReentrantLock"></a>Semaphore  与 ReentrantLock</h2><p>Semaphore 基本能完成 ReentrantLock 的所有工作，使用方法也与之类似，通过 acquire()与release()方法来获得和释放临界资源。经实测，Semaphone.acquire()方法默认为可响应中断锁，与 ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被Thread.interrupt()方法中断。</p><p>此外，Semaphore 也实现了可轮询的锁请求与定时锁的功能，除了方法名 tryAcquire 与 tryLock不同，其使用方法与 ReentrantLock几乎一致。Semaphore也提供了公平与非公平锁的机制，也可在构造函数中进行设定。</p><p>Semaphore的锁释放操作也由手动进行，因此与 ReentrantLock 一样，为避免线程因抛出异常而无法正常释放锁的情况发生，释放锁的操作也必须在 finally 代码块中完成。</p>]]></content>
    
    <summary type="html">
    
      Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore 可以用来构建一些对象池，资源池之类的，比如数据库连接池。
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
      <category term="锁" scheme="http://blog.linzhongtai.cn/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之多线程并发：ReentrantLock</title>
    <link href="http://blog.linzhongtai.cn/2019/04/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%9AReentrantLock/"/>
    <id>http://blog.linzhongtai.cn/2019/04/重温系列之多线程并发：ReentrantLock/</id>
    <published>2019-04-01T09:41:12.000Z</published>
    <updated>2019-04-01T09:41:12.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>ReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。</p></blockquote><h2 id="Lock接口的主要方法"><a href="#Lock接口的主要方法" class="headerlink" title="Lock接口的主要方法"></a>Lock接口的主要方法</h2><ol><li>void lock(): 执行此方法时, <strong>如果锁处于空闲状态, 当前线程将获取到锁</strong>。相反, 如果锁已经被其他线程持有, 将禁用当前线程, 直到当前线程获取到锁。<strong>获得锁就返回 true，不能的话一直等待获得锁。</strong></li><li>boolean tryLock()：<strong>如果锁可用, 则获取锁, 并立即返回 true, 否则返回 false。</strong>该方法和lock()的区别在于, tryLock()只是”试图”获取锁, 如果锁不可用, 不会导致当前线程被禁用,当前线程仍然继续往下执行代码. 而 lock()方法则是一定要获取到锁, 如果锁不可用, 就一直等待, 在未获得锁之前,当前线程并不继续向下执行.</li><li>void unlock()：执行此方法时, 当前线程将释放持有的锁. 锁只能由持有者释放, 如果线程并不持有锁, 却执行该方法, 可能导致异常的发生.</li><li>Condition newCondition()：条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的 await()方法，而调用后，当前线程将缩放锁。</li><li>getHoldCount() ：查询当前线程保持此锁的次数，也就是执行此线程执行lock方法的次数。</li><li>getQueueLength（）：返回正等待获取此锁的线程估计数，比如启动 10 个线程，1 个线程获得锁，此时返回的是 9</li><li>getWaitQueueLength：（Condition condition）返回等待与此锁相关的给定条件的线程估计数。比如 10 个线程，用同一个 condition 对象，并且此时这 10 个线程都执行了condition 对象的 await 方法，那么此时执行此方法返回 10</li><li>hasWaiters(Condition condition)：查询是否有线程等待与此锁有关的给定条件<br>(condition)，对于指定 contidion 对象，有多少线程执行了 condition.await 方法</li><li>hasQueuedThread(Thread thread)：查询给定线程是否等待获取此锁</li><li>hasQueuedThreads()：是否有线程等待此锁</li><li>isFair()：该锁是否公平锁</li><li>isHeldByCurrentThread()： 当前线程是否保持锁锁定，线程的执行 lock 方法的前后分别是 false 和 true</li><li>isLock()：此锁是否有任意线程占用</li><li>lockInterruptibly（）：如果当前线程未被中断，获取锁</li><li>tryLock（）：尝试获得锁，仅在调用时锁未被线程占用，获得锁</li><li>tryLock(long timeout TimeUnit unit)：如果锁在给定等待时间内没有被另一个线程保持，则获取该锁。</li></ol><h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><p>JVM 按随机、就近原则分配锁的机制则称为不公平锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式，默认为非公平锁。非公平锁实际执行的效率要远远超出公平锁，除非程序有特殊需要，否则最常用非公平锁的分配机制。</p><h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><p>公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式来定义公平锁</p><h2 id="ReentrantLock与Synchronized"><a href="#ReentrantLock与Synchronized" class="headerlink" title="ReentrantLock与Synchronized"></a>ReentrantLock与Synchronized</h2><ol><li>ReentrantLock 通过方法 lock()与 unlock()来进行加锁与解锁操作，与<strong>synchronized 会被 JVM 自动解锁机制不同，ReentrantLock 加锁后需要手动进行解锁</strong>。为了避免程序出现异常而无法正常解锁的情况，使用 ReentrantLock 必须在 finally 控制块中进行解锁操作。</li><li>ReentrantLock 相比 synchronized 的优势是可中断、公平锁、多个锁。这种情况下需要使用 ReentrantLock。</li></ol><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ol><li>都是用来协调多线程对共享对象、变量的访问</li><li>都是可重入锁，同一线程可以多次获得同一个锁</li><li>都保证了可见性和互斥性</li></ol><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ol><li>ReentrantLock 显示的获得、释放锁，synchronized 隐式获得释放锁</li><li>ReentrantLock 可响应中断、可轮回，synchronized 是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性</li><li>ReentrantLock 是 API 级别的，synchronized 是 JVM 级别的</li><li>ReentrantLock 可以实现公平锁</li><li>ReentrantLock 通过 Condition 可以绑定多个条件</li><li>底层实现不一样， synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻塞，采用的是乐观并发策略</li><li>Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现。</li><li>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁。</li><li>Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断。</li><li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li><li>Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等。</li></ol><h2 id="ReentrantLock实现"><a href="#ReentrantLock实现" class="headerlink" title="ReentrantLock实现"></a>ReentrantLock实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MyService &#123;</span><br><span class="line">  private Lock lock = new ReentrantLock();</span><br><span class="line">  //Lock lock=new ReentrantLock(true);//公平锁</span><br><span class="line">  //Lock lock=new ReentrantLock(false);//非公平锁</span><br><span class="line">  private Condition condition=lock.newCondition();//创建 Condition</span><br><span class="line">  public void testMethod() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      lock.lock();//lock 加锁</span><br><span class="line">      //1：wait 方法等待：</span><br><span class="line">      //System.out.println(&quot;开始 wait&quot;);</span><br><span class="line">      condition.await();</span><br><span class="line">      //通过创建 Condition 对象来使线程 wait，必须先执行 lock.lock 方法获得锁</span><br><span class="line">      //:2：signal 方法唤醒</span><br><span class="line">      condition.signal();//condition 对象的 signal 方法可以唤醒 wait 线程</span><br><span class="line">      for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        System.out.println(&quot;ThreadName=&quot; + Thread.currentThread().getName()+ (&quot; &quot; + (i + 1)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;finally&#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Condition-类和-Object-类锁方法区别区别"><a href="#Condition-类和-Object-类锁方法区别区别" class="headerlink" title="Condition 类和 Object 类锁方法区别区别"></a>Condition 类和 Object 类锁方法区别区别</h2><ol><li>Condition 类的 awiat 方法和 Object 类的 wait 方法等效</li><li>Condition 类的 signal 方法和 Object 类的 notify 方法等效</li><li>Condition 类的 signalAll 方法和 Object 类的 notifyAll 方法等效</li><li><strong>ReentrantLock 类可以唤醒指定条件的线程，而 object 的唤醒是随机的</strong></li></ol><h2 id="tryLock-和-lock-和-lockInterruptibly-的区别"><a href="#tryLock-和-lock-和-lockInterruptibly-的区别" class="headerlink" title="tryLock 和 lock 和 lockInterruptibly 的区别"></a>tryLock 和 lock 和 lockInterruptibly 的区别</h2><ol><li>tryLock 能获得锁就返回 true，不能就立即返回 false，tryLock(long timeout,TimeUnit unit)，可以增加时间限制，如果超过该时间段还没获得锁，返回 false</li><li>lock 能获得锁就返回 true，不能的话一直等待获得锁</li><li>lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程，lock 不会抛出异常，而 lockInterruptibly 会抛出异常</li></ol>]]></content>
    
    <summary type="html">
    
      ReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
      <category term="锁" scheme="http://blog.linzhongtai.cn/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之多线程并发：Synchronized同步锁</title>
    <link href="http://blog.linzhongtai.cn/2019/04/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%9ASynchronized%E5%90%8C%E6%AD%A5%E9%94%81/"/>
    <id>http://blog.linzhongtai.cn/2019/04/重温系列之多线程并发：Synchronized同步锁/</id>
    <published>2019-04-01T09:39:47.000Z</published>
    <updated>2019-04-01T09:39:47.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>synchronized 它可以把任意一个非NULL的对象当作锁，属于独占式的悲观锁，同时属于可重入锁。</p></blockquote><h2 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h2><ol><li>作用于方法时，锁住的是对象的实例(this)；</li><li>当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久代PermGen(jdk1.8则是 metaspace)，永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程；</li><li>synchronized 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。</li></ol><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><ol><li>Wait Set：那些调用 wait 方法被阻塞的线程被放置在这里；</li><li>Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；</li><li>Entry List：Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中；</li><li>OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为 OnDeck；</li><li>Owner：当前已经获取到所资源的线程被称为 Owner；</li><li>!Owner：当前释放锁的线程。</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><img src="https://blog2019.oss-cn-shenzhen.aliyuncs.com/synchronized.jpg" alt=""></p><ol><li>JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList 会被大量的并发线程进行 CAS 访问，为了降低对尾部元素的竞争，JVM 会将<br>一部分线程移动到 EntryList 中作为候选竞争线程。</li><li>Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并指定EntryList 中的某个线程为 OnDeck 线程（一般是最先进去的那个线程）。</li><li>Owner 线程并不直接把锁传递给 OnDeck 线程，而是把锁竞争的权利交给 OnDeck，OnDeck需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在JVM 中，也把这种选择行为称之为“竞争切换”。</li><li>OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 EntryList中。如果Owner线程被wait方法阻塞，则转移到WaitSet队列中，直到某个时刻通过notify或者 notifyAll 唤醒，会重新进去 EntryList 中。</li><li>处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux 内核下采用 pthread_mutex_lock 内核函数实现的）。</li><li>Synchronized 是非公平锁。 Synchronized 在线程进入 ContentionList 时，等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁<br>资源。<br>参考：<a href="https://blog.csdn.net/zqz_zqz/article/details/70233767" target="_blank" rel="noopener">https://blog.csdn.net/zqz_zqz/article/details/70233767</a></li><li>每个对象都有个 monitor 对象，加锁就是在竞争 monitor 对象，代码块加锁是在前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的</li><li>synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。</li><li>Java1.6，synchronized 进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。</li><li>锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀；</li><li>JDK 1.6 中默认是开启偏向锁和轻量级锁，可以通过-XX:-UseBiasedLocking 来禁用偏向锁</li></ol>]]></content>
    
    <summary type="html">
    
      synchronized 它可以把任意一个非NULL的对象当作锁，属于独占式的悲观锁，同时属于可重入锁。
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
      <category term="锁" scheme="http://blog.linzhongtai.cn/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之多线程并发：自旋锁</title>
    <link href="http://blog.linzhongtai.cn/2019/03/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%9A%E8%87%AA%E6%97%8B%E9%94%81/"/>
    <id>http://blog.linzhongtai.cn/2019/03/重温系列之多线程并发：自旋锁/</id>
    <published>2019-03-31T05:49:48.000Z</published>
    <updated>2019-03-31T05:49:48.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p></blockquote><p>自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。</p><p>线程自旋是需要消耗cpu的，说白了就是让cpu在做无用功，如果一直获取不到锁，那线程也不能一直占用cpu自旋做无用功，所以需要设定一个自旋等待的最大时间。</p><p>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p><h2 id="自旋锁的优缺点"><a href="#自旋锁的优缺点" class="headerlink" title="自旋锁的优缺点"></a>自旋锁的优缺点</h2><ul><li>优点</li></ul><p>自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换</p><ul><li>缺点</li></ul><p>如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为<strong>自旋锁在获取锁前一直都是占用 cpu 做无用功</strong>，占着茅坑不 拉屎，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要cpu的线程又不能获取到cpu，造成 cpu 的浪费，所以这种情况下我们要关闭自旋锁。</p><h2 id="自旋锁时间阈值-1-6-引入了适应性自旋锁"><a href="#自旋锁时间阈值-1-6-引入了适应性自旋锁" class="headerlink" title="自旋锁时间阈值(1.6 引入了适应性自旋锁)"></a>自旋锁时间阈值(1.6 引入了适应性自旋锁)</h2><p>自旋锁的目的是为了占着 CPU 的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选择额外重要。<br>JVM对于自旋周期的选择，jdk1.5这个限度是一定的写死的，在<strong>1.6引入了适应性自旋锁</strong>，适应性自旋锁意味着自旋的时间不在是固定的了，而是<strong>由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定</strong>，基本认为一个线程上下文切换的时间是最佳的一个时间，同时JVM还针对当前CPU的负荷情况做了较多的优化。</p><ol><li>如果平均负载小于CPUs则一直自旋</li><li>如果有超过(CPUs/2)个线程正在自旋，则后来线程直接阻塞</li><li>如果正在自旋的线程发现Owner发生了变化则延迟自旋时间（自旋计数）或进入阻塞</li><li>如果CPU处于节电模式则停止自旋</li><li>自旋时间的最坏情况是CPU的存储延迟（CPU A存储了一个数据，到CPU B得知这个数据直接的时间差）</li><li>自旋时会适当放弃线程优先级之间的差异</li></ol><h2 id="自旋锁的开启"><a href="#自旋锁的开启" class="headerlink" title="自旋锁的开启"></a>自旋锁的开启</h2><ul><li>JDK1.6中-XX:+UseSpinning开启； </li><li>-XX:PreBlockSpin=10 为自旋次数； </li><li>JDK1.7后，去掉此参数，由jvm控制；</li></ul>]]></content>
    
    <summary type="html">
    
      当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
      <category term="锁" scheme="http://blog.linzhongtai.cn/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之多线程并发：乐观锁与悲观锁</title>
    <link href="http://blog.linzhongtai.cn/2019/03/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%9A%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81/"/>
    <id>http://blog.linzhongtai.cn/2019/03/重温系列之多线程并发：乐观锁与悲观锁/</id>
    <published>2019-03-31T05:48:43.000Z</published>
    <updated>2019-03-31T05:48:43.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>悲观锁：适合写操作多的场景，先加锁可以保证写操作时数据正确。<br>乐观锁：适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</p></blockquote><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p><strong>总是假设最好的情况，每次去拿数据的时候都认为不会修改，所以不会上锁，但在更新的时候会判断一下在此期间这个数据有没有更新，可以使用版本号机制和CAS(Compare And Swap)算法实现。</strong><br>乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p><blockquote><p>乐观锁一般会使用版本号机制或CAS算法实现。</p></blockquote><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h4><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p><h4 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h4><ul><li>需要读写的内存值 V</li><li>进行比较的值 A</li><li>要写入的新值 B</li></ul><p><strong>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</strong></p><h3 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a>乐观锁的缺点</h3><ul><li>ABA 问题</li></ul><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。<br>JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值</p><ul><li>循环时间长开销大</li></ul><p><strong>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销</strong></p><ul><li>只能保证一个共享变量的原子操作</li></ul><p><strong>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效</strong>。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起。可以依靠数据库实现，如行锁、读锁和写锁等，都是在操作之前加锁，在Java中，synchronized的思想也是悲观锁。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</p>]]></content>
    
    <summary type="html">
    
      乐观or悲观
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
      <category term="锁" scheme="http://blog.linzhongtai.cn/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之多线程并发：线程方法</title>
    <link href="http://blog.linzhongtai.cn/2019/03/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95/"/>
    <id>http://blog.linzhongtai.cn/2019/03/重温系列之多线程并发：线程方法/</id>
    <published>2019-03-30T12:54:30.000Z</published>
    <updated>2019-03-30T12:54:30.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/5937589-a786abecc68cf0a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><p>线程调用该方法将启动线程，使之从新建状态进入就绪队列排队，一旦轮到它来享用CPU资源时，就可以脱离创建它的线程独立开始自己的生命周期了。</p><h2 id="run-线程执行"><a href="#run-线程执行" class="headerlink" title="run-线程执行"></a>run-线程执行</h2><p>Thread类的run()方法与Runnable接口中的run()方法的功能和作用相同，都用来定义线程对象被调度之后所执行的操作，都是系统自动调用而用户程序不得引用的方法。</p><h2 id="wait-线程等待"><a href="#wait-线程等待" class="headerlink" title="wait-线程等待"></a>wait-线程等待</h2><p>调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知(notify/notifyAll)或被中断才会返回，需要注意的是调用 wait()方法后，<strong>会释放对象的锁</strong>。因此，wait 方法一般用在同步方法或同步代码块中。</p><h2 id="sleep-线程睡眠"><a href="#sleep-线程睡眠" class="headerlink" title="sleep-线程睡眠"></a>sleep-线程睡眠</h2><p>sleep 导致当前线程休眠，与 wait 方法不同的是 sleep 不会释放当前占有的锁,sleep(long)会导致线程进入 TIMED-WATING 状态，而 wait()方法会导致当前线程进入 WATING 状态</p><h2 id="yield-线程让步"><a href="#yield-线程让步" class="headerlink" title="yield-线程让步"></a>yield-线程让步</h2><p>yield 会使当前线程让出 CPU 执行时间片，与其他线程一起重新竞争 CPU 时间片。一般情况下，优先级高的线程有更大的可能性成功竞争得到 CPU 时间片，但这又不是绝对的，有的操作系统对线程优先级并不敏感</p><h2 id="interrupt-线程中断"><a href="#interrupt-线程中断" class="headerlink" title="interrupt-线程中断"></a>interrupt-线程中断</h2><p>中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位。这个线程本身并不会因此而改变状态(如阻塞，终止等)</p><ol><li>调用 interrupt()方法并不会中断一个正在运行的线程。也就是说处于 Running 状态的线程并不会因为被中断而被终止，仅仅改变了内部维护的中断标识位而已</li><li>若调用 sleep()而使线程处于 TIMED-WATING 状态，这时调用interrupt()方法，会抛出InterruptedException,从而使线程提前结束 TIMED-WATING 状态。</li><li>许多声明抛出 InterruptedException 的方法(如Thread.sleep(long mills 方法))，抛出异常前，都会清除中断标识位，所以抛出异常后，调用isInterrupted()方法将会返回 false。</li><li>中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止一个线程thread的时候，可以调用thread.interrupt()方法，在线程的run方法内部可以根据 thread.isInterrupted()的值来优雅的终止线程</li></ol><h2 id="join-等待线程终止"><a href="#join-等待线程终止" class="headerlink" title="join-等待线程终止"></a>join-等待线程终止</h2><blockquote><p>join(0)的意思不是A线程等待B线程0秒，而是A线程等待B线程无限时间，直到B线程执行完毕，即join(0)等价于join();<br>join(10)，则表示A线程会等待B线程执行10毫秒，10毫秒过后，A、B线程并行执行</p></blockquote><p>join() 方法，放弃当前线程的执行，等待其他线程终止，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞状态，等到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu</p><h2 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h2><p>Object 类中的 notify() 方法，<strong>唤醒在此对象监视器上等待的单个线程</strong>，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，<strong>选择是任意的</strong>，并在对实现做出决定时发生，线程通过调用其中一个 wait() 方法，在对象的监视器上等待，<strong>直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程</strong>，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。类似的方法还有 notifyAll() ，唤醒再次监视器上等待的所有线程</p><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><ol><li>sleep()：强迫一个线程睡眠Ｎ毫秒。</li><li>isAlive()： 判断一个线程是否存活。</li><li>join()： 等待线程终止。</li><li>activeCount()： 程序中活跃的线程数。</li><li>enumerate()： 枚举程序中的线程。</li><li>currentThread()： 得到当前线程。</li><li>isDaemon()： 一个线程是否为守护线程。</li><li>setDaemon()： 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束)</li><li>setName()： 为线程设置一个名称。</li><li>wait()： 强迫一个线程等待。</li><li>notify()： 通知一个线程继续运行。</li><li>setPriority()： 设置一个线程的优先级。</li><li>getPriority():    获得一个线程的优先级</li></ol><h2 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h2><ol><li>sleep方法属于Thread类，wait方法属于Object类</li><li>sleep()方法导致了程序暂停执行指定的时间，让出 cpu给其他线程，但是监控状态依然保持着，当指定的时间到了又会自动恢复运行状态</li><li>在调用 sleep()方法的过程中，线程不会释放对象锁</li><li>而当调用 wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用 notify()/notifyAll()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态</li></ol><h2 id="start与run区别"><a href="#start与run区别" class="headerlink" title="start与run区别"></a>start与run区别</h2><ol><li>start()方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码</li><li>通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行</li><li>方法 run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行 run 函数当中的代码。 Run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程</li></ol>]]></content>
    
    <summary type="html">
    
      start/wait/sleep/notify...
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之多线程并发：线程生命周期</title>
    <link href="http://blog.linzhongtai.cn/2019/03/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://blog.linzhongtai.cn/2019/03/重温系列之多线程并发：线程生命周期/</id>
    <published>2019-03-30T12:52:30.000Z</published>
    <updated>2019-03-30T12:52:30.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。<br>在线程的生命周期中，它要经过<strong>新建(New)、就绪(Runnable)、运行(Running)、阻塞(Blocked)和死亡(Dead)</strong>这5 种状态。尤其是当线程启动以后，它不可能一直”霸占”着 CPU 独自运行，所以 CPU 需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换。<br><img src="http://upload-images.jianshu.io/upload_images/5937589-7feb259b7240994e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="新建状态NEW"><a href="#新建状态NEW" class="headerlink" title="新建状态NEW"></a>新建状态NEW</h2><p>当程序<strong>使用 new 关键字创建了一个线程之后</strong>，该线程就处于新建状态，此时仅由 JVM 为其分配内存，并初始化其成员变量的值</p><h2 id="就绪状态-RUNNABLE"><a href="#就绪状态-RUNNABLE" class="headerlink" title="就绪状态(RUNNABLE )"></a>就绪状态(RUNNABLE )</h2><p>当线程对象<strong>调用了 start()方法之后</strong>，该线程处于就绪状态。Java 虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。</p><h2 id="运行状态-RUNNING"><a href="#运行状态-RUNNING" class="headerlink" title="运行状态(RUNNING)"></a>运行状态(RUNNING)</h2><p>如果<strong>处于就绪状态的线程获得了 CPU，开始执行 run()方法的线程执行体</strong>，则该线程处于运行状态。</p><h2 id="阻塞状态-BLOCKED"><a href="#阻塞状态-BLOCKED" class="headerlink" title="阻塞状态(BLOCKED)"></a>阻塞状态(BLOCKED)</h2><blockquote><p>阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice，暂时停止运行。直到线程进入可运行/就绪(runnable)状态，才有机会再次获得 cpu timeslice 转到运行(running)状态。</p></blockquote><p>阻塞的情况分三种：</p><ul><li><strong>等待阻塞</strong>( o.wait-&gt; 等待对列)：运行(running)的线程执行 o.wait()方法，JVM 会把该线程放入等待队列(waitting queue)中</li><li><strong>同步阻塞</strong> (lock-&gt; 锁池)：运行(running)的线程在获取对象的同步锁时，若该<strong>同步锁被别的线程占用</strong>，则 JVM 会把该线程放入锁池(lock pool)中</li><li><strong>其他阻塞</strong> (sleep/join)：运行(running)的线程执行 Thread.sleep(long ms)或 t.join()方法，或者发出了 I/O 请求时，JVM 会把该线程置为阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O处理完毕时，线程重新转入可运行(runnable)状态。</li></ul><h2 id="线程死亡-DEAD"><a href="#线程死亡-DEAD" class="headerlink" title="线程死亡(DEAD)"></a>线程死亡(DEAD)</h2><p>线程会以下面三种方式结束，结束后就是死亡状态。</p><ol><li>正常结束<br>run()或 call()方法执行完成，线程正常结束</li><li>异常结束<br>线程抛出一个未捕获的 Exception 或 Error</li><li>调用stop-已废弃<br>直接调用该线程的 stop()方法来结束该线程(该方法通常容易导致死锁，不推荐使用)<h3 id="终止线程四种方式"><a href="#终止线程四种方式" class="headerlink" title="终止线程四种方式"></a>终止线程四种方式</h3></li><li>正常运行结束</li><li><p>使用退出标志退出线程<br>一般 run()方法执行完，线程就会正常结束，但是有些线程需要长时间的<br>运行，只有在外部某些条件满足的情况下，才能关闭这些线程。使用一个变量来控制循环，例如：最直接的方法就是设一个boolean 类型的标志，并通过设置这个标志为 true或 false 来控制 while循环是否退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadSafe extends Thread &#123;</span><br><span class="line">  public volatile boolean exit = false;// volatile保证数据可见性，使得exit值同步</span><br><span class="line">  public void run() &#123;</span><br><span class="line">    while (!exit)&#123;</span><br><span class="line">      //do something</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Interrupt  方法结束线程<br>使用 interrupt()方法来中断线程有两种情况：</p></li></ol><ul><li>线程处于阻塞状态</li></ul><p>如使用了 sleep/同步锁的 wait/socket 中的 receiver,accept 等方法时，会使线程处于阻塞状态。当调用线程的 interrupt()方法时，会抛出InterruptException 异常。<br><strong>通常很多人认为只要调用 interrupt 方法线程就会结束，实际上是错的， 一定要先捕获 InterruptedException 异常之后通过 break 来跳出循环，才能正常结束 run 方法</strong></p><ul><li>线程未处于阻塞状态</li></ul><p>使用 isInterrupted()判断线程的中断标志来退出循环。当使用<br>interrupt()方法时，中断标志就会置 true，和使用自定义的标志来控制循环是一样的道理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadSafe extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">      while (!isInterrupted())&#123; //非阻塞过程中通过判断中断标志来退出</span><br><span class="line">        try&#123;</span><br><span class="line">          Thread.sleep(5*1000);//阻塞过程捕获中断异常来退出</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">          break;//捕获到异常之后，执行 break 跳出循环</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>stop 方法终止线程（线程不安全，已废弃）</li></ol><blockquote><p>thread.stop()调用之后，创建子线程的线程就会抛出 ThreadDeatherror 的错误，并且会释放子线程所持有的所有锁。</p></blockquote><p>一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在<strong>调用<br>thread.stop()后导致了该线程所持有的所有锁的突然释放(不可控制)</strong>，那么被保护数据就有可能呈现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因此，并不推荐使用 stop 方法来终止线程。</p>]]></content>
    
    <summary type="html">
    
      NEW-RUNNING-BLOCKED-DEAD
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之多线程并发：Java线程实现/创建方式</title>
    <link href="http://blog.linzhongtai.cn/2019/03/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0-%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/"/>
    <id>http://blog.linzhongtai.cn/2019/03/重温系列之多线程并发：Java线程实现-创建方式/</id>
    <published>2019-03-30T07:13:18.000Z</published>
    <updated>2019-03-30T07:13:18.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h2><blockquote><p>Thread实质上是实现了Runnable接口的一个实例。</p></blockquote><p>启动线程的唯一方法是通过Thread的start()实例方法。start()是一个native方法，将启动新线程，并执行run()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public TestThread extends Thread()&#123;</span><br><span class="line">        public void run()&#123;</span><br><span class="line">                System.out.println(&quot;TestThread run&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">TestThread test = new TestThread();</span><br><span class="line">test.start();</span><br></pre></td></tr></table></figure></p><h2 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h2><ol><li><p>如果此时类已经继承了其他的父类，那么无法直接继承Thread，则可以实现一个Runnable。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends OtherClass implements Runnable &#123;  </span><br><span class="line">　　public void run() &#123;  </span><br><span class="line">　　 System.out.println(&quot;MyThread.run()&quot;);  </span><br><span class="line">　　&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动MyThread，需要首先实例化一个Thread，然后将MyThread作为一个target传入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyThread myThread = new MyThread();  </span><br><span class="line">Thread thread = new Thread(myThread);  </span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure></li><li><p>当传入一个 Runnable target 参数给 Thread 后，Thread 的 run()方法就会调用target.run()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;  </span><br><span class="line">　　if (target != null) &#123;  </span><br><span class="line">　　 target.run();  </span><br><span class="line">　　&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="ExecutorService-、Callable-、Future有返回值线程"><a href="#ExecutorService-、Callable-、Future有返回值线程" class="headerlink" title="ExecutorService 、Callable 、Future有返回值线程"></a>ExecutorService 、Callable<class> 、Future有返回值线程</class></h2><blockquote><p>有返回值的任务 Callable，无返回值的任务 Runnable</p></blockquote><p>执行Callable任务后，可以获取一个 Future 的对象，在该对象上调用 get 就可以获取到 Callable 任务返回的 Object 了，再结合线程池接口 ExecutorService 就可以实现传说中有返回结果的多线程了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//创建一个线程池</span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(taskSize);</span><br><span class="line">// 创建多个有返回值的任务</span><br><span class="line">List&lt;Future&gt; list = new ArrayList&lt;Future&gt;();</span><br><span class="line">for (int i = 0; i &lt; taskSize; i++) &#123;</span><br><span class="line">    Callable c = new MyCallable(i + &quot; &quot;);</span><br><span class="line">    // 执行任务并获取 Future 对象</span><br><span class="line">    Future f = pool.submit(c);</span><br><span class="line">    list.add(f);</span><br><span class="line">&#125;</span><br><span class="line">// 关闭线程池</span><br><span class="line">pool.shutdown();</span><br><span class="line">// 获取所有并发任务的运行结果</span><br><span class="line">for (Future f : list) &#123;</span><br><span class="line">    // 从 Future 对象上获取任务的返回值，并输出到控制台</span><br><span class="line">    System.out.println(&quot;res：&quot; + f.get().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="基于线程池的方式"><a href="#基于线程池的方式" class="headerlink" title="基于线程池的方式"></a>基于线程池的方式</h2><p>线程和数据库连接这些资源都是非常宝贵的资源。那么每次需要的时候创建，不需要的时候销毁，是非常浪费资源的。那么我们就可以使用缓存的策略，也就是使用线程池。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 创建线程池</span><br><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(10);</span><br><span class="line">while(true) &#123;</span><br><span class="line">  threadPool.execute(new Runnable() &#123; // 提交多个线程任务，并执行</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; is running ..&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4种线程池"><a href="#4种线程池" class="headerlink" title="4种线程池"></a>4种线程池</h3><blockquote><p>Java 里面线程池的顶级接口是 Executor，但是严格意义上讲 Executor 并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是 ExecutorService。</p></blockquote><p>线程池底层都是通过ThreadPoolExecutor来实现的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                   <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                   <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                   TimeUnit unit,</span><br><span class="line">                   BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                   ThreadFactory threadFactory,</span><br><span class="line">                   RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure></p><p><strong>corePoolSize</strong>: 表示需要设置的线程个数；<strong>maximumPoolSize</strong>: 线程池允许的最大线程个数； <strong>keepAliveTime</strong>: 空闲线程存活的时间，超过这个时间就会被回收； unit: 存活时间的单位；<strong>workQueue</strong>: 需要执行的任务队列。<strong>threadFactory</strong>: 线程工厂，用于创建线程，一般用默认的即可；<strong>handler</strong>: 拒绝策略，当任务太多来不及处理，如何拒绝任务； 拒绝策略： 直接丢弃（DiscardPolicy） 丢弃队列中最老的任务(DiscardOldestPolicy) 抛异常(AbortPolicy) 将任务分给调用线程来执行(CallerRunsPolicy)</p><h4 id="newCachedThreadPool：可缓存线程池"><a href="#newCachedThreadPool：可缓存线程池" class="headerlink" title="newCachedThreadPool：可缓存线程池"></a>newCachedThreadPool：<strong>可缓存线程池</strong></h4><blockquote><p>如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><ul><li>工作线程的创建数量几乎没有限制(数目限制为Interger. MAX_VALUE), 可灵活的往线程池中添加线程。</li><li>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</li><li>在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有可能会造成系统瘫痪。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                      60L, TimeUnit.SECONDS,</span><br><span class="line">                                      new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><p><strong>SynchronousQueue</strong>：<br>SynchronousQueue是无界的，是一种无缓冲的等待队列，但是由于该Queue本身的特性，<strong>在某次添加元素put后必须等待其他线程取走take后才能继续添加</strong>；可以认为SynchronousQueue是一个缓存值为1的阻塞队列，但是 isEmpty()方法永远返回是true，remainingCapacity() 方法永远返回是0，remove()和removeAll() 方法永远返回是false，iterator()方法永远返回空，peek()方法永远返回null。<br>声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的行为。<br><strong>公平模式和非公平模式的区别</strong>:如果采用公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO先进先出队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；但如果是非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO后进先出队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</p><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><blockquote><p>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。(可控制线程最大并发数，超出的线程会在队列中等待)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">        return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。</p><ul><li>如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。</li><li>如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。</li><li>在某个线程被显式地关闭之前，池中的线程将一直存在。</li></ul><p><strong>LinkedBlockingQueue</strong>是无界的，是一个无界缓存的等待队列。<br>基于链表的阻塞队列，内部维持着一个数据缓冲队列（该队列由链表构成）。当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。<br>LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p><h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h4><blockquote><p>创建一个定长线程池，支持定时及周期性任务执行</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">       ThreadPoolExecutor(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span><br><span class="line">             new DelayedWorkQueue());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>schedule：延迟执行一次</li><li>scheduleAtFixedRate：固定的频率来执行某项计划，它不受计划执行时间的影响</li><li>scheduleWithFixedDelay：无论任务执行多长时间，等执行完了，再延迟指定的时间，受计划执行时间的影响<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledThreadPool= Executors.newScheduledThreadPool(3);</span><br><span class="line">scheduledThreadPool.schedule(newRunnable()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;延迟三秒&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, 3, TimeUnit.SECONDS);</span><br><span class="line">scheduledThreadPool.scheduleAtFixedRate(newRunnable()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;延迟 1 秒后每三秒执行一次（不受计划执行时间的影响）&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;,1,3,TimeUnit.SECONDS);</span><br><span class="line">scheduledThreadPool.scheduleWithFixedDelay(newRunnable()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;延迟 1 秒后每三秒执行一次（受计划执行时间的影响）&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;,1,3,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></li></ul><p><strong>DelayedWorkQueue</strong></p><blockquote><blockquote><p>使用优先级队列DelayedWorkQueue，保证添加到队列中的任务，会按照任务的延时时间进行排序，延时时间少的任务首先被获取。</p></blockquote></blockquote><ol><li>元素个数超过数组长度，就会调用grow()方法，进行数组扩容。</li><li>将新元素e添加到优先级队列中对应的位置，通过siftUp方法，保证按照元素的优先级排序。</li><li>如果新插入的元素是队列头，即更换了队列头，那么就要唤醒正在等待获取任务的线程。这些线程可能是因为原队列头元素的延时时间没到，而等待的。</li></ol><h4 id="NewSingleThreadExecutor"><a href="#NewSingleThreadExecutor" class="headerlink" title="NewSingleThreadExecutor"></a>NewSingleThreadExecutor</h4><blockquote><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</p></blockquote><p><strong>这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">        return new FinalizableDelegatedExecutorService</span><br><span class="line">            (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>LinkedBlockingQueue</strong>是无界的，是一个无界缓存的等待队列。<br>基于链表的阻塞队列，内部维持着一个数据缓冲队列（该队列由链表构成）。当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。<br>LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p>]]></content>
    
    <summary type="html">
    
      Java线程实现方式以及四种线程池
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之Java集合</title>
    <link href="http://blog.linzhongtai.cn/2019/03/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8BJava%E9%9B%86%E5%90%88/"/>
    <id>http://blog.linzhongtai.cn/2019/03/重温系列之Java集合/</id>
    <published>2019-03-28T07:38:07.000Z</published>
    <updated>2019-03-28T07:38:07.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/5937589-a9744eacd7c5472d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>集合类存放于 Java.util 包中，主要有 3 种：set(集）、list(列表包含 Queue）和 map(映射)。</p><ol><li>Collection：Collection 是集合 List、Set、Queue 的最基本的接口。</li><li>Iterator：迭代器，可以通过迭代器遍历集合中的数据</li><li>Map：是映射表的基础接口<br><img src="http://upload-images.jianshu.io/upload_images/5937589-e6bec3a42c025e9e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li></ol><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><blockquote><p>List里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。</p></blockquote><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li>ArrayList在内存不够时默认是扩展50% + 1个，Vector是默认扩展1倍。</li><li>Vector属于线程安全级别的，但是大多数情况下不使用Vector，因为线程安全需要更大的系统开销。</li><li>一般使用ArrayList和LinkedList比较多，LinkedList不存在get()的操作，不能单个定位，ArrayList是顺序存储结构，LinkedList是链表存储结构</li><li>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针</li><li>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据</li></ul><h3 id="ArrayList（常用、数组实现，对元素快速随机访问）"><a href="#ArrayList（常用、数组实现，对元素快速随机访问）" class="headerlink" title="ArrayList（常用、数组实现，对元素快速随机访问）"></a>ArrayList（常用、数组实现，对元素快速随机访问）</h3><p>ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除</p><h3 id="Vector（数组实现、线程同步、需高花费）"><a href="#Vector（数组实现、线程同步、需高花费）" class="headerlink" title="Vector（数组实现、线程同步、需高花费）"></a>Vector（数组实现、线程同步、需高花费）</h3><p>Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢</p><h3 id="LinkedList（链表结构、Queue）"><a href="#LinkedList（链表结构、Queue）" class="headerlink" title="LinkedList（链表结构、Queue）"></a>LinkedList（链表结构、Queue）</h3><p>LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用</p><blockquote><p>ArrayList和LinkedList在用法上没有区别，但是在功能上还是有区别的。LinkedList经常用在增删操作较多而查询操作很少的情况下，ArrayList则相反</p></blockquote><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><blockquote><p>Set集合不允许出现重复数据<br>允许包含值为null的元素，但最多只能有一个null元素。</p></blockquote><p>Set 注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号）判断的，如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方法。</p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><ul><li>HashSet中不能有重复的元素</li><li>HashSet是无序的</li><li>HashSet也是基于HashMap实现</li></ul><p>哈希表边存放的是哈希值。HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals 方法 如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。</p><blockquote><p>HashSet 通过 hashCode 值来确定元素在内存中的位置。一个 hashCode 位置上可以存放多个元素。</p></blockquote><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><ul><li>TreeSet中不能有重复的元素；</li><li>TreeSet具有排序功能，缺省是按照自然排序进行排列</li><li>TreeSet中的元素必须实现Comparable接口并重写compareTo()方法，TreeSet判断元素是否重复 、以及确定元素的顺序靠的都是这个方法</li><li>基于TreeMap实现</li></ul><ol><li>TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。</li><li>Integer 和 String 对象都可以进行默认的 TreeSet 排序，而<strong>自定义类的对象是不可以的，自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数</strong>，才可以正常使用。</li><li>在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序</li><li>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。</li></ol><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><blockquote><p>Map集合中存储的是键值对，键不能重复，值可以重复。根据键得到值，对map集合遍历时先得到键的set集合，对set集合进行遍历，得到相应的值</p></blockquote><p>Map遍历：KeySet()、entrySet()<br>keySet其实是遍历了2次，一次是转为iterator，一次就是从HashMap中取出key所对于的value。而entryset只是遍历了第一次，它把key和value都放到了entry中，所以<strong>entrySet效率较高</strong></p><h3 id="HashMap-数组-链表-红黑树"><a href="#HashMap-数组-链表-红黑树" class="headerlink" title="HashMap(数组+ 链表+ 红黑树)"></a>HashMap(数组+ 链表+ 红黑树)</h3><p>HashMap是最常用的Map，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。因为键对象不可以重复，所以HashMap最多只允许一条记录的键为Null，允许多条记录的值为Null，是非同步的</p><ul><li>HashMap是无序的散列映射表；</li><li>HashMap通过Hash 算法来决定存储位置</li><li>底层实现是哈希表<h4 id="java7实现"><a href="#java7实现" class="headerlink" title="java7实现"></a>java7实现</h4><img src="http://upload-images.jianshu.io/upload_images/5937589-a994b71010fe6416.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。</li></ul><ol><li>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。</li><li>loadFactor：负载因子，默认为 0.75。</li><li>threshold：扩容的阈值，等于 capacity * loadFactor<h4 id="java8实现"><a href="#java8实现" class="headerlink" title="java8实现"></a>java8实现</h4><blockquote><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。</p></blockquote></li></ol><p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，<strong>需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)</strong>。为了降低这部分的开销，在 Java8 中，<strong>当链表中的元素超过了 8 个以后，会将链表转换为红黑树</strong>，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。<br><img src="http://upload-images.jianshu.io/upload_images/5937589-3e29e0cf98e2070f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="ConcurrentHashMap（线程安全）"><a href="#ConcurrentHashMap（线程安全）" class="headerlink" title="ConcurrentHashMap（线程安全）"></a>ConcurrentHashMap（线程安全）</h3><ul><li>JDK1.7分析：ConcurrentHashMap采用 分段锁的机制，实现并发的更新操作，底层采用数组+链表的存储结构<br><img src="http://upload-images.jianshu.io/upload_images/5937589-46911a5688705fd6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li><li>JDK1.8分析：1.8的实现已经抛弃了Segment分段锁机制，利用CAS+Synchronized来保证并发更新的安全，底层采用数组+链表+红黑树的存储结构<br><img src="http://upload-images.jianshu.io/upload_images/5937589-3bbf539fb495d071.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li><li>CAS的思想：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。</li></ul><h4 id="Segment-段"><a href="#Segment-段" class="headerlink" title="Segment 段"></a>Segment 段</h4><p>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。</p><h4 id="线程安全（Segment-继承-ReentrantLock-加锁）"><a href="#线程安全（Segment-继承-ReentrantLock-加锁）" class="headerlink" title="线程安全（Segment  继承 ReentrantLock 加锁）"></a>线程安全（Segment  继承 ReentrantLock 加锁）</h4><p>ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。 </p><h4 id="并行度（默认-16-）"><a href="#并行度（默认-16-）" class="headerlink" title="并行度（默认 16 ）"></a>并行度（默认 16 ）</h4><p>concurrencyLevel：并行级别、并发数、Segment 数。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。</p><h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>Hashtable与HashMap类似，是HashMap的线程安全版，它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢，它继承自Dictionary类，不同的是它不允许记录的键或者值为null，同时效率较低</p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序（自然顺序），也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。不允许key值为空，非同步的</p><ul><li>适用于按自然顺序或自定义顺序遍历键(key)。</li><li>底层是二叉树</li><li>提供compareTo，可以定义排序方法</li></ul><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>LinkedHashMap保存了记录的插入顺序，在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢，有HashMap的全部特性。</p><h2 id="主要实现类区别"><a href="#主要实现类区别" class="headerlink" title="主要实现类区别"></a>主要实现类区别</h2><h3 id="Vector-VS-ArrayList"><a href="#Vector-VS-ArrayList" class="headerlink" title="Vector VS ArrayList"></a>Vector VS ArrayList</h3><ul><li>vector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用arraylist效率比较高。</li><li>如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%，而arraylist增长率为目前数组长度的50%。如果在集合中使用数据量比较大的数据，用vector有一定的优势。</li><li>如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，如果频繁的访问数据，这个时候使用vector和arraylist都可以。而如果移动一个指定位置会导致后面的元素都发生移动，这个时候就应该考虑到使用linklist,因为它移动一个指定位置的数据时其它元素不移动。</li><li>ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要涉及到数组元素移动等内存操作，所以索引数据快，插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快</li></ul><h3 id="ArrayList-VS-LinkedList"><a href="#ArrayList-VS-LinkedList" class="headerlink" title="ArrayList VS LinkedList"></a>ArrayList VS LinkedList</h3><ul><li>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</li><li>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</li><li>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据</li></ul><h3 id="HashMap-VS-TreeMap"><a href="#HashMap-VS-TreeMap" class="headerlink" title="HashMap VS TreeMap"></a>HashMap VS TreeMap</h3><ul><li>HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。</li><li>在Map 中插入、删除和定位元素，HashMap是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。<br>两个map中的元素一样，但顺序不一样，导致hashCode()不一样。<br>同样做测试：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在HashMap中，同样的值的map,顺序不同，equals时，false;</span><br><span class="line">而在treeMap中，同样的值的map,顺序不同,equals时，true，</span><br><span class="line">说明treeMap在equals()时是整理了顺序了的</span><br></pre></td></tr></table></figure></li></ul><h3 id="HashTable-VS-HashMap"><a href="#HashTable-VS-HashMap" class="headerlink" title="HashTable VS HashMap"></a>HashTable VS HashMap</h3><ul><li>同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的。</li><li>HashMap允许存在一个为null的key，多个为null的value 。</li><li>hashtable的key和value都不允许为null</li></ul><p>参考：<a href="https://www.cnblogs.com/leeplogs/p/5891861.html" target="_blank" rel="noopener">JAVA集合类汇总</a>、<a href="https://blog.csdn.net/initphp/article/details/8264219" target="_blank" rel="noopener">深入理解Java集合</a></p>]]></content>
    
    <summary type="html">
    
      List/Set/Map
    
    </summary>
    
      <category term="JAVA" scheme="http://blog.linzhongtai.cn/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://blog.linzhongtai.cn/tags/JAVA/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之JVM：类加载机制</title>
    <link href="http://blog.linzhongtai.cn/2019/03/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8BJVM%EF%BC%9A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://blog.linzhongtai.cn/2019/03/重温系列之JVM：类加载机制/</id>
    <published>2019-03-28T04:13:30.000Z</published>
    <updated>2019-03-28T04:13:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class SingletonA&#123;</span><br><span class="line">    private static SingletonA singleton = new SingletonA();</span><br><span class="line">    public static int a;</span><br><span class="line">    public static int b= 0;</span><br><span class="line"></span><br><span class="line">    private SingletonA()&#123;</span><br><span class="line">        a++;</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonA getInstance()&#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SingletonB&#123;</span><br><span class="line">    public static int a;</span><br><span class="line">    public static int b= 0;</span><br><span class="line">    private static SingletonB singleton = new SingletonB();</span><br><span class="line"></span><br><span class="line">    private SingletonB()&#123;</span><br><span class="line">        a++;</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonB getInstance()&#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        SingletonA singleton = SingletonA.getInstance();</span><br><span class="line">        System.out.println(&quot;SingletonA a:&quot; + singleton.a);</span><br><span class="line">        System.out.println(&quot;SingletonA b:&quot; + singleton.b);</span><br><span class="line"></span><br><span class="line">        SingletonB singleton = SingletonB .getInstance();</span><br><span class="line">        System.out.println(&quot;SingletonB a:&quot; + singleton.a);</span><br><span class="line">        System.out.println(&quot;SingletonB b:&quot; + singleton.b);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SingletonA a: 1 </span><br><span class="line">SingletonA b: 0 </span><br><span class="line">SingletonB a: 1 </span><br><span class="line">SingletonB b: 1</span><br></pre></td></tr></table></figure></p><p>SingletonA 解析过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、首先执行main中的SingletonA singleton = SingletonA .getInstance(); </span><br><span class="line">2、类的加载：加载类SingletonA </span><br><span class="line">3、类的验证 </span><br><span class="line">4、类的准备：为静态变量分配内存，设置默认值。这里为singleton(引用类型)设置为null,</span><br><span class="line">a,b（基本数据类型）设置默认值0 </span><br><span class="line">5、类的初始化（按照赋值语句进行修改）： </span><br><span class="line">执行private static SingletonA singleton = new SingletonA(); </span><br><span class="line">执行SingletonA 的构造器：a++;b++; 此时a，b均等于1 </span><br><span class="line">执行 </span><br><span class="line">public static int a; </span><br><span class="line">public static int b= 0; </span><br><span class="line">此时a=1，b=0</span><br></pre></td></tr></table></figure></p><p>SingletonB 解析过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、首先执行main中的SingletonB singleton = SingletonB.getInstance(); </span><br><span class="line">2、类的加载：加载类SingletonB</span><br><span class="line">3、类的验证 </span><br><span class="line">4、类的准备：为静态变量分配内存，设置默认值。这里为a,b（基本数据类型）设置默认值0,</span><br><span class="line">singleton(引用类型)设置为null, </span><br><span class="line">5、类的初始化（按照赋值语句进行修改）： </span><br><span class="line">执行 </span><br><span class="line">public static int value2 = 0; </span><br><span class="line">此时value2=0(value1不变，依然是0); </span><br><span class="line">执行 </span><br><span class="line">private static SingletonB singleton = new SingletonB(); </span><br><span class="line">执行SingletonB的构造器：a++;b++; </span><br><span class="line">此时a，b均等于1,即为最后结果</span><br></pre></td></tr></table></figure></p><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产出是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向我们提供了访问方法区内的数据结构的接口。</p><p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误)如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误</p><p>加载.class文件的方式：</p><ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件</li><li>从zip，jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件</li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="http://upload-images.jianshu.io/upload_images/5937589-11dad6409b7914a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p><ul><li>通过一个类的全限定名来获取其定义的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</li></ul><p>加载方式：</p><ol><li>命令行启动应用时候由JVM初始化加载</li><li>通过Class.forName()方法动态加载</li><li>通过ClassLoader.loadClass()方法动态加载</li></ol><p><strong>Class.forName()和ClassLoader.loadClass()加载的区别：</strong></p><ul><li>Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li><li>ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li><li>Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><blockquote><p>验证：确保被加载的类的正确性</p></blockquote></li></ul><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p><ol><li><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型等等。</li><li><strong>元数据验证</strong>：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外、这个类的父类是否继承了不允许被继承的类等等。</li><li><strong>字节码验证</strong>：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li><strong>符号引用验证</strong>：确保解析动作能正确执行，如果无法通过符号引用验证，那么将会抛出一个java.lang.IncompatibleClassChangeError异常的子类…</li></ol><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><blockquote><p>正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。</p></blockquote><ol><li>这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</li><li>这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</li></ol><p>假设一个类变量的定义为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static int value = 520；</span><br></pre></td></tr></table></figure><p>那么变量value在准备阶段过后的初始值为0，而不是520，因为这时候尚未开始执行任何Java方法，而把value赋值为520的public static指令是在程序编译后，存放于类构造器<clinit>()方法之中的，所以把value赋值为520的动作将在初始化阶段才会执行。</clinit></p><ol start="3"><li>如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。</li></ol><p>假设上面的类变量value被定义为：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final int value = 524；</span><br></pre></td></tr></table></figure><p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为524。可以理解为static final常量在编译期就将其结果放入了常量池中。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><blockquote><p>虚拟机将常量池内的符号引用替换成直接引用的过程。<br>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p></blockquote><p><strong>符号引用</strong>：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时可以无歧义的定位到目标即可。<br><strong>直接引用</strong>：可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p><ol><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值</li></ol><p>JVM初始化步骤：</p><ol><li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ol><p>虚拟机规范严格规定了有且只有5中情况（jdk1.7）必须对类进行“初始化”（加载、验证、准备自然需要在此之前开始）：</p><ul><li>遇到new、getstatic、putstatic、invokestatic这四条字节码指令时，如果类还没有进行过初始化，则需要先触发其初始化。生成这四条指令最常见的Java场景是：使用new关键字实例化对象时、读取或设置一个类的静态字段（static）时（被static修饰又被final修饰的，已在编译期把结果放入常量池的静态字段除外）、以及调用一个类的静态方法时。</li><li>使用Java.lang.refect包的方法对类进行反射调用时(比如：Class.forName(“com.lzt.Test”))，如果类还没有进行过初始化，则需要先触发其初始化。</li><li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先执行该主类。</li><li><p>当使用jdk1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。</p><p>虚拟机规定只有这五种情况才会触发类的初始化，称为对一个类进行主动引用，除此之外所有引用类的方式都不会触发其初始化，称为被动引用。下面举一些例子来说明被动引用。</p></li></ul><ol><li><strong>通过子类引用父类中的静态字段，这时对子类的引用为被动引用，因此不会初始化子类，只会初始化父类</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Father&#123;</span><br><span class="line">public static int f= 66;</span><br><span class="line">static&#123;</span><br><span class="line">System.out.println(&quot;父类初始化&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Child extends Father&#123;</span><br><span class="line">static&#123;</span><br><span class="line">System.out.println(&quot;子类初始化&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class StaticTest&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">System.out.println(Child.f);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>输出的结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类初始化</span><br><span class="line">66</span><br></pre></td></tr></table></figure></p><blockquote><p>对于静态字段，只有直接定义这个字段的类才会被初始化，因此，通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p></blockquote><ol start="2"><li><strong>常量在编译阶段会存入调用它的类的常量池中，本质上没有直接引用到定义该常量的类，因此不会触发定义常量的类的初始化</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Contant&#123;</span><br><span class="line">public static final String NAME = &quot;常量哦哦哦&quot;;</span><br><span class="line">static&#123;</span><br><span class="line">System.out.println(&quot;初始化Contant类&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">System.out.println(Contant.NAME);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>执行后输出的结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">常量哦哦哦</span><br></pre></td></tr></table></figure></p><p>虽然程序中引用了Contant类的常量NAME，但是在编译阶段将此常量的值“我是常量”存储到了调用它的类Test的常量池中，对常量Contant.NAME的引用实际上转化为了Test类对自身常量池的引用。也就是说，实际上Test的Class文件之中并没有Contant类的符号引用入口，这两个类在编译成Class文件后就不存在任何联系了。</p><ol start="3"><li><strong>通过数组定义来引用类，不会触发类的初始化</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Contant&#123;</span><br><span class="line">static&#123;</span><br><span class="line">System.out.println(&quot;初始化Contant&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class ArrayTest&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Contant[] contant= new Contant[6];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>执行后没有输出任何信息，因此Contant类并没有被初始化。</strong><br>  但这段代码里触发了另一个类的初始化，它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类，创建动作由字节码指令newarray触发，很明显，这是一个对数组引用类型的初初始化，而该数组中的元素仅仅包含一个对Contant类的引用，并没有对其进行初始化。如果我们加入对contant数组中各个Contant类元素的实例化代码，便会触发Contant类的初始化，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Contant&#123;</span><br><span class="line">static&#123;</span><br><span class="line">System.out.println(&quot;初始化Contant类&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class ArrayTest&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Contant[] contant= new Contant[6];</span><br><span class="line">for(Contant con:contant)</span><br><span class="line">con = new Contant();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样便会得到如下输出结果：(这里的new触发了Contant类)<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初始化Const类</span><br></pre></td></tr></table></figure></p><p>接口的初始化过程与类初始化过程的不同：<br>接口也有初始化过程，上面的代码中我们都是用静态语句块来输出初始化信息的，而在接口中不能使用“static{}”语句块，但编译器仍然会为接口生成<clinit>类构造器，用于初始化接口中定义的成员变量（实际上是static final修饰的全局常量）。</clinit></p><p><strong>二者在初始化时最主要的区别是</strong>：当一个类在初始化时，要求其父类全部已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量），才会初始化该父接口。这点也与类初始化的情况很不同，回过头来看第2个例子就知道，调用类中的static final常量时并不会 触发该类的初始化，但是调用接口中的static final常量时便会触发该接口的初始化。</p><h2 id="结束生命周期"><a href="#结束生命周期" class="headerlink" title="结束生命周期"></a>结束生命周期</h2><p>在如下几种情况下，Java虚拟机将结束生命周期</p><ul><li>执行了System.exit()方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p><img src="http://upload-images.jianshu.io/upload_images/5937589-4a6d99fb5f2d66d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><blockquote><p>父类加载器并不是通过继承关系来实现的，而是采用组合实现的。</p></blockquote><p>类加载器可以大致划分为以下三类：</p><ul><li>启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。</li><li>扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。</li><li>应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul><p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p><ol><li>在执行非置信代码之前，自动验证数字签名。</li><li>动态地创建符合用户特定需要的定制化构建类。</li><li>从特定的场所取得java class，例如数据库中和网络中。</li></ol><p>类加载机制：</p><ul><li><strong>全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li><li><strong>父类委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li><li><strong>缓存机制</strong>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li></ul><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><p><strong>双亲委派机制:</strong></p><ol><li>当<strong>AppClassLoader</strong>加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<strong>ExtClassLoader</strong>去完成。</li><li>当<strong>ExtClassLoader</strong>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给<strong>BootStrapClassLoader</strong>去完成。</li><li>如果<strong>BootStrapClassLoader</strong>加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用<strong>ExtClassLoader</strong>来尝试加载；</li><li>若<strong>ExtClassLoader</strong>也加载失败，则会使用<strong>AppClassLoader</strong>来加载，如果<strong>AppClassLoader</strong>也加载失败，则会报出异常ClassNotFoundException。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public Class&lt;?&gt; loadClass(String name)throws ClassNotFoundException &#123;</span><br><span class="line">        return loadClass(name, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve)throws ClassNotFoundException &#123;</span><br><span class="line">        // 首先判断该类型是否已经被加载</span><br><span class="line">        Class c = findLoadedClass(name);</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            //如果没有被加载，就委托给父类加载或者委派给启动类加载器加载</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent != null) &#123;</span><br><span class="line">                     //如果存在父类加载器，就委派给父类加载器加载</span><br><span class="line">                    c = parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                //如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)</span><br><span class="line">                    c = findBootstrapClass0(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">             // 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能</span><br><span class="line">                c = findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>双亲委派模型意义：</p><ul><li>系统类防止内存中出现多份同样的字节码</li><li>保证Java程序安全稳定运行</li></ul><h2 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h2><p>双亲委派模型很好的解决了各个类加载器加载基础类的统一性问题。即越基础的类由越上层的加载器进行加载。 若加载的基础类中需要回调用户代码，而这时顶层的类加载器无法识别这些用户代码，怎么办呢？这时就需要破坏双亲委派模型了。<br>下面介绍两个例子来讲解破坏双亲委派模型的过程：</p><ol><li>JNDI破坏双亲委派模型<br>JNDI是Java标准服务，它的代码由启动类加载器去加载。但是JNDI需要回调独立厂商实现的代码，而类加载器无法识别这些回调代码（SPI）。<br>为了解决这个问题，引入了一个线程上下文类加载器。 可通过Thread.setContextClassLoader()设置。 利用线程上下文类加载器去加载所需要的SPI代码，即父类加载器请求子类加载器去完成类加载的过程，而破坏了双亲委派模型。</li><li>Spring破坏双亲委派模型 <blockquote><p>Spring要对用户程序进行组织和管理，而用户程序一般放在WEB-INF目录下，由WebAppClassLoader类加载器加载，而Spring由Common类加载器或Shared类加载器加载。</p></blockquote></li></ol><p>问：<strong>Spring是如何访问WEB-INF下的用户程序呢？</strong><br>答：<strong>使用线程上下文类加载器</strong>。 Spring加载类所用的classLoader都是通过Thread.currentThread().getContextClassLoader()获取的。当线程创建时会默认创建一个AppClassLoader类加载器（对应Tomcat中的WebAppclassLoader类加载器）： setContextClassLoader(AppClassLoader)。<br>利用这个来加载用户程序。即任何一个线程都可通过getContextClassLoader()获取到WebAppclassLoader。</p>]]></content>
    
    <summary type="html">
    
      加载-连接(验证-准备-解析)-初始化-使用-卸载
    
    </summary>
    
      <category term="jvm" scheme="http://blog.linzhongtai.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://blog.linzhongtai.cn/tags/jvm/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之JVM：GC垃圾收集器</title>
    <link href="http://blog.linzhongtai.cn/2019/03/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8BJVM%EF%BC%9AGC%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://blog.linzhongtai.cn/2019/03/重温系列之JVM：GC垃圾收集器/</id>
    <published>2019-03-27T13:32:37.000Z</published>
    <updated>2019-03-27T13:32:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java 堆内存被划分为新生代和年老代两部分，新生代主要使用复制算法 ；年老代主要使用标记-整理和标记-清除垃圾回收算法，因此 java 虚拟中针对新生代和年老代分别提供了多种不同的垃圾收集器，JDK1.6 中 Sun HotSpot 虚拟机的垃圾收集器如下：<br><img src="http://upload-images.jianshu.io/upload_images/5937589-12919617c472286d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="Serial-收集器（单线程、-复制算法）"><a href="#Serial-收集器（单线程、-复制算法）" class="headerlink" title="Serial 收集器（单线程、 复制算法）"></a>Serial 收集器（单线程、 复制算法）</h2><p><strong>Serial是最基本垃圾收集器，使用复制算法。</strong><br>Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此 <strong>Serial垃圾收集器依然是 java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器</strong></p><h2 id="ParNew-收集器（Serial-多线程-多线程）"><a href="#ParNew-收集器（Serial-多线程-多线程）" class="headerlink" title="ParNew 收集器（Serial+多线程 多线程）"></a>ParNew 收集器（Serial+多线程 多线程）</h2><p>ParNew 垃圾收集器其实<strong>是 Serial 收集器的多线程版本</strong>，也使用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和 Serial 收集器完全一样，ParNew 垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。<br>ParNew 收集器默认开启和 CPU 数目相同的线程数，可通过-XX:ParallelGCThreads参数来限制垃圾收集器的线程数<br>ParNew虽然是除了多线程外和Serial收集器几乎完全一样，但是<strong>ParNew垃圾收集器是很多java虚拟机运行在 Server 模式下新生代的默认垃圾收集器</strong></p><h2 id="Parallel-Scavenge-收集器（多线程复制算法、高效）"><a href="#Parallel-Scavenge-收集器（多线程复制算法、高效）" class="headerlink" title="Parallel Scavenge 收集器（多线程复制算法、高效）"></a>Parallel Scavenge 收集器（多线程复制算法、高效）</h2><p>Parallel Scavenge 收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃圾收集器，它<strong>重点关注的是程序达到一个可控制的吞吐量</strong>（Thoughput，CPU 用于运行用户代码的时间/CPU 总消耗时间，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)），高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。<br><strong>自适应调节策略也是ParallelScavenge 收集器与 ParNew 收集器的一个重要区别。</strong></p><h2 id="Serial-Old-收集器（单线程标记整理算法）"><a href="#Serial-Old-收集器（单线程标记整理算法）" class="headerlink" title="Serial Old 收集器（单线程标记整理算法）"></a>Serial Old 收集器（单线程标记整理算法）</h2><p>Serial Old 是 Serial 垃圾收集器年老代版本，它同样是个单线程的收集器，使用标记-整理算法，这个收集器也<strong>主要是运行在 Client 默认的 java 虚拟机默认的年老代垃圾收集器。</strong></p><h2 id="Parallel-Old-收集器（多线程标记整理算法）"><a href="#Parallel-Old-收集器（多线程标记整理算法）" class="headerlink" title="Parallel Old 收集器（多线程标记整理算法）"></a>Parallel Old 收集器（多线程标记整理算法）</h2><p>Parallel Old收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在JDK1.6才开始提供。<br>在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量，<strong>Parallel Old 正是为了在年老代同样提供吞吐量优先的垃圾收集器</strong>，如果系统对吞吐量要求比较高，可以优先考虑新生代 Parallel Scavenge和年老代 Parallel Old 收集器的搭配策略。</p><h2 id="CMS-收集器（多线程标记清除算法）"><a href="#CMS-收集器（多线程标记清除算法）" class="headerlink" title="CMS 收集器（多线程标记清除算法）"></a>CMS 收集器（多线程标记清除算法）</h2><blockquote><p><strong>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。是基于多线程的“标记-清除”算法。</strong></p></blockquote><ol><li>初始标记（Stop The World）<br>只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。</li><li>并发标记（Stop The World）<br>进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。</li><li>重新标记<br>为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。</li><li>并发清除<br>清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看<strong>CMS 收集器的内存回收和用户线程是一起并发地执行。</strong></li></ol><p>CMS 收集器工作过程：<br><img src="http://upload-images.jianshu.io/upload_images/5937589-6f5c41a61b10b6f2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>优点：</p><ul><li>并发收集</li><li>低停顿</li></ul><p>缺点：</p><ul><li>对CPU资源非常敏感</li><li>无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次的Full GC的产生。</li><li>使用“标记-清除”算法会导致大量内存空间碎片（碎片过多，当分配大对象的时候可能无法找到足够大的连续空间进行分配，从而提前触发Full GC）</li></ul><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器，G1 收集器两个最突出的改进是：</p><ol><li>基于标记-整理算法，不产生内存碎片。</li><li>可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。</li></ol><p>G1是一款面向服务端应用的垃圾收集器。</p><ul><li>并行与并发</li><li>分代收集</li><li>空间整合</li><li>可预测的停顿</li></ul><p>G1把堆内存划分为分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但是新生代和老年代不再是物理隔离的了，而是一部分Region(不需要连续)的集合。<br><strong>G1跟踪各个Region里面的垃圾堆积的价值大小</strong>(回收所获得的空间大小以及回收所需时间的经验值)，<strong>在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region</strong>(这也是Garbage-First名称的由来)。这种使用Rrgion划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p><p>G1收集器的运作大致可划分为以下几个步骤：</p><ol><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ol>]]></content>
    
    <summary type="html">
    
      重点了解下CMS、G1收集器
    
    </summary>
    
      <category term="jvm" scheme="http://blog.linzhongtai.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://blog.linzhongtai.cn/tags/jvm/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之JVM：Java引用类型</title>
    <link href="http://blog.linzhongtai.cn/2019/03/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8BJVM%EF%BC%9AJava%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>http://blog.linzhongtai.cn/2019/03/重温系列之JVM：Java引用类型/</id>
    <published>2019-03-27T13:31:32.000Z</published>
    <updated>2019-03-27T13:31:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之一。</p><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。</p><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。</p><h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。</p>]]></content>
    
    <summary type="html">
    
      强软弱虚
    
    </summary>
    
      <category term="jvm" scheme="http://blog.linzhongtai.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://blog.linzhongtai.cn/tags/jvm/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之JVM：垃圾回收与算法</title>
    <link href="http://blog.linzhongtai.cn/2019/03/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8BJVM%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.linzhongtai.cn/2019/03/重温系列之JVM：垃圾回收与算法/</id>
    <published>2019-03-27T13:30:19.000Z</published>
    <updated>2019-03-27T13:30:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/5937589-7184030af256a415.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="如何确定垃圾"><a href="#如何确定垃圾" class="headerlink" title="如何确定垃圾"></a>如何确定垃圾</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>在 Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。<br><strong>每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</strong></p><h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。</p><p>在Java语言中，GC Roots包括：</p><ul><li>虚拟机栈中引用的对象。</li><li>方法区中类静态属性实体引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI引用的对象。</li></ul><p><strong>要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。</strong></p><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。<br>主要缺点有两个：一个是<strong>效率问题，标记和清除过程的效率都不高</strong>；另外一个是<strong>空间问题，标记清除之后会产生大量不连续的内存碎片</strong>，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。<br><img src="http://upload-images.jianshu.io/upload_images/5937589-f7a1f6e35a3a742a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。<br>这种算法虽然<strong>实现简单，内存效率高，不易产生碎片</strong>，但是最大的问题是<strong>可用内存被压缩到了原本的一半</strong>。且存活对象增多的话，Copying 算法的效率会大大降低。<br>[图片上传失败…(image-580a95-1553689761459)]</p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。<br>[图片上传失败…(image-26ac3c-1553689761459)]</p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。<br>“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</p><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><h3 id="内存分配的2种方式："><a href="#内存分配的2种方式：" class="headerlink" title="内存分配的2种方式："></a>内存分配的2种方式：</h3><blockquote><p><strong>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong></p></blockquote><ul><li><strong>指针碰撞</strong><br>Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离</li><li><strong>空闲列表</strong><br>Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录<h3 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h3></li></ul><ol><li>对象优先在Eden区分配<br>大多数情况下，对象在新生代Eden区分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次MinorGC。</li><li>大对象直接进入老年代<br>所谓的大对象，指的是需要大量连续内存空间的Java对象，典型的大对象就是那种很长的字符串或数组。</li><li>长期存活的对象将进入老年代（-XX:MaxTenuringThreshold）<br>当对象在 Survivor 区躲过一次 GC 后，其年龄就会+1。默认情况下年龄到达 15 的对象会被移到老生代中。</li><li>动态年龄判断<br>如果在Survivor空间中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄</li><li>空间分配担保<br>虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次的Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。</li></ol><blockquote><p>Minor GC与Full GC有什么不一样？</p></blockquote><ul><li>新生代GC（MinorGC）：指发生在新生代的垃圾收集动作，因为Java对象大都具备朝生夕灭的特性，所以Minor GC 非常频繁，一般回收速度也比较快；</li><li>老年代GC（Major GC / Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</li></ul>]]></content>
    
    <summary type="html">
    
      新生代-复制算法，老年代-标记-清除/整理算法
    
    </summary>
    
      <category term="jvm" scheme="http://blog.linzhongtai.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://blog.linzhongtai.cn/tags/jvm/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
  </entry>
  
</feed>
