<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林林总总</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.linzhongtai.cn/"/>
  <updated>2019-03-30T12:54:30.000Z</updated>
  <id>http://blog.linzhongtai.cn/</id>
  
  <author>
    <name>Soul</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>重温系列之多线程并发：线程方法</title>
    <link href="http://blog.linzhongtai.cn/2019/03/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95/"/>
    <id>http://blog.linzhongtai.cn/2019/03/重温系列之多线程并发：线程方法/</id>
    <published>2019-03-30T12:54:30.000Z</published>
    <updated>2019-03-30T12:54:30.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/5937589-a786abecc68cf0a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><p>线程调用该方法将启动线程，使之从新建状态进入就绪队列排队，一旦轮到它来享用CPU资源时，就可以脱离创建它的线程独立开始自己的生命周期了。</p><h2 id="run-线程执行"><a href="#run-线程执行" class="headerlink" title="run-线程执行"></a>run-线程执行</h2><p>Thread类的run()方法与Runnable接口中的run()方法的功能和作用相同，都用来定义线程对象被调度之后所执行的操作，都是系统自动调用而用户程序不得引用的方法。</p><h2 id="wait-线程等待"><a href="#wait-线程等待" class="headerlink" title="wait-线程等待"></a>wait-线程等待</h2><p>调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知(notify/notifyAll)或被中断才会返回，需要注意的是调用 wait()方法后，<strong>会释放对象的锁</strong>。因此，wait 方法一般用在同步方法或同步代码块中。</p><h2 id="sleep-线程睡眠"><a href="#sleep-线程睡眠" class="headerlink" title="sleep-线程睡眠"></a>sleep-线程睡眠</h2><p>sleep 导致当前线程休眠，与 wait 方法不同的是 sleep 不会释放当前占有的锁,sleep(long)会导致线程进入 TIMED-WATING 状态，而 wait()方法会导致当前线程进入 WATING 状态</p><h2 id="yield-线程让步"><a href="#yield-线程让步" class="headerlink" title="yield-线程让步"></a>yield-线程让步</h2><p>yield 会使当前线程让出 CPU 执行时间片，与其他线程一起重新竞争 CPU 时间片。一般情况下，优先级高的线程有更大的可能性成功竞争得到 CPU 时间片，但这又不是绝对的，有的操作系统对线程优先级并不敏感</p><h2 id="interrupt-线程中断"><a href="#interrupt-线程中断" class="headerlink" title="interrupt-线程中断"></a>interrupt-线程中断</h2><p>中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位。这个线程本身并不会因此而改变状态(如阻塞，终止等)</p><ol><li>调用 interrupt()方法并不会中断一个正在运行的线程。也就是说处于 Running 状态的线程并不会因为被中断而被终止，仅仅改变了内部维护的中断标识位而已</li><li>若调用 sleep()而使线程处于 TIMED-WATING 状态，这时调用interrupt()方法，会抛出InterruptedException,从而使线程提前结束 TIMED-WATING 状态。</li><li>许多声明抛出 InterruptedException 的方法(如Thread.sleep(long mills 方法))，抛出异常前，都会清除中断标识位，所以抛出异常后，调用isInterrupted()方法将会返回 false。</li><li>中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止一个线程thread的时候，可以调用thread.interrupt()方法，在线程的run方法内部可以根据 thread.isInterrupted()的值来优雅的终止线程</li></ol><h2 id="join-等待线程终止"><a href="#join-等待线程终止" class="headerlink" title="join-等待线程终止"></a>join-等待线程终止</h2><blockquote><p>join(0)的意思不是A线程等待B线程0秒，而是A线程等待B线程无限时间，直到B线程执行完毕，即join(0)等价于join();<br>join(10)，则表示A线程会等待B线程执行10毫秒，10毫秒过后，A、B线程并行执行</p></blockquote><p>join() 方法，放弃当前线程的执行，等待其他线程终止，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞状态，等到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu</p><h2 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h2><p>Object 类中的 notify() 方法，<strong>唤醒在此对象监视器上等待的单个线程</strong>，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，<strong>选择是任意的</strong>，并在对实现做出决定时发生，线程通过调用其中一个 wait() 方法，在对象的监视器上等待，<strong>直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程</strong>，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。类似的方法还有 notifyAll() ，唤醒再次监视器上等待的所有线程</p><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><ol><li>sleep()：强迫一个线程睡眠Ｎ毫秒。</li><li>isAlive()： 判断一个线程是否存活。</li><li>join()： 等待线程终止。</li><li>activeCount()： 程序中活跃的线程数。</li><li>enumerate()： 枚举程序中的线程。</li><li>currentThread()： 得到当前线程。</li><li>isDaemon()： 一个线程是否为守护线程。</li><li>setDaemon()： 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束)</li><li>setName()： 为线程设置一个名称。</li><li>wait()： 强迫一个线程等待。</li><li>notify()： 通知一个线程继续运行。</li><li>setPriority()： 设置一个线程的优先级。</li><li>getPriority():    获得一个线程的优先级</li></ol>]]></content>
    
    <summary type="html">
    
      start/wait/sleep/notify...
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之多线程并发：线程生命周期</title>
    <link href="http://blog.linzhongtai.cn/2019/03/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://blog.linzhongtai.cn/2019/03/重温系列之多线程并发：线程生命周期/</id>
    <published>2019-03-30T12:52:30.000Z</published>
    <updated>2019-03-30T12:52:30.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。<br>在线程的生命周期中，它要经过<strong>新建(New)、就绪(Runnable)、运行(Running)、阻塞(Blocked)和死亡(Dead)</strong>这5 种状态。尤其是当线程启动以后，它不可能一直”霸占”着 CPU 独自运行，所以 CPU 需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换。<br><img src="http://upload-images.jianshu.io/upload_images/5937589-7feb259b7240994e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="新建状态NEW"><a href="#新建状态NEW" class="headerlink" title="新建状态NEW"></a>新建状态NEW</h2><p>当程序<strong>使用 new 关键字创建了一个线程之后</strong>，该线程就处于新建状态，此时仅由 JVM 为其分配内存，并初始化其成员变量的值</p><h2 id="就绪状态-RUNNABLE"><a href="#就绪状态-RUNNABLE" class="headerlink" title="就绪状态(RUNNABLE )"></a>就绪状态(RUNNABLE )</h2><p>当线程对象<strong>调用了 start()方法之后</strong>，该线程处于就绪状态。Java 虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。</p><h2 id="运行状态-RUNNING"><a href="#运行状态-RUNNING" class="headerlink" title="运行状态(RUNNING)"></a>运行状态(RUNNING)</h2><p>如果<strong>处于就绪状态的线程获得了 CPU，开始执行 run()方法的线程执行体</strong>，则该线程处于运行状态。</p><h2 id="阻塞状态-BLOCKED"><a href="#阻塞状态-BLOCKED" class="headerlink" title="阻塞状态(BLOCKED)"></a>阻塞状态(BLOCKED)</h2><blockquote><p>阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice，暂时停止运行。直到线程进入可运行/就绪(runnable)状态，才有机会再次获得 cpu timeslice 转到运行(running)状态。</p></blockquote><p>阻塞的情况分三种：</p><ul><li><strong>等待阻塞</strong>( o.wait-&gt; 等待对列)：运行(running)的线程执行 o.wait()方法，JVM 会把该线程放入等待队列(waitting queue)中</li><li><strong>同步阻塞</strong> (lock-&gt; 锁池)：运行(running)的线程在获取对象的同步锁时，若该<strong>同步锁被别的线程占用</strong>，则 JVM 会把该线程放入锁池(lock pool)中</li><li><strong>其他阻塞</strong> (sleep/join)：运行(running)的线程执行 Thread.sleep(long ms)或 t.join()方法，或者发出了 I/O 请求时，JVM 会把该线程置为阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O处理完毕时，线程重新转入可运行(runnable)状态。</li></ul><h2 id="线程死亡-DEAD"><a href="#线程死亡-DEAD" class="headerlink" title="线程死亡(DEAD)"></a>线程死亡(DEAD)</h2><p>线程会以下面三种方式结束，结束后就是死亡状态。</p><ol><li>正常结束<br>run()或 call()方法执行完成，线程正常结束</li><li>异常结束<br>线程抛出一个未捕获的 Exception 或 Error</li><li>调用stop-已废弃<br>直接调用该线程的 stop()方法来结束该线程(该方法通常容易导致死锁，不推荐使用)<h3 id="终止线程四种方式"><a href="#终止线程四种方式" class="headerlink" title="终止线程四种方式"></a>终止线程四种方式</h3></li><li>正常运行结束</li><li><p>使用退出标志退出线程<br>一般 run()方法执行完，线程就会正常结束，但是有些线程需要长时间的<br>运行，只有在外部某些条件满足的情况下，才能关闭这些线程。使用一个变量来控制循环，例如：最直接的方法就是设一个boolean 类型的标志，并通过设置这个标志为 true或 false 来控制 while循环是否退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadSafe extends Thread &#123;</span><br><span class="line">  public volatile boolean exit = false;// volatile保证数据可见性，使得exit值同步</span><br><span class="line">  public void run() &#123;</span><br><span class="line">    while (!exit)&#123;</span><br><span class="line">      //do something</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Interrupt  方法结束线程<br>使用 interrupt()方法来中断线程有两种情况：</p></li></ol><ul><li>线程处于阻塞状态</li></ul><p>如使用了 sleep/同步锁的 wait/socket 中的 receiver,accept 等方法时，会使线程处于阻塞状态。当调用线程的 interrupt()方法时，会抛出InterruptException 异常。<br><strong>通常很多人认为只要调用 interrupt 方法线程就会结束，实际上是错的， 一定要先捕获 InterruptedException 异常之后通过 break 来跳出循环，才能正常结束 run 方法</strong></p><ul><li>线程未处于阻塞状态</li></ul><p>使用 isInterrupted()判断线程的中断标志来退出循环。当使用<br>interrupt()方法时，中断标志就会置 true，和使用自定义的标志来控制循环是一样的道理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadSafe extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">      while (!isInterrupted())&#123; //非阻塞过程中通过判断中断标志来退出</span><br><span class="line">        try&#123;</span><br><span class="line">          Thread.sleep(5*1000);//阻塞过程捕获中断异常来退出</span><br><span class="line">        &#125;catch(InterruptedException e)&#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">          break;//捕获到异常之后，执行 break 跳出循环</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>stop 方法终止线程（线程不安全，已废弃）</li></ol><blockquote><p>thread.stop()调用之后，创建子线程的线程就会抛出 ThreadDeatherror 的错误，并且会释放子线程所持有的所有锁。</p></blockquote><p>一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在<strong>调用<br>thread.stop()后导致了该线程所持有的所有锁的突然释放(不可控制)</strong>，那么被保护数据就有可能呈现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因此，并不推荐使用 stop 方法来终止线程。</p>]]></content>
    
    <summary type="html">
    
      NEW-RUNNING-BLOCKED-DEAD
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>重温系列之多线程并发：Java线程实现/创建方式</title>
    <link href="http://blog.linzhongtai.cn/2019/03/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0-%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/"/>
    <id>http://blog.linzhongtai.cn/2019/03/重温系列之多线程并发：Java线程实现-创建方式/</id>
    <published>2019-03-30T07:13:18.000Z</published>
    <updated>2019-03-30T07:13:18.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h2><blockquote><p>Thread实质上是实现了Runnable接口的一个实例。</p></blockquote><p>启动线程的唯一方法是通过Thread的start()实例方法。start()是一个native方法，将启动新线程，并执行run()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public TestThread extends Thread()&#123;</span><br><span class="line">        public void run()&#123;</span><br><span class="line">                System.out.println(&quot;TestThread run&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">TestThread test = new TestThread();</span><br><span class="line">test.start();</span><br></pre></td></tr></table></figure></p><h2 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h2><ol><li><p>如果此时类已经继承了其他的父类，那么无法直接继承Thread，则可以实现一个Runnable。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends OtherClass implements Runnable &#123;  </span><br><span class="line">　　public void run() &#123;  </span><br><span class="line">　　 System.out.println(&quot;MyThread.run()&quot;);  </span><br><span class="line">　　&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动MyThread，需要首先实例化一个T和read，然后将MyThread作为一个target传入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyThread myThread = new MyThread();  </span><br><span class="line">Thread thread = new Thread(myThread);  </span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure></li><li><p>当传入一个 Runnable target 参数给 Thread 后，Thread 的 run()方法就会调用target.run()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;  </span><br><span class="line">　　if (target != null) &#123;  </span><br><span class="line">　　 target.run();  </span><br><span class="line">　　&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="ExecutorService-、Callable-、Future有返回值线程"><a href="#ExecutorService-、Callable-、Future有返回值线程" class="headerlink" title="ExecutorService 、Callable 、Future有返回值线程"></a>ExecutorService 、Callable<class> 、Future有返回值线程</class></h2><blockquote><p>有返回值的任务必须继承Callable，无返回值的任务必须继承Runnable</p></blockquote><p>执行Callable任务后，可以获取一个 Future 的对象，在该对象上调用 get 就可以获取到 Callable 任务返回的 Object 了，再结合线程池接口 ExecutorService 就可以实现传说中有返回结果的多线程了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//创建一个线程池</span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(taskSize);</span><br><span class="line">// 创建多个有返回值的任务</span><br><span class="line">List&lt;Future&gt; list = new ArrayList&lt;Future&gt;();</span><br><span class="line">for (int i = 0; i &lt; taskSize; i++) &#123;</span><br><span class="line">    Callable c = new MyCallable(i + &quot; &quot;);</span><br><span class="line">    // 执行任务并获取 Future 对象</span><br><span class="line">    Future f = pool.submit(c);</span><br><span class="line">    list.add(f);</span><br><span class="line">&#125;</span><br><span class="line">// 关闭线程池</span><br><span class="line">pool.shutdown();</span><br><span class="line">// 获取所有并发任务的运行结果</span><br><span class="line">for (Future f : list) &#123;</span><br><span class="line">    // 从 Future 对象上获取任务的返回值，并输出到控制台</span><br><span class="line">    System.out.println(&quot;res：&quot; + f.get().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="基于线程池的方式"><a href="#基于线程池的方式" class="headerlink" title="基于线程池的方式"></a>基于线程池的方式</h2><p>线程和数据库连接这些资源都是非常宝贵的资源。那么每次需要的时候创建，不需要的时候销毁，是非常浪费资源的。那么我们就可以使用缓存的策略，也就是使用线程池。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 创建线程池</span><br><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(10);</span><br><span class="line">while(true) &#123;</span><br><span class="line">  threadPool.execute(new Runnable() &#123; // 提交多个线程任务，并执行</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; is running ..&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4种线程池"><a href="#4种线程池" class="headerlink" title="4种线程池"></a>4种线程池</h3><blockquote><p>Java 里面线程池的顶级接口是 Executor，但是严格意义上讲 Executor 并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是 ExecutorService。</p></blockquote><h4 id="newCachedThreadPool：可缓存线程池"><a href="#newCachedThreadPool：可缓存线程池" class="headerlink" title="newCachedThreadPool：可缓存线程池"></a>newCachedThreadPool：<strong>可缓存线程池</strong></h4><blockquote><p>如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><ul><li>工作线程的创建数量几乎没有限制(数目限制为Interger. MAX_VALUE), 可灵活的往线程池中添加线程。</li><li>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</li><li>在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有可能会造成系统瘫痪。</li></ul></blockquote><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><blockquote><p>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。(可控制线程最大并发数，超出的线程会在队列中等待)</p></blockquote><p>在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。</p><ul><li>如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。</li><li>如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。</li><li>在某个线程被显式地关闭之前，池中的线程将一直存在。</li></ul><h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h4><blockquote><p>创建一个定长线程池，支持定时及周期性任务执行</p></blockquote><p>*schedule：延迟执行一次</p><ul><li>scheduleAtFixedRate：固定的频率来执行某项计划，它不受计划执行时间的影响</li><li>scheduleWithFixedDelay：无论任务执行多长时间，等执行完了，再延迟指定的时间，受计划执行时间的影响<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledThreadPool= Executors.newScheduledThreadPool(3);</span><br><span class="line">scheduledThreadPool.schedule(newRunnable()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;延迟三秒&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, 3, TimeUnit.SECONDS);</span><br><span class="line">scheduledThreadPool.scheduleAtFixedRate(newRunnable()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;延迟 1 秒后每三秒执行一次（不受计划执行时间的影响）&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;,1,3,TimeUnit.SECONDS);</span><br><span class="line">scheduledThreadPool.scheduleWithFixedDelay(newRunnable()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;延迟 1 秒后每三秒执行一次（受计划执行时间的影响）&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;,1,3,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></li></ul><h4 id="NewSingleThreadExecutor"><a href="#NewSingleThreadExecutor" class="headerlink" title="NewSingleThreadExecutor"></a>NewSingleThreadExecutor</h4><blockquote><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</p></blockquote><p><strong>这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去</strong></p>]]></content>
    
    <summary type="html">
    
      Java线程实现方式以及四种线程池
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之Java集合</title>
    <link href="http://blog.linzhongtai.cn/2019/03/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8BJava%E9%9B%86%E5%90%88/"/>
    <id>http://blog.linzhongtai.cn/2019/03/重温系列之Java集合/</id>
    <published>2019-03-28T07:38:07.000Z</published>
    <updated>2019-03-28T07:38:07.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/5937589-a9744eacd7c5472d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>集合类存放于 Java.util 包中，主要有 3 种：set(集）、list(列表包含 Queue）和 map(映射)。</p><ol><li>Collection：Collection 是集合 List、Set、Queue 的最基本的接口。</li><li>Iterator：迭代器，可以通过迭代器遍历集合中的数据</li><li>Map：是映射表的基础接口<br><img src="http://upload-images.jianshu.io/upload_images/5937589-e6bec3a42c025e9e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li></ol><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><blockquote><p>List里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。</p></blockquote><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li>ArrayList在内存不够时默认是扩展50% + 1个，Vector是默认扩展1倍。</li><li>Vector属于线程安全级别的，但是大多数情况下不使用Vector，因为线程安全需要更大的系统开销。</li><li>一般使用ArrayList和LinkedList比较多，LinkedList不存在get()的操作，不能单个定位，ArrayList是顺序存储结构，LinkedList是链表存储结构</li><li>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针</li><li>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据</li></ul><h3 id="ArrayList（常用、数组实现，对元素快速随机访问）"><a href="#ArrayList（常用、数组实现，对元素快速随机访问）" class="headerlink" title="ArrayList（常用、数组实现，对元素快速随机访问）"></a>ArrayList（常用、数组实现，对元素快速随机访问）</h3><p>ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除</p><h3 id="Vector（数组实现、线程同步、需高花费）"><a href="#Vector（数组实现、线程同步、需高花费）" class="headerlink" title="Vector（数组实现、线程同步、需高花费）"></a>Vector（数组实现、线程同步、需高花费）</h3><p>Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢</p><h3 id="LinkedList（链表结构、Queue）"><a href="#LinkedList（链表结构、Queue）" class="headerlink" title="LinkedList（链表结构、Queue）"></a>LinkedList（链表结构、Queue）</h3><p>LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用</p><blockquote><p>ArrayList和LinkedList在用法上没有区别，但是在功能上还是有区别的。LinkedList经常用在增删操作较多而查询操作很少的情况下，ArrayList则相反</p></blockquote><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><blockquote><p>Set集合不允许出现重复数据<br>允许包含值为null的元素，但最多只能有一个null元素。</p></blockquote><p>Set 注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号）判断的，如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方法。</p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><ul><li>HashSet中不能有重复的元素</li><li>HashSet是无序的</li><li>HashSet也是基于HashMap实现</li></ul><p>哈希表边存放的是哈希值。HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals 方法 如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。</p><blockquote><p>HashSet 通过 hashCode 值来确定元素在内存中的位置。一个 hashCode 位置上可以存放多个元素。</p></blockquote><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><ul><li>TreeSet中不能有重复的元素；</li><li>TreeSet具有排序功能，缺省是按照自然排序进行排列</li><li>TreeSet中的元素必须实现Comparable接口并重写compareTo()方法，TreeSet判断元素是否重复 、以及确定元素的顺序靠的都是这个方法</li><li>基于TreeMap实现</li></ul><ol><li>TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。</li><li>Integer 和 String 对象都可以进行默认的 TreeSet 排序，而<strong>自定义类的对象是不可以的，自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数</strong>，才可以正常使用。</li><li>在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序</li><li>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。</li></ol><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><blockquote><p>Map集合中存储的是键值对，键不能重复，值可以重复。根据键得到值，对map集合遍历时先得到键的set集合，对set集合进行遍历，得到相应的值</p></blockquote><p>Map遍历：KeySet()、entrySet()<br>keySet其实是遍历了2次，一次是转为iterator，一次就是从HashMap中取出key所对于的value。而entryset只是遍历了第一次，它把key和value都放到了entry中，所以<strong>entrySet效率较高</strong></p><h3 id="HashMap-数组-链表-红黑树"><a href="#HashMap-数组-链表-红黑树" class="headerlink" title="HashMap(数组+ 链表+ 红黑树)"></a>HashMap(数组+ 链表+ 红黑树)</h3><p>HashMap是最常用的Map，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。因为键对象不可以重复，所以HashMap最多只允许一条记录的键为Null，允许多条记录的值为Null，是非同步的</p><ul><li>HashMap是无序的散列映射表；</li><li>HashMap通过Hash 算法来决定存储位置</li><li>底层实现是哈希表<h4 id="java7实现"><a href="#java7实现" class="headerlink" title="java7实现"></a>java7实现</h4><img src="http://upload-images.jianshu.io/upload_images/5937589-a994b71010fe6416.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。</li></ul><ol><li>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。</li><li>loadFactor：负载因子，默认为 0.75。</li><li>threshold：扩容的阈值，等于 capacity * loadFactor<h4 id="java8实现"><a href="#java8实现" class="headerlink" title="java8实现"></a>java8实现</h4><blockquote><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。</p></blockquote></li></ol><p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，<strong>需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)</strong>。为了降低这部分的开销，在 Java8 中，<strong>当链表中的元素超过了 8 个以后，会将链表转换为红黑树</strong>，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。<br><img src="http://upload-images.jianshu.io/upload_images/5937589-3e29e0cf98e2070f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="ConcurrentHashMap（线程安全）"><a href="#ConcurrentHashMap（线程安全）" class="headerlink" title="ConcurrentHashMap（线程安全）"></a>ConcurrentHashMap（线程安全）</h3><ul><li>JDK1.7分析：ConcurrentHashMap采用 分段锁的机制，实现并发的更新操作，底层采用数组+链表的存储结构<br><img src="http://upload-images.jianshu.io/upload_images/5937589-46911a5688705fd6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li><li>JDK1.8分析：1.8的实现已经抛弃了Segment分段锁机制，利用CAS+Synchronized来保证并发更新的安全，底层采用数组+链表+红黑树的存储结构<br><img src="http://upload-images.jianshu.io/upload_images/5937589-3bbf539fb495d071.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li><li>CAS的思想：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。</li></ul><h4 id="Segment-段"><a href="#Segment-段" class="headerlink" title="Segment 段"></a>Segment 段</h4><p>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。</p><h4 id="线程安全（Segment-继承-ReentrantLock-加锁）"><a href="#线程安全（Segment-继承-ReentrantLock-加锁）" class="headerlink" title="线程安全（Segment  继承 ReentrantLock 加锁）"></a>线程安全（Segment  继承 ReentrantLock 加锁）</h4><p>ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。 </p><h4 id="并行度（默认-16-）"><a href="#并行度（默认-16-）" class="headerlink" title="并行度（默认 16 ）"></a>并行度（默认 16 ）</h4><p>concurrencyLevel：并行级别、并发数、Segment 数。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。</p><h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>Hashtable与HashMap类似，是HashMap的线程安全版，它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢，它继承自Dictionary类，不同的是它不允许记录的键或者值为null，同时效率较低</p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序（自然顺序），也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。不允许key值为空，非同步的</p><ul><li>适用于按自然顺序或自定义顺序遍历键(key)。</li><li>底层是二叉树</li><li>提供compareTo，可以定义排序方法</li></ul><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>LinkedHashMap保存了记录的插入顺序，在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢，有HashMap的全部特性。</p><h2 id="主要实现类区别"><a href="#主要实现类区别" class="headerlink" title="主要实现类区别"></a>主要实现类区别</h2><h3 id="Vector-VS-ArrayList"><a href="#Vector-VS-ArrayList" class="headerlink" title="Vector VS ArrayList"></a>Vector VS ArrayList</h3><ul><li>vector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用arraylist效率比较高。</li><li>如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%，而arraylist增长率为目前数组长度的50%。如果在集合中使用数据量比较大的数据，用vector有一定的优势。</li><li>如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，如果频繁的访问数据，这个时候使用vector和arraylist都可以。而如果移动一个指定位置会导致后面的元素都发生移动，这个时候就应该考虑到使用linklist,因为它移动一个指定位置的数据时其它元素不移动。</li><li>ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要涉及到数组元素移动等内存操作，所以索引数据快，插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快</li></ul><h3 id="ArrayList-VS-LinkedList"><a href="#ArrayList-VS-LinkedList" class="headerlink" title="ArrayList VS LinkedList"></a>ArrayList VS LinkedList</h3><ul><li>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</li><li>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</li><li>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据</li></ul><h3 id="HashMap-VS-TreeMap"><a href="#HashMap-VS-TreeMap" class="headerlink" title="HashMap VS TreeMap"></a>HashMap VS TreeMap</h3><ul><li>HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。</li><li>在Map 中插入、删除和定位元素，HashMap是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。<br>两个map中的元素一样，但顺序不一样，导致hashCode()不一样。<br>同样做测试：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在HashMap中，同样的值的map,顺序不同，equals时，false;</span><br><span class="line">而在treeMap中，同样的值的map,顺序不同,equals时，true，</span><br><span class="line">说明treeMap在equals()时是整理了顺序了的</span><br></pre></td></tr></table></figure></li></ul><h3 id="HashTable-VS-HashMap"><a href="#HashTable-VS-HashMap" class="headerlink" title="HashTable VS HashMap"></a>HashTable VS HashMap</h3><ul><li>同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的。</li><li>HashMap允许存在一个为null的key，多个为null的value 。</li><li>hashtable的key和value都不允许为null</li></ul><p>参考：<a href="https://www.cnblogs.com/leeplogs/p/5891861.html" target="_blank" rel="noopener">JAVA集合类汇总</a>、<a href="https://blog.csdn.net/initphp/article/details/8264219" target="_blank" rel="noopener">深入理解Java集合</a></p>]]></content>
    
    <summary type="html">
    
      List/Set/Map
    
    </summary>
    
      <category term="JAVA" scheme="http://blog.linzhongtai.cn/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://blog.linzhongtai.cn/tags/JAVA/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之JVM：类加载机制</title>
    <link href="http://blog.linzhongtai.cn/2019/03/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8BJVM%EF%BC%9A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://blog.linzhongtai.cn/2019/03/重温系列之JVM：类加载机制/</id>
    <published>2019-03-28T04:13:30.000Z</published>
    <updated>2019-03-28T04:13:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class SingletonA&#123;</span><br><span class="line">    private static SingletonA singleton = new SingletonA();</span><br><span class="line">    public static int a;</span><br><span class="line">    public static int b= 0;</span><br><span class="line"></span><br><span class="line">    private SingletonA()&#123;</span><br><span class="line">        a++;</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonA getInstance()&#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SingletonB&#123;</span><br><span class="line">    public static int a;</span><br><span class="line">    public static int b= 0;</span><br><span class="line">    private static SingletonB singleton = new SingletonB();</span><br><span class="line"></span><br><span class="line">    private SingletonB()&#123;</span><br><span class="line">        a++;</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonB getInstance()&#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        SingletonA singleton = SingletonA.getInstance();</span><br><span class="line">        System.out.println(&quot;SingletonA a:&quot; + singleton.a);</span><br><span class="line">        System.out.println(&quot;SingletonA b:&quot; + singleton.b);</span><br><span class="line"></span><br><span class="line">        SingletonB singleton = SingletonB .getInstance();</span><br><span class="line">        System.out.println(&quot;SingletonB a:&quot; + singleton.a);</span><br><span class="line">        System.out.println(&quot;SingletonB b:&quot; + singleton.b);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SingletonA a: 1 </span><br><span class="line">SingletonA b: 0 </span><br><span class="line">SingletonB a: 1 </span><br><span class="line">SingletonB b: 1</span><br></pre></td></tr></table></figure></p><p>SingletonA 解析过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、首先执行main中的SingletonA singleton = SingletonA .getInstance(); </span><br><span class="line">2、类的加载：加载类SingletonA </span><br><span class="line">3、类的验证 </span><br><span class="line">4、类的准备：为静态变量分配内存，设置默认值。这里为singleton(引用类型)设置为null,</span><br><span class="line">a,b（基本数据类型）设置默认值0 </span><br><span class="line">5、类的初始化（按照赋值语句进行修改）： </span><br><span class="line">执行private static SingletonA singleton = new SingletonA(); </span><br><span class="line">执行SingletonA 的构造器：a++;b++; 此时a，b均等于1 </span><br><span class="line">执行 </span><br><span class="line">public static int a; </span><br><span class="line">public static int b= 0; </span><br><span class="line">此时a=1，b=0</span><br></pre></td></tr></table></figure></p><p>SingletonB 解析过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、首先执行main中的SingletonB singleton = SingletonB.getInstance(); </span><br><span class="line">2、类的加载：加载类SingletonB</span><br><span class="line">3、类的验证 </span><br><span class="line">4、类的准备：为静态变量分配内存，设置默认值。这里为a,b（基本数据类型）设置默认值0,</span><br><span class="line">singleton(引用类型)设置为null, </span><br><span class="line">5、类的初始化（按照赋值语句进行修改）： </span><br><span class="line">执行 </span><br><span class="line">public static int value2 = 0; </span><br><span class="line">此时value2=0(value1不变，依然是0); </span><br><span class="line">执行 </span><br><span class="line">private static SingletonB singleton = new SingletonB(); </span><br><span class="line">执行SingletonB的构造器：a++;b++; </span><br><span class="line">此时a，b均等于1,即为最后结果</span><br></pre></td></tr></table></figure></p><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产出是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向我们提供了访问方法区内的数据结构的接口。</p><p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误)如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误</p><p>加载.class文件的方式：</p><ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件</li><li>从zip，jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件</li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="http://upload-images.jianshu.io/upload_images/5937589-11dad6409b7914a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p><ul><li>通过一个类的全限定名来获取其定义的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</li></ul><p>加载方式：</p><ol><li>命令行启动应用时候由JVM初始化加载</li><li>通过Class.forName()方法动态加载</li><li>通过ClassLoader.loadClass()方法动态加载</li></ol><p><strong>Class.forName()和ClassLoader.loadClass()加载的区别：</strong></p><ul><li>Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li><li>ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li><li>Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><blockquote><p>验证：确保被加载的类的正确性</p></blockquote></li></ul><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p><ol><li><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型等等。</li><li><strong>元数据验证</strong>：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外、这个类的父类是否继承了不允许被继承的类等等。</li><li><strong>字节码验证</strong>：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li><strong>符号引用验证</strong>：确保解析动作能正确执行，如果无法通过符号引用验证，那么将会抛出一个java.lang.IncompatibleClassChangeError异常的子类…</li></ol><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><blockquote><p>正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。</p></blockquote><ol><li>这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</li><li>这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</li></ol><p>假设一个类变量的定义为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static int value = 520；</span><br></pre></td></tr></table></figure><p>那么变量value在准备阶段过后的初始值为0，而不是520，因为这时候尚未开始执行任何Java方法，而把value赋值为520的public static指令是在程序编译后，存放于类构造器<clinit>()方法之中的，所以把value赋值为520的动作将在初始化阶段才会执行。</clinit></p><ol start="3"><li>如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。</li></ol><p>假设上面的类变量value被定义为：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final int value = 524；</span><br></pre></td></tr></table></figure><p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为524。可以理解为static final常量在编译期就将其结果放入了常量池中。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><blockquote><p>虚拟机将常量池内的符号引用替换成直接引用的过程。<br>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p></blockquote><p><strong>符号引用</strong>：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时可以无歧义的定位到目标即可。<br><strong>直接引用</strong>：可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p><ol><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值</li></ol><p>JVM初始化步骤：</p><ol><li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ol><p>虚拟机规范严格规定了有且只有5中情况（jdk1.7）必须对类进行“初始化”（加载、验证、准备自然需要在此之前开始）：</p><ul><li>遇到new、getstatic、putstatic、invokestatic这四条字节码指令时，如果类还没有进行过初始化，则需要先触发其初始化。生成这四条指令最常见的Java场景是：使用new关键字实例化对象时、读取或设置一个类的静态字段（static）时（被static修饰又被final修饰的，已在编译期把结果放入常量池的静态字段除外）、以及调用一个类的静态方法时。</li><li>使用Java.lang.refect包的方法对类进行反射调用时(比如：Class.forName(“com.lzt.Test”))，如果类还没有进行过初始化，则需要先触发其初始化。</li><li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先执行该主类。</li><li><p>当使用jdk1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。</p><p>虚拟机规定只有这五种情况才会触发类的初始化，称为对一个类进行主动引用，除此之外所有引用类的方式都不会触发其初始化，称为被动引用。下面举一些例子来说明被动引用。</p></li></ul><ol><li><strong>通过子类引用父类中的静态字段，这时对子类的引用为被动引用，因此不会初始化子类，只会初始化父类</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Father&#123;</span><br><span class="line">public static int f= 66;</span><br><span class="line">static&#123;</span><br><span class="line">System.out.println(&quot;父类初始化&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Child extends Father&#123;</span><br><span class="line">static&#123;</span><br><span class="line">System.out.println(&quot;子类初始化&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class StaticTest&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">System.out.println(Child.f);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>输出的结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类初始化</span><br><span class="line">66</span><br></pre></td></tr></table></figure></p><blockquote><p>对于静态字段，只有直接定义这个字段的类才会被初始化，因此，通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p></blockquote><ol start="2"><li><strong>常量在编译阶段会存入调用它的类的常量池中，本质上没有直接引用到定义该常量的类，因此不会触发定义常量的类的初始化</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Contant&#123;</span><br><span class="line">public static final String NAME = &quot;常量哦哦哦&quot;;</span><br><span class="line">static&#123;</span><br><span class="line">System.out.println(&quot;初始化Contant类&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">System.out.println(Contant.NAME);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>执行后输出的结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">常量哦哦哦</span><br></pre></td></tr></table></figure></p><p>虽然程序中引用了Contant类的常量NAME，但是在编译阶段将此常量的值“我是常量”存储到了调用它的类Test的常量池中，对常量Contant.NAME的引用实际上转化为了Test类对自身常量池的引用。也就是说，实际上Test的Class文件之中并没有Contant类的符号引用入口，这两个类在编译成Class文件后就不存在任何联系了。</p><ol start="3"><li><strong>通过数组定义来引用类，不会触发类的初始化</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Contant&#123;</span><br><span class="line">static&#123;</span><br><span class="line">System.out.println(&quot;初始化Contant&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class ArrayTest&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Contant[] contant= new Contant[6];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>执行后没有输出任何信息，因此Contant类并没有被初始化。</strong><br>  但这段代码里触发了另一个类的初始化，它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类，创建动作由字节码指令newarray触发，很明显，这是一个对数组引用类型的初初始化，而该数组中的元素仅仅包含一个对Contant类的引用，并没有对其进行初始化。如果我们加入对contant数组中各个Contant类元素的实例化代码，便会触发Contant类的初始化，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Contant&#123;</span><br><span class="line">static&#123;</span><br><span class="line">System.out.println(&quot;初始化Contant类&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class ArrayTest&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Contant[] contant= new Contant[6];</span><br><span class="line">for(Contant con:contant)</span><br><span class="line">con = new Contant();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样便会得到如下输出结果：(这里的new触发了Contant类)<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初始化Const类</span><br></pre></td></tr></table></figure></p><p>接口的初始化过程与类初始化过程的不同：<br>接口也有初始化过程，上面的代码中我们都是用静态语句块来输出初始化信息的，而在接口中不能使用“static{}”语句块，但编译器仍然会为接口生成<clinit>类构造器，用于初始化接口中定义的成员变量（实际上是static final修饰的全局常量）。</clinit></p><p><strong>二者在初始化时最主要的区别是</strong>：当一个类在初始化时，要求其父类全部已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量），才会初始化该父接口。这点也与类初始化的情况很不同，回过头来看第2个例子就知道，调用类中的static final常量时并不会 触发该类的初始化，但是调用接口中的static final常量时便会触发该接口的初始化。</p><h2 id="结束生命周期"><a href="#结束生命周期" class="headerlink" title="结束生命周期"></a>结束生命周期</h2><p>在如下几种情况下，Java虚拟机将结束生命周期</p><ul><li>执行了System.exit()方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p><img src="http://upload-images.jianshu.io/upload_images/5937589-4a6d99fb5f2d66d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><blockquote><p>父类加载器并不是通过继承关系来实现的，而是采用组合实现的。</p></blockquote><p>类加载器可以大致划分为以下三类：</p><ul><li>启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。</li><li>扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。</li><li>应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul><p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p><ol><li>在执行非置信代码之前，自动验证数字签名。</li><li>动态地创建符合用户特定需要的定制化构建类。</li><li>从特定的场所取得java class，例如数据库中和网络中。</li></ol><p>类加载机制：</p><ul><li><strong>全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li><li><strong>父类委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li><li><strong>缓存机制</strong>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li></ul><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><p><strong>双亲委派机制:</strong></p><ol><li>当<strong>AppClassLoader</strong>加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<strong>ExtClassLoader</strong>去完成。</li><li>当<strong>ExtClassLoader</strong>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给<strong>BootStrapClassLoader</strong>去完成。</li><li>如果<strong>BootStrapClassLoader</strong>加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用<strong>ExtClassLoader</strong>来尝试加载；</li><li>若<strong>ExtClassLoader</strong>也加载失败，则会使用<strong>AppClassLoader</strong>来加载，如果<strong>AppClassLoader</strong>也加载失败，则会报出异常ClassNotFoundException。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public Class&lt;?&gt; loadClass(String name)throws ClassNotFoundException &#123;</span><br><span class="line">        return loadClass(name, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve)throws ClassNotFoundException &#123;</span><br><span class="line">        // 首先判断该类型是否已经被加载</span><br><span class="line">        Class c = findLoadedClass(name);</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            //如果没有被加载，就委托给父类加载或者委派给启动类加载器加载</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent != null) &#123;</span><br><span class="line">                     //如果存在父类加载器，就委派给父类加载器加载</span><br><span class="line">                    c = parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                //如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)</span><br><span class="line">                    c = findBootstrapClass0(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">             // 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能</span><br><span class="line">                c = findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>双亲委派模型意义：</p><ul><li>系统类防止内存中出现多份同样的字节码</li><li>保证Java程序安全稳定运行</li></ul><h2 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h2><p>双亲委派模型很好的解决了各个类加载器加载基础类的统一性问题。即越基础的类由越上层的加载器进行加载。 若加载的基础类中需要回调用户代码，而这时顶层的类加载器无法识别这些用户代码，怎么办呢？这时就需要破坏双亲委派模型了。<br>下面介绍两个例子来讲解破坏双亲委派模型的过程：</p><ol><li>JNDI破坏双亲委派模型<br>JNDI是Java标准服务，它的代码由启动类加载器去加载。但是JNDI需要回调独立厂商实现的代码，而类加载器无法识别这些回调代码（SPI）。<br>为了解决这个问题，引入了一个线程上下文类加载器。 可通过Thread.setContextClassLoader()设置。 利用线程上下文类加载器去加载所需要的SPI代码，即父类加载器请求子类加载器去完成类加载的过程，而破坏了双亲委派模型。</li><li>Spring破坏双亲委派模型 <blockquote><p>Spring要对用户程序进行组织和管理，而用户程序一般放在WEB-INF目录下，由WebAppClassLoader类加载器加载，而Spring由Common类加载器或Shared类加载器加载。</p></blockquote></li></ol><p>问：<strong>Spring是如何访问WEB-INF下的用户程序呢？</strong><br>答：<strong>使用线程上下文类加载器</strong>。 Spring加载类所用的classLoader都是通过Thread.currentThread().getContextClassLoader()获取的。当线程创建时会默认创建一个AppClassLoader类加载器（对应Tomcat中的WebAppclassLoader类加载器）： setContextClassLoader(AppClassLoader)。<br>利用这个来加载用户程序。即任何一个线程都可通过getContextClassLoader()获取到WebAppclassLoader。</p>]]></content>
    
    <summary type="html">
    
      加载-连接(验证-准备-解析)-初始化-使用-卸载
    
    </summary>
    
      <category term="jvm" scheme="http://blog.linzhongtai.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://blog.linzhongtai.cn/tags/jvm/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之JVM：GC垃圾收集器</title>
    <link href="http://blog.linzhongtai.cn/2019/03/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8BJVM%EF%BC%9AGC%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://blog.linzhongtai.cn/2019/03/重温系列之JVM：GC垃圾收集器/</id>
    <published>2019-03-27T13:32:37.000Z</published>
    <updated>2019-03-27T13:32:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java 堆内存被划分为新生代和年老代两部分，新生代主要使用复制算法 ；年老代主要使用标记-整理和标记-清除垃圾回收算法，因此 java 虚拟中针对新生代和年老代分别提供了多种不同的垃圾收集器，JDK1.6 中 Sun HotSpot 虚拟机的垃圾收集器如下：<br><img src="http://upload-images.jianshu.io/upload_images/5937589-12919617c472286d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="Serial-收集器（单线程、-复制算法）"><a href="#Serial-收集器（单线程、-复制算法）" class="headerlink" title="Serial 收集器（单线程、 复制算法）"></a>Serial 收集器（单线程、 复制算法）</h2><p><strong>Serial是最基本垃圾收集器，使用复制算法。</strong><br>Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此 <strong>Serial垃圾收集器依然是 java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器</strong></p><h2 id="ParNew-收集器（Serial-多线程-多线程）"><a href="#ParNew-收集器（Serial-多线程-多线程）" class="headerlink" title="ParNew 收集器（Serial+多线程 多线程）"></a>ParNew 收集器（Serial+多线程 多线程）</h2><p>ParNew 垃圾收集器其实<strong>是 Serial 收集器的多线程版本</strong>，也使用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和 Serial 收集器完全一样，ParNew 垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。<br>ParNew 收集器默认开启和 CPU 数目相同的线程数，可通过-XX:ParallelGCThreads参数来限制垃圾收集器的线程数<br>ParNew虽然是除了多线程外和Serial收集器几乎完全一样，但是<strong>ParNew垃圾收集器是很多java虚拟机运行在 Server 模式下新生代的默认垃圾收集器</strong></p><h2 id="Parallel-Scavenge-收集器（多线程复制算法、高效）"><a href="#Parallel-Scavenge-收集器（多线程复制算法、高效）" class="headerlink" title="Parallel Scavenge 收集器（多线程复制算法、高效）"></a>Parallel Scavenge 收集器（多线程复制算法、高效）</h2><p>Parallel Scavenge 收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃圾收集器，它<strong>重点关注的是程序达到一个可控制的吞吐量</strong>（Thoughput，CPU 用于运行用户代码的时间/CPU 总消耗时间，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)），高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。<br><strong>自适应调节策略也是ParallelScavenge 收集器与 ParNew 收集器的一个重要区别。</strong></p><h2 id="Serial-Old-收集器（单线程标记整理算法）"><a href="#Serial-Old-收集器（单线程标记整理算法）" class="headerlink" title="Serial Old 收集器（单线程标记整理算法）"></a>Serial Old 收集器（单线程标记整理算法）</h2><p>Serial Old 是 Serial 垃圾收集器年老代版本，它同样是个单线程的收集器，使用标记-整理算法，这个收集器也<strong>主要是运行在 Client 默认的 java 虚拟机默认的年老代垃圾收集器。</strong></p><h2 id="Parallel-Old-收集器（多线程标记整理算法）"><a href="#Parallel-Old-收集器（多线程标记整理算法）" class="headerlink" title="Parallel Old 收集器（多线程标记整理算法）"></a>Parallel Old 收集器（多线程标记整理算法）</h2><p>Parallel Old收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在JDK1.6才开始提供。<br>在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量，<strong>Parallel Old 正是为了在年老代同样提供吞吐量优先的垃圾收集器</strong>，如果系统对吞吐量要求比较高，可以优先考虑新生代 Parallel Scavenge和年老代 Parallel Old 收集器的搭配策略。</p><h2 id="CMS-收集器（多线程标记清除算法）"><a href="#CMS-收集器（多线程标记清除算法）" class="headerlink" title="CMS 收集器（多线程标记清除算法）"></a>CMS 收集器（多线程标记清除算法）</h2><blockquote><p><strong>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。是基于多线程的“标记-清除”算法。</strong></p></blockquote><ol><li>初始标记（Stop The World）<br>只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。</li><li>并发标记（Stop The World）<br>进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。</li><li>重新标记<br>为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。</li><li>并发清除<br>清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看<strong>CMS 收集器的内存回收和用户线程是一起并发地执行。</strong></li></ol><p>CMS 收集器工作过程：<br><img src="http://upload-images.jianshu.io/upload_images/5937589-6f5c41a61b10b6f2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>优点：</p><ul><li>并发收集</li><li>低停顿</li></ul><p>缺点：</p><ul><li>对CPU资源非常敏感</li><li>无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次的Full GC的产生。</li><li>使用“标记-清除”算法会导致大量内存空间碎片（碎片过多，当分配大对象的时候可能无法找到足够大的连续空间进行分配，从而提前触发Full GC）</li></ul><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器，G1 收集器两个最突出的改进是：</p><ol><li>基于标记-整理算法，不产生内存碎片。</li><li>可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。</li></ol><p>G1是一款面向服务端应用的垃圾收集器。</p><ul><li>并行与并发</li><li>分代收集</li><li>空间整合</li><li>可预测的停顿</li></ul><p>G1把堆内存划分为分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但是新生代和老年代不再是物理隔离的了，而是一部分Region(不需要连续)的集合。<br><strong>G1跟踪各个Region里面的垃圾堆积的价值大小</strong>(回收所获得的空间大小以及回收所需时间的经验值)，<strong>在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region</strong>(这也是Garbage-First名称的由来)。这种使用Rrgion划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p><p>G1收集器的运作大致可划分为以下几个步骤：</p><ol><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ol>]]></content>
    
    <summary type="html">
    
      重点了解下CMS、G1收集器
    
    </summary>
    
      <category term="jvm" scheme="http://blog.linzhongtai.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://blog.linzhongtai.cn/tags/jvm/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之JVM：Java引用类型</title>
    <link href="http://blog.linzhongtai.cn/2019/03/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8BJVM%EF%BC%9AJava%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>http://blog.linzhongtai.cn/2019/03/重温系列之JVM：Java引用类型/</id>
    <published>2019-03-27T13:31:32.000Z</published>
    <updated>2019-03-27T13:31:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之一。</p><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。</p><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。</p><h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。</p>]]></content>
    
    <summary type="html">
    
      强软弱虚
    
    </summary>
    
      <category term="jvm" scheme="http://blog.linzhongtai.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://blog.linzhongtai.cn/tags/jvm/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之JVM：垃圾回收与算法</title>
    <link href="http://blog.linzhongtai.cn/2019/03/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8BJVM%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.linzhongtai.cn/2019/03/重温系列之JVM：垃圾回收与算法/</id>
    <published>2019-03-27T13:30:19.000Z</published>
    <updated>2019-03-27T13:30:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/5937589-7184030af256a415.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="如何确定垃圾"><a href="#如何确定垃圾" class="headerlink" title="如何确定垃圾"></a>如何确定垃圾</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>在 Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。<br><strong>每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</strong></p><h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。</p><p>在Java语言中，GC Roots包括：</p><ul><li>虚拟机栈中引用的对象。</li><li>方法区中类静态属性实体引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI引用的对象。</li></ul><p><strong>要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。</strong></p><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。<br>主要缺点有两个：一个是<strong>效率问题，标记和清除过程的效率都不高</strong>；另外一个是<strong>空间问题，标记清除之后会产生大量不连续的内存碎片</strong>，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。<br><img src="http://upload-images.jianshu.io/upload_images/5937589-f7a1f6e35a3a742a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。<br>这种算法虽然<strong>实现简单，内存效率高，不易产生碎片</strong>，但是最大的问题是<strong>可用内存被压缩到了原本的一半</strong>。且存活对象增多的话，Copying 算法的效率会大大降低。<br>[图片上传失败…(image-580a95-1553689761459)]</p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。<br>[图片上传失败…(image-26ac3c-1553689761459)]</p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。<br>“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</p><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><h3 id="内存分配的2种方式："><a href="#内存分配的2种方式：" class="headerlink" title="内存分配的2种方式："></a>内存分配的2种方式：</h3><blockquote><p><strong>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong></p></blockquote><ul><li><strong>指针碰撞</strong><br>Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离</li><li><strong>空闲列表</strong><br>Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录<h3 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h3></li></ul><ol><li>对象优先在Eden区分配<br>大多数情况下，对象在新生代Eden区分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次MinorGC。</li><li>大对象直接进入老年代<br>所谓的大对象，指的是需要大量连续内存空间的Java对象，典型的大对象就是那种很长的字符串或数组。</li><li>长期存活的对象将进入老年代（-XX:MaxTenuringThreshold）<br>当对象在 Survivor 区躲过一次 GC 后，其年龄就会+1。默认情况下年龄到达 15 的对象会被移到老生代中。</li><li>动态年龄判断<br>如果在Survivor空间中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄</li><li>空间分配担保<br>虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次的Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。</li></ol><blockquote><p>Minor GC与Full GC有什么不一样？</p></blockquote><ul><li>新生代GC（MinorGC）：指发生在新生代的垃圾收集动作，因为Java对象大都具备朝生夕灭的特性，所以Minor GC 非常频繁，一般回收速度也比较快；</li><li>老年代GC（Major GC / Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</li></ul>]]></content>
    
    <summary type="html">
    
      新生代-复制算法，老年代-标记-清除/整理算法
    
    </summary>
    
      <category term="jvm" scheme="http://blog.linzhongtai.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://blog.linzhongtai.cn/tags/jvm/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之JVM：内存区域</title>
    <link href="http://blog.linzhongtai.cn/2019/03/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8BJVM%EF%BC%9A%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>http://blog.linzhongtai.cn/2019/03/重温系列之JVM：内存区域/</id>
    <published>2019-03-27T09:42:53.000Z</published>
    <updated>2019-03-27T09:42:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h1><p><img src="http://blog2019.oss-cn-shenzhen.aliyuncs.com/1553675182%281%29.jpg" alt=""></p><ul><li>线程私有：【程序计数器、虚拟机栈、本地方法栈】</li><li>线程共享：【方法区（永久区）、Java堆】—–线程共享区域随虚拟机的启动/关闭而创建/销毁</li><li>直接内存：直接内存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用: 在 JDK 1.4 引入的 NIO 提供了基于 Channel 与 Buffer 的 IO 方式, 它可以使用 Native 函数库直接分配堆外内存, 然后使用DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展), 这样就避免了在 Java堆和 Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。<blockquote><p>线程私有数据区域生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在 Hotspot VM内， 每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的生/死对应）</p></blockquote></li></ul><p><img src="http://blog2019.oss-cn-shenzhen.aliyuncs.com/1553675939%281%29.jpg" alt=""></p><h2 id="程序计数器-线程私有"><a href="#程序计数器-线程私有" class="headerlink" title="程序计数器( 线程私有)"></a>程序计数器( 线程私有)</h2><p>一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有”的内存。<br>正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如果还是 Native 方法，则为空。<br><strong>这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域。</strong></p><h2 id="虚拟机栈-线程私有"><a href="#虚拟机栈-线程私有" class="headerlink" title="虚拟机栈( 线程私有)"></a>虚拟机栈( 线程私有)</h2><p><strong>虚拟机栈是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</strong><br>每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。<br>栈帧（ Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接(Dynamic Linking)、 方法返回值和异常分派（ Dispatch Exception）。栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。</p><h2 id="本地方法区-线程私有"><a href="#本地方法区-线程私有" class="headerlink" title="本地方法区( 线程私有)"></a>本地方法区( 线程私有)</h2><p>本地方法区和 Java Stack 作用类似, <strong>区别是虚拟机栈为执行 Java 方法服务, 而本地方法栈则为Native 方法服务</strong>, 如果一个 VM 实现使用 C-linkage 模型来支持 Native 调用, 那么该栈将会是一个C 栈，但 HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一。</p><h2 id="堆（Heap-线程共享）-运行时数据区"><a href="#堆（Heap-线程共享）-运行时数据区" class="headerlink" title="堆（Heap- 线程共享）- 运行时数据区"></a>堆（Heap- 线程共享）- 运行时数据区</h2><p>是被线程共享的一块内存区域，<strong>创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。</strong>由于现代 VM 采用分代收集算法, 因此 Java 堆从 GC 的角度还可以细分为: 新生代( Eden 区 、 From Survivor 区 和 To Survivor 区 )和老年代。<br>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><h2 id="方法区-永久代（线程共享）"><a href="#方法区-永久代（线程共享）" class="headerlink" title="方法区/永久代（线程共享）"></a>方法区/永久代（线程共享）</h2><p><strong>永久代(Permanent Generation), 用于存储被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong> HotSpot VM把GC分代收集扩展至方法区, 即使用Java堆的永久代来实现方法区, 这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存,而不必为方法区开发专门的内存管理器(永久带的内存回收的主要目标是针对常量池的回收和类型的卸载, 因此收益一般很小)。</p><p><strong>运行时常量池（Runtime Constant Pool）</strong>是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 Java 虚拟机对 Class 文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。</p><h1 id="JVM运行时内存"><a href="#JVM运行时内存" class="headerlink" title="JVM运行时内存"></a>JVM运行时内存</h1><blockquote><p>Java 堆从 GC 的角度还可以细分为: 新生代( Eden 区 、 From Survivor 区 和 To Survivor 区 )和老年代。</p></blockquote><p><img src="https://blog2019.oss-cn-shenzhen.aliyuncs.com/1553678879%281%29.jpg" alt=""></p><h2 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h2><blockquote><p>是用来存放新生的对象。一般占据堆的1/3空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。新生代又分为 Eden 区、FromSurvivor、ToSurvivor 三个区。</p></blockquote><h3 id="Eden区"><a href="#Eden区" class="headerlink" title="Eden区"></a>Eden区</h3><p>Java新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老<br>年代）。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行<br>一次垃圾回收。</p><h3 id="From-Survivor"><a href="#From-Survivor" class="headerlink" title="From Survivor"></a>From Survivor</h3><p>上一次 GC 的幸存者，作为这一次 GC 的被扫描者。</p><h3 id="To-Survivor"><a href="#To-Survivor" class="headerlink" title="To Survivor"></a>To Survivor</h3><p>保留了一次 MinorGC 过程中的幸存者。</p><h3 id="MinorGC的过程（复制-gt-清空-gt-互换）"><a href="#MinorGC的过程（复制-gt-清空-gt-互换）" class="headerlink" title="MinorGC的过程（复制-&gt;清空-&gt;互换）"></a>MinorGC的过程（复制-&gt;清空-&gt;互换）</h3><p>MinorGC 采用复制算法。</p><ol><li><strong>Eden、FromSurvivor复制到 ToSurvivor，年龄+1</strong><br>首先，把 Eden和 FromSurvivor区域中存活的对象复制到 ToSurvivor区域（如果有对象的年龄以及达到了老年的标准，则复制到老年代区），同时把这些对象的年龄+1（如果 ToSurvivor不够位置了就放到老年区）；</li><li><strong>清空 Eden 、 FromSurvivor</strong><br>然后，清空 Eden 和 FromSurvivor中的对象；</li><li>ToSurvivor和 FromSurvivor互换<br>最后，ToSurvivor和 FromSurvivor互换，原 ToSurvivor成为下一次 GC 时的 FromSurvivor区。</li></ol><h2 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h2><blockquote><p>主要存放应用程序中生命周期长的内存对象。</p></blockquote><p>老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。</p><p><strong>MajorGC 采用标记清除算法</strong>：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC 的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。</p><h2 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h2><p>指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息,Class 在被加载的时候被放入永久区域，它和和存放实例的区域不同,GC 不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。</p><h3 id="JAVA8-与元数据"><a href="#JAVA8-与元数据" class="headerlink" title="JAVA8 与元数据"></a>JAVA8 与元数据</h3><p>在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 nativememory, 字符串池和类的静态变量放入 java 堆中，这样可以加载多少类的元数据就不再由MaxPermSize 控制, 而由系统的实际可用空间来控制。</p>]]></content>
    
    <summary type="html">
    
      回顾学习之旅
    
    </summary>
    
      <category term="jvm" scheme="http://blog.linzhongtai.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://blog.linzhongtai.cn/tags/jvm/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
  </entry>
  
  <entry>
    <title>最近</title>
    <link href="http://blog.linzhongtai.cn/2018/12/%E6%9C%80%E8%BF%91/"/>
    <id>http://blog.linzhongtai.cn/2018/12/最近/</id>
    <published>2018-12-12T06:05:35.000Z</published>
    <updated>2018-12-12T06:05:35.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>做一个有想法的人。</p></blockquote><article><br>    年初的目标还没有完成，却已到了年底啊啊啊啊啊啊啊。<br>    有很多想做想学想去改变的东西，三分钟热度撑不住想法，坚持才行。<br>    五月份，在选择的关卡，其实并没有深入的去了解自己想去想做的事情，很片面，也很幼稚的去做出决定。一段较为纠结的时间段，可能让自己学到的，就是知道了自己不想做什么事情，想做什么。<br>    十一月份是新的开始，也是新的挑战，一个人，能做事，且做好。<br>    世界很大，我想去看看，更想带你去看看。<br>    是随便乱写的哈哈哈，希望明年的自己更Xiang Yang。<br></article>]]></content>
    
    <summary type="html">
    
      2018年
    
    </summary>
    
      <category term="我的" scheme="http://blog.linzhongtai.cn/categories/%E6%88%91%E7%9A%84/"/>
    
    
      <category term="我的" scheme="http://blog.linzhongtai.cn/tags/%E6%88%91%E7%9A%84/"/>
    
  </entry>
  
  <entry>
    <title>缓存与数据库一致性之缓存穿透、缓存雪崩、key重建方案</title>
    <link href="http://blog.linzhongtai.cn/2018/10/%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7%E4%B9%8B%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81key%E9%87%8D%E5%BB%BA%E6%96%B9%E6%A1%88/"/>
    <id>http://blog.linzhongtai.cn/2018/10/缓存与数据库一致性之缓存穿透、缓存雪崩、key重建方案/</id>
    <published>2018-10-24T09:41:34.000Z</published>
    <updated>2018-10-24T09:41:34.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="缓存穿透预防及优化"><a href="#缓存穿透预防及优化" class="headerlink" title="缓存穿透预防及优化"></a>缓存穿透预防及优化</h2><blockquote><p>缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不会命中，但是出于容错的考虑，如果从存储层查不到数据则不写入缓存层</p></blockquote><p>如下图所示整个过程分为如下 3 步：</p><ol><li>缓存层不命中</li><li>存储层不命中，所以不将空结果写回缓存</li><li>返回空结果 </li></ol><p><strong>缓存穿透将导致不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端存储的意义。</strong><br><img src="http://upload-images.jianshu.io/upload_images/5937589-026c3cb02174adc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>缓存穿透问题可能会使后端存储负载加大，由于很多后端存储不具备高并发性，甚至可能造成后端存储宕掉。通常可以在程序中分别统计总调用数、缓存层命中数、存储层命中数，如果发现大量存储层空命中，可能就是出现了缓存穿透问题。<br>造成缓存穿透的基本有两个：<br>    第一，业务自身代码或者数据出现问题<br>    第二，一些恶意攻击、爬虫等造成大量空命中</p><h2 id="缓存穿透的解决方法"><a href="#缓存穿透的解决方法" class="headerlink" title="缓存穿透的解决方法"></a>缓存穿透的解决方法</h2><h3 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h3><p>如下图所示，当第 2 步存储层不命中后，仍然将空对象保留到缓存层中，之后再访问这个数据将会从缓存中获取，保护了后端数据源。<br><img src="http://upload-images.jianshu.io/upload_images/5937589-a569c782dd2f9dfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><strong>缓存空对象会有两个问题：</strong> </p><ol><li>空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间（如果是攻击，问题更严重）比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。 </li><li>缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。<br>例如过期时间设置为 5 分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致，此时可以利用消息系统或者其他方式清除掉缓存层中的空对象。 </li></ol><p><img src="http://upload-images.jianshu.io/upload_images/5937589-7c838cbb036b7a2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="布隆过滤器拦截"><a href="#布隆过滤器拦截" class="headerlink" title="布隆过滤器拦截"></a>布隆过滤器拦截</h3><blockquote><p>这种方法适用于数据命中不高，数据相对固定实时性低（通常是数据集较大）的应用场景，代码维护较为复杂，但是缓存空间占用少。 </p></blockquote><p>如下图所示，在访问缓存层和存储层之前，将存在的 key 用布隆过滤器提前保存起来，做第一层拦截。</p><p>例如： 一个个性化推荐系统有 4 亿个用户 ID，每个小时算法工程师会根据每个用户之前历史行为做出来的个性化放到存储层中，但是最新的用户由于没有历史行为，就会发生缓存穿透的行为，为此可以将所有有个性化推荐数据的用户做成布隆过滤器。如果布隆过滤器认为该用户 ID 不存在，那么就不会访问存储层，在一定程度保护了存储层。 </p><p>有关布隆过滤器的相关知识，可以参考： <a href="http://www.cnblogs.com/duanxz/p/3480254.html" target="_blank" rel="noopener">Bloom Filter(布隆过滤器)的概念和原理</a><br>可以利用 Redis 的 Bitmaps 实现布隆过滤器，GitHub 上已经开源了类似的方案，读者可以进行<a href="https://github.com/erikdubbelboer/Redis-Lua-scaling-bloom-filter" target="_blank" rel="noopener">参考</a><br><img src="http://upload-images.jianshu.io/upload_images/5937589-5d192941526934da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="方案对比"><a href="#方案对比" class="headerlink" title="方案对比"></a>方案对比</h3><table><thead><tr><th style="text-align:center">解决缓存穿透</th><th style="text-align:left">适用场景</th><th style="text-align:left">维护成本</th></tr></thead><tbody><tr><td style="text-align:center">缓存空对象</td><td style="text-align:left">1、数据命中不高 <br> 2、 数据频繁变化实时性高</td><td style="text-align:left">1、代码维护简单<br> 2、需要过多的缓存空间<br> 3、数据不一致</td></tr><tr><td style="text-align:center">布隆过滤器</td><td style="text-align:left">1、数据命中不高 <br> 2、数据相对固定实时性低</td><td style="text-align:left">1、代码维护复杂<br> 2、缓存空间占用少 </td></tr></tbody></table><h2 id="缓存雪崩问题优化"><a href="#缓存雪崩问题优化" class="headerlink" title="缓存雪崩问题优化"></a>缓存雪崩问题优化</h2><p>由于缓存层承载着大量请求，有效的保护了存储层，但是如果缓存层由于某些原因整体不能提供服务，于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。缓存雪崩的英文原意是 stampeding herd（奔逃的野牛），指的是缓存层宕掉后，流量会像奔逃的野牛一样，打向后端存储。<br><img src="http://upload-images.jianshu.io/upload_images/5937589-496de023cbb4fef1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>预防和解决缓存雪崩问题，可以从以下三个方面进行着手:</p><ul><li>保证缓存层服务高可用性<br>如果缓存层设计成高可用的，即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，例如前面介绍过的 Redis Sentinel 和 Redis Cluster 都实现了高可用</li><li>依赖隔离组件为后端限流并降级<br>无论是缓存层还是存储层都会有出错的概率，可以将它们视同为资源。作为并发量较大的系统，假如有一个资源不可用，可能会造成线程全部 hang 在这个资源上，造成整个系统不可用。降级在高并发系统中是非常正常的：比如推荐服务中，如果个性化推荐服务不可用，可以降级补充热点数据，不至于造成前端页面是开天窗。</li></ul><p>在实际项目中，我们需要对重要的资源 ( 例如 Redis、 MySQL、 Hbase、外部接口 ) 都进行隔离，让每种资源都单独运行在自己的线程池中，即使个别资源出现了问题，对其他服务没有影响。但是线程池如何管理，比如如何关闭资源池，开启资源池，资源池阀值管理，这些做起来还是相当复杂的，这里推荐一个 Java 依赖隔离工具 Hystrix</p><ul><li>提前演练<br>在项目上线前，演练缓存层宕掉后，应用以及后端的负载情况以及可能出现的问题，在此基础上做一些预案设定</li></ul><h2 id="缓存热点key重建优化"><a href="#缓存热点key重建优化" class="headerlink" title="缓存热点key重建优化"></a>缓存热点key重建优化</h2><p>使用缓存 + 过期时间的策略既可以加速数据读写，又保证数据的定期更新，这种模式基本能够满足绝大部分需求。但是有两个问题如果同时出现，可能就会对应用造成致命的危害：</p><ol><li>当前 key 是一个热点 key( 例如一个热门的娱乐新闻），并发量非常大。</li><li>重建缓存不能在短时间完成，可能是一个复杂计算，例如复杂的 SQL、多次 IO、多个依赖等。</li></ol><p>在缓存失效的瞬间，有大量线程来重建缓存 ( 如下图)，造成后端负载加大，甚至可能会让应用崩溃。<br><img src="http://upload-images.jianshu.io/upload_images/5937589-6fa6c98545a45dba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><center>热点key失效后大量线程重建缓存</center><p>要解决这个问题也不是很复杂，但是不能为了解决这个问题给系统带来更多的麻烦，所以需要制定如下目标:</p><ul><li>减少重建缓存的次数</li><li>数据尽可能一致</li><li>较少的潜在危险</li></ul><h3 id="互斥锁-mutex-key"><a href="#互斥锁-mutex-key" class="headerlink" title="互斥锁(mutex key)"></a>互斥锁(mutex key)</h3><p>此方法只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完，重新从缓存获取数据即可，整个过程如图 :<br><img src="http://upload-images.jianshu.io/upload_images/5937589-af803ef33f86623f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>下面代码使用 Redis 的 setnx 命令实现上述功能。<br><img src="http://upload-images.jianshu.io/upload_images/5937589-0fc84d2f1f890f99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><ol><li>从Redis获取数据，如果值不为空，则直接返回值，否则往下执行</li><li>如果 set(nx 和 ex) 结果为 true，说明此时没有其他线程重建缓存，那么当前线程执行缓存构建逻辑。</li><li>如果 setnx(nx 和 ex) 结果为 false，说明此时已经有其他线程正在执行构建缓存的工作，那么当前线程将休息指定时间(例如这里是50毫秒，取决于构建缓存的速度)后，重新执行函数，直到获取到数据。 </li></ol><h3 id="永远不过期"><a href="#永远不过期" class="headerlink" title="永远不过期"></a>永远不过期</h3><ul><li>从缓存层面来看，确实没有设置过期时间，所以不会出现热点 key 过期后产生的问题，也就是“物理”不过期。 </li><li>从功能层面来看，为每个 value 设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去构建缓存。<br>整个过程如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/5937589-31ab16cd9aff0871.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li></ul><p>从实战看，此方法有效杜绝了热点key产生的问题，但唯一不足的就是重构缓存期间，会出现数据不一致的情况，这取决于应用方是否容忍这种不一致。下面代码使用 Redis 进行模拟：<br><img src="http://upload-images.jianshu.io/upload_images/5937589-a00b171ba0ef7c83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>作为一个并发量较大的应用，在使用缓存时有三个目标:</p><ol><li>加快用户访问速度，提高用户体验。</li><li>降低后端负载，减少潜在的风险，保证系统平稳。</li><li>保证数据“尽可能”及时更新。</li></ol><p><strong>互斥锁 (mutex key)：</strong> 这种方案思路比较简单，但是存在一定的隐患，如果构建缓存过程出现问题或者时间较长，可能会存在死锁和线程池阻塞的风险，但是这种方法能够较好的降低后端存储负载并在一致性上做的比较好。<br><strong>永远不过期</strong>：这种方案由于没有设置真正的过期时间，实际上已经不存在热点 key 产生的一系列危害，但是会存在数据不一致的情况，同时代码复杂度会增大。</p><table><thead><tr><th style="text-align:center">解决方案</th><th style="text-align:left">优点</th><th style="text-align:left">缺点</th></tr></thead><tbody><tr><td style="text-align:center">简单分布式锁</td><td style="text-align:left">1、思路简单<br>2、保证一致性</td><td style="text-align:left">1、代码复杂性增大 <br> 2、存在死锁的风险<br>3、存在线程池阻塞的风险</td></tr><tr><td style="text-align:center">“永远不过期”</td><td style="text-align:left">基本杜绝热点key问题</td><td style="text-align:left">1、可能存在数据不一致 <br> 2、增加代码维护成本以及内存成本</td></tr></tbody></table><p><a href="http://www.cnblogs.com/duanxz/p/3788366.html" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      缓存穿透、缓存雪崩、key重建
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>从ConcurrentHashMap看Java多线程核心技术</title>
    <link href="http://blog.linzhongtai.cn/2018/10/%E4%BB%8EConcurrentHashMap%E7%9C%8BJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    <id>http://blog.linzhongtai.cn/2018/10/从ConcurrentHashMap看Java多线程核心技术/</id>
    <published>2018-10-10T09:39:13.000Z</published>
    <updated>2018-10-10T09:39:13.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>本文转发自技术世界，原文链接　<a href="http://www.jasongj.com/java/concurrenthashmap/" target="_blank" rel="noopener">http://www.jasongj.com/java/concurrenthashmap/</a></p></blockquote><blockquote><p>注：本章的代码均基于JDK 1.7.0_67</p></blockquote><h2 id="线程不安全的HashMap"><a href="#线程不安全的HashMap" class="headerlink" title="线程不安全的HashMap"></a>线程不安全的HashMap</h2><p>众所周知，HashMap是非线程安全的。而HashMap的线程不安全主要体现在resize时的死循环及使用迭代器时的fast-fail上。</p><h3 id="HashMap工作原理"><a href="#HashMap工作原理" class="headerlink" title="HashMap工作原理"></a>HashMap工作原理</h3><h4 id="HashMap数据结构"><a href="#HashMap数据结构" class="headerlink" title="HashMap数据结构"></a>HashMap数据结构</h4><p>常用的底层数据结构主要有数组和链表。数组存储区间连续，占用内存较多，寻址容易，插入和删除困难。链表存储区间离散，占用内存较少，寻址困难，插入和删除容易。</p><p>HashMap要实现的是哈希表的效果，尽量实现O(1)级别的增删改查。它的具体实现则是同时使用了数组和链表，可以认为最外层是一个数组，数组的每个元素是一个链表的表头。</p><h4 id="HashMap寻址方式"><a href="#HashMap寻址方式" class="headerlink" title="HashMap寻址方式"></a>HashMap寻址方式</h4><p>对于新插入的数据或者待读取的数据，HashMap将Key的哈希值对数组长度取模，结果作为该Entry在数组中的index。在计算机中，取模的代价远高于位操作的代价，因此HashMap要求数组的长度必须为2的N次方。此时将Key的哈希值对2^N-1进行与运算，其效果即与取模等效。HashMap并不要求用户在指定HashMap容量时必须传入一个2的N次方的整数，而是会通过Integer.highestOneBit算出比指定整数小的最大的2^N值，其实现方法如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static int highestOneBit(int i) &#123;</span><br><span class="line">  i |= (i &gt;&gt;  1);</span><br><span class="line">  i |= (i &gt;&gt;  2);</span><br><span class="line">  i |= (i &gt;&gt;  4);</span><br><span class="line">  i |= (i &gt;&gt;  8);</span><br><span class="line">  i |= (i &gt;&gt; 16);</span><br><span class="line">  return i - (i &gt;&gt;&gt; 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于Key的哈希值的分布直接决定了所有数据在哈希表上的分布或者说决定了哈希冲突的可能性，因此为防止糟糕的Key的hashCode实现（例如低位都相同，只有高位不相同，与2^N-1取与后的结果都相同），JDK 1.7的HashMap通过如下方法使得最终的哈希值的二进制形式中的1尽量均匀分布从而尽可能减少哈希冲突。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int h = hashSeed;</span><br><span class="line">h ^= k.hashCode();</span><br><span class="line">h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br></pre></td></tr></table></figure><h3 id="resize死循环"><a href="#resize死循环" class="headerlink" title="resize死循环"></a>resize死循环</h3><h4 id="transfer方法"><a href="#transfer方法" class="headerlink" title="transfer方法"></a>transfer方法</h4><p>当HashMap的size超过Capacity*loadFactor时，需要对HashMap进行扩容。具体方法是，创建一个新的，长度为原来Capacity两倍的数组，保证新的Capacity仍为2的N次方，从而保证上述寻址方式仍适用。同时需要通过如下transfer方法将原来的所有数据全部重新插入（rehash）到新的数组中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">  int newCapacity = newTable.length;</span><br><span class="line">  for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">    while(null != e) &#123;</span><br><span class="line">      Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">      if (rehash) &#123;</span><br><span class="line">        e.hash = null == e.key ? 0 : hash(e.key);</span><br><span class="line">      &#125;</span><br><span class="line">      int i = indexFor(e.hash, newCapacity);</span><br><span class="line">      e.next = newTable[i];</span><br><span class="line">      newTable[i] = e;</span><br><span class="line">      e = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法并不保证线程安全，而且在多线程并发调用时，可能出现死循环。其执行过程如下。从步骤2可见，转移时链表顺序反转。</p><ol><li>遍历原数组中的元素</li><li>对链表上的每一个节点遍历：用next取得要转移那个元素的下一个，将e转移到新数组的头部，使用头插法插入节点</li><li>循环2，直到链表节点全部转移</li><li>循环1，直到所有元素全部转移</li></ol><h4 id="单线程rehash"><a href="#单线程rehash" class="headerlink" title="单线程rehash"></a>单线程rehash</h4><p>单线程情况下，rehash无问题。下图演示了单线程条件下的rehash过程</p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-e0a43281e978f0f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h4 id="多线程并发下的rehash"><a href="#多线程并发下的rehash" class="headerlink" title="多线程并发下的rehash"></a>多线程并发下的rehash</h4><p>这里假设有两个线程同时执行了put操作并引发了rehash，执行了transfer方法，并假设线程一进入transfer方法并执行完next = e.next后，因为线程调度所分配时间片用完而“暂停”，此时线程二完成了transfer方法的执行。此时状态如下。</p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-0d09e45d87c1b565.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>接着线程1被唤醒，继续执行第一轮循环的剩余部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e.next = newTable[1] = null</span><br><span class="line">newTable[1] = e = key(5)</span><br><span class="line">e = next = key(9)</span><br></pre></td></tr></table></figure><p>结果如下图所示:</p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-cb17d3b1c2d9f858.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>接着执行下一轮循环，结果状态图如下所示:</p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-816de4cf32a85eb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>继续下一轮循环，结果状态图如下所示:</p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-ee745434f8ca222e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>此时循环链表形成，并且key(11)无法加入到线程1的新数组。在下一次访问该链表时会出现死循环。</p><h3 id="Fast-fail"><a href="#Fast-fail" class="headerlink" title="Fast-fail"></a>Fast-fail</h3><h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><p>在使用迭代器的过程中如果HashMap被修改，那么ConcurrentModificationException将被抛出，也即Fast-fail策略。</p><p>当HashMap的iterator()方法被调用时，会构造并返回一个新的EntryIterator对象，并将EntryIterator的expectedModCount设置为HashMap的modCount（该变量记录了HashMap被修改的次数）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashIterator() &#123;</span><br><span class="line">  expectedModCount = modCount;</span><br><span class="line">  if (size &gt; 0) &#123; // advance to first entry</span><br><span class="line">  Entry[] t = table;</span><br><span class="line">  while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)</span><br><span class="line">    ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在通过该Iterator的next方法访问下一个Entry时，它会先检查自己的expectedModCount与HashMap的modCount是否相等，如果不相等，说明HashMap被修改，直接抛出ConcurrentModificationException。该Iterator的remove方法也会做类似的检查。该异常的抛出意在提醒用户及早意识到线程安全问题。</p><h4 id="线程安全解决方案"><a href="#线程安全解决方案" class="headerlink" title="线程安全解决方案"></a>线程安全解决方案</h4><p>单线程条件下，为避免出现ConcurrentModificationException，需要保证只通过HashMap本身或者只通过Iterator去修改数据，不能在Iterator使用结束之前使用HashMap本身的方法修改数据。因为通过Iterator删除数据时，HashMap的modCount和Iterator的expectedModCount都会自增，不影响二者的相等性。如果是增加数据，只能通过HashMap本身的方法完成，此时如果要继续遍历数据，需要重新调用iterator()方法从而重新构造出一个新的Iterator，使得新Iterator的expectedModCount与更新后的HashMap的modCount相等。</p><p>多线程条件下，可使用Collections.synchronizedMap方法构造出一个同步Map，或者直接使用线程安全的ConcurrentHashMap。</p><h2 id="Java-7基于分段锁的ConcurrentHashMap"><a href="#Java-7基于分段锁的ConcurrentHashMap" class="headerlink" title="Java 7基于分段锁的ConcurrentHashMap"></a>Java 7基于分段锁的ConcurrentHashMap</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>Java 7中的ConcurrentHashMap的底层数据结构仍然是数组和链表。与HashMap不同的是，ConcurrentHashMap最外层不是一个大的数组，而是一个Segment的数组。每个Segment包含一个与HashMap数据结构差不多的链表数组。整体数据结构如下图所示。</p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-bcd7264209f04829.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p>在读写某个Key时，先取该Key的哈希值。并将哈希值的高N位对Segment个数取模从而得到该Key应该属于哪个Segment，接着如同操作HashMap一样操作这个Segment。为了保证不同的值均匀分布到不同的Segment，需要通过如下方法计算哈希值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private int hash(Object k) &#123;</span><br><span class="line">  int h = hashSeed;</span><br><span class="line">  if ((0 != h) &amp;&amp; (k instanceof String)) &#123;</span><br><span class="line">    return sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">  &#125;</span><br><span class="line">  h ^= k.hashCode();</span><br><span class="line">  h += (h &lt;&lt;  15) ^ 0xffffcd7d;</span><br><span class="line">  h ^= (h &gt;&gt;&gt; 10);</span><br><span class="line">  h += (h &lt;&lt;   3);</span><br><span class="line">  h ^= (h &gt;&gt;&gt;  6);</span><br><span class="line">  h += (h &lt;&lt;   2) + (h &lt;&lt; 14);</span><br><span class="line">  return h ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样为了提高取模运算效率，通过如下计算，ssize即为大于concurrencyLevel的最小的2的N次方，同时segmentMask为2^N-1。这一点跟上文中计算数组长度的方法一致。对于某一个Key的哈希值，只需要向右移segmentShift位以取高sshift位，再与segmentMask取与操作即可得到它在Segment数组上的索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int sshift = 0;</span><br><span class="line">int ssize = 1;</span><br><span class="line">while (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">  ++sshift;</span><br><span class="line">  ssize &lt;&lt;= 1;</span><br><span class="line">&#125;</span><br><span class="line">this.segmentShift = 32 - sshift;</span><br><span class="line">this.segmentMask = ssize - 1;</span><br><span class="line">Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];</span><br></pre></td></tr></table></figure><h3 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h3><p>Segment继承自ReentrantLock，所以我们可以很方便的对每一个Segment上锁。</p><p>对于读操作，获取Key所在的Segment时，需要保证可见性(请参考如何保证多线程条件下的可见性)。具体实现上可以使用volatile关键字，也可使用锁。但使用锁开销太大，而使用volatile时每次写操作都会让所有CPU内缓存无效，也有一定开销。ConcurrentHashMap使用如下方法保证可见性，取得最新的Segment。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Segment&lt;K,V&gt; s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)</span><br></pre></td></tr></table></figure><p>获取Segment中的HashEntry时也使用了类似方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">  (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE)</span><br></pre></td></tr></table></figure></p><p>对于写操作，并不要求同时获取所有Segment的锁，因为那样相当于锁住了整个Map。它会先获取该Key-Value对所在的Segment的锁，获取成功后就可以像操作一个普通的HashMap一样操作该Segment，并保证该Segment的安全性。<br>同时由于其它Segment的锁并未被获取，因此理论上可支持concurrencyLevel（等于Segment的个数）个线程安全的并发读写。</p><p>获取锁时，并不直接使用lock来获取，因为该方法获取锁失败时会挂起（参考可重入锁）。事实上，它使用了自旋锁，如果tryLock获取锁失败，说明锁被其它线程占用，此时通过循环再次以tryLock的方式申请锁。如果在循环过程中该Key所对应的链表头被修改，则重置retry次数。如果retry次数超过一定值，则使用lock方法申请锁。</p><p>这里使用自旋锁是因为自旋锁的效率比较高，但是它消耗CPU资源比较多，因此在自旋次数超过阈值时切换为互斥锁。</p><h3 id="size操作"><a href="#size操作" class="headerlink" title="size操作"></a>size操作</h3><p>put、remove和get操作只需要关心一个Segment，而size操作需要遍历所有的Segment才能算出整个Map的大小。一个简单的方案是，先锁住所有Sgment，计算完后再解锁。但这样做，在做size操作时，不仅无法对Map进行写操作，同时也无法进行读操作，不利于对Map的并行操作。</p><p>为更好支持并发操作，ConcurrentHashMap会在不上锁的前提逐个Segment计算3次size，如果某相邻两次计算获取的所有Segment的更新次数（每个Segment都与HashMap一样通过modCount跟踪自己的修改次数，Segment每修改一次其modCount加一）相等，说明这两次计算过程中无更新操作，则这两次计算出的总size相等，可直接作为最终结果返回。如果这三次计算过程中Map有更新，则对所有Segment加锁重新计算Size。该计算方法代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">  final Segment&lt;K,V&gt;[] segments = this.segments;</span><br><span class="line">  int size;</span><br><span class="line">  boolean overflow; // true if size overflows 32 bits</span><br><span class="line">  long sum;         // sum of modCounts</span><br><span class="line">  long last = 0L;   // previous sum</span><br><span class="line">  int retries = -1; // first iteration isn&apos;t retry</span><br><span class="line">  try &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">      if (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">        for (int j = 0; j &lt; segments.length; ++j)</span><br><span class="line">          ensureSegment(j).lock(); // force creation</span><br><span class="line">      &#125;</span><br><span class="line">      sum = 0L;</span><br><span class="line">      size = 0;</span><br><span class="line">      overflow = false;</span><br><span class="line">      for (int j = 0; j &lt; segments.length; ++j) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">        if (seg != null) &#123;</span><br><span class="line">          sum += seg.modCount;</span><br><span class="line">          int c = seg.count;</span><br><span class="line">          if (c &lt; 0 || (size += c) &lt; 0)</span><br><span class="line">            overflow = true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (sum == last)</span><br><span class="line">        break;</span><br><span class="line">      last = sum;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    if (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">      for (int j = 0; j &lt; segments.length; ++j)</span><br><span class="line">        segmentAt(segments, j).unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h3><p>ConcurrentHashMap与HashMap相比，有以下不同点:</p><ul><li>ConcurrentHashMap线程安全，而HashMap非线程安全</li><li>HashMap允许Key和Value为null，而ConcurrentHashMap不允许</li><li>HashMap不允许通过Iterator遍历的同时通过HashMap修改，而ConcurrentHashMap允许该行为，并且该更新对后续的遍历可见</li></ul><h2 id="Java-8基于CAS的ConcurrentHashMap"><a href="#Java-8基于CAS的ConcurrentHashMap" class="headerlink" title="Java 8基于CAS的ConcurrentHashMap"></a>Java 8基于CAS的ConcurrentHashMap</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>Java 7为实现并行访问，引入了Segment这一结构，实现了分段锁，理论上最大并发度与Segment个数相等。Java 8为进一步提高并发性，摒弃了分段锁的方案，而是直接使用一个大的数组。同时为了提高哈希碰撞下的寻址性能，Java 8在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(long(N))）。其数据结构如下图所示</p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-19e2cf9571e7d39b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="寻址方式-1"><a href="#寻址方式-1" class="headerlink" title="寻址方式"></a>寻址方式</h3><p>Java 8的ConcurrentHashMap同样是通过Key的哈希值与数组长度取模确定该Key在数组中的索引。同样为了避免不太好的Key的hashCode设计，它通过如下方法计算得到Key的最终哈希值。不同的是，Java 8的ConcurrentHashMap作者认为引入红黑树后，即使哈希冲突比较严重，寻址效率也足够高，所以作者并未在哈希值的计算上做过多设计，只是将Key的hashCode值与其高16位作异或并保证最高位为0（从而保证最终结果为正整数）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final int spread(int h) &#123;</span><br><span class="line">  return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步方式-1"><a href="#同步方式-1" class="headerlink" title="同步方式"></a>同步方式</h3><p>对于put操作，如果Key对应的数组元素为null，则通过CAS操作将其设置为当前值。如果Key对应的数组元素（也即链表表头或者树的根元素）不为null，则对该元素使用synchronized关键字申请锁，然后进行操作。如果该put操作使得当前链表长度超过一定阈值，则将该链表转换为树，从而提高寻址效率。</p><p>对于读操作，由于数组被volatile关键字修饰，因此不用担心数组的可见性问题。同时每个元素是一个Node实例（Java 7中每个元素是一个HashEntry），它的Key值和hash值都由final修饰，不可变更，无须关心它们被修改后的可见性问题。而其Value及对下一个元素的引用由volatile修饰，可见性也有保障。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">  final int hash;</span><br><span class="line">  final K key;</span><br><span class="line">  volatile V val;</span><br><span class="line">  volatile Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于Key对应的数组元素的可见性，由Unsafe的getObjectVolatile方法保证。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123;</span><br><span class="line">  return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="size操作-1"><a href="#size操作-1" class="headerlink" title="size操作"></a>size操作</h3><p>put方法和remove方法都会通过addCount方法维护Map的size。size方法通过sumCount获取由addCount方法维护的Map的size。</p>]]></content>
    
    <summary type="html">
    
      resize/rehash/Fast-fail
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程相关技术点</title>
    <link href="http://blog.linzhongtai.cn/2018/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E7%82%B9/"/>
    <id>http://blog.linzhongtai.cn/2018/09/多线程相关技术点/</id>
    <published>2018-09-15T09:38:01.000Z</published>
    <updated>2018-09-15T09:38:01.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>本文转发自技术世界，原文链接　<a href="http://www.jasongj.com/java/multi_thread/" target="_blank" rel="noopener">http://www.jasongj.com/java/multi_thread/</a></p></blockquote><h2 id="sleep和wait到底什么区别"><a href="#sleep和wait到底什么区别" class="headerlink" title="sleep和wait到底什么区别"></a>sleep和wait到底什么区别</h2><p>其实这个问题应该这么问——sleep和wait有什么相同点。因为这两个方法除了都能让当前线程暂停执行完，几乎没有其它相同点。</p><p>wait方法是Object类的方法，这意味着所有的Java类都可以调用该方法。sleep方法是Thread类的静态方法。</p><p>wait是在当前线程持有wait对象锁的情况下，暂时放弃锁，并让出CPU资源，并积极等待其它线程调用同一对象的notify或者notifyAll方法。注意，即使只有一个线程在等待，并且有其它线程调用了notify或者notifyAll方法，等待的线程只是被激活，但是它必须得再次获得锁才能继续往下执行。换言之，即使notify被调用，但只要锁没有被释放，原等待线程因为未获得锁仍然无法继续执行。测试代码如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line">public class Wait &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Thread thread1 = new Thread(() -&gt; &#123;</span><br><span class="line">      synchronized (Wait.class) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          System.out.println(new Date() + &quot; Thread1 is running&quot;);</span><br><span class="line">          Wait.class.wait();</span><br><span class="line">          System.out.println(new Date() + &quot; Thread1 ended&quot;);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">          ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    </span><br><span class="line">    Thread thread2 = new Thread(() -&gt; &#123;</span><br><span class="line">      synchronized (Wait.class) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          System.out.println(new Date() + &quot; Thread2 is running&quot;);</span><br><span class="line">          Wait.class.notify();</span><br><span class="line">          // Don&apos;t use sleep method to avoid confusing</span><br><span class="line">          for(long i = 0; i &lt; 200000; i++) &#123;</span><br><span class="line">            for(long j = 0; j &lt; 100000; j++) &#123;&#125;</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(new Date() + &quot; Thread2 release lock&quot;);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">          ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      for(long i = 0; i &lt; 200000; i++) &#123;</span><br><span class="line">        for(long j = 0; j &lt; 100000; j++) &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(new Date() + &quot; Thread2 ended&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    // Don&apos;t use sleep method to avoid confusing</span><br><span class="line">    for(long i = 0; i &lt; 200000; i++) &#123;</span><br><span class="line">      for(long j = 0; j &lt; 100000; j++) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    thread2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Tue Jun 14 22:51:11 CST 2016 Thread1 is running</span><br><span class="line">Tue Jun 14 22:51:23 CST 2016 Thread2 is running</span><br><span class="line">Tue Jun 14 22:51:36 CST 2016 Thread2 release lock</span><br><span class="line">Tue Jun 14 22:51:36 CST 2016 Thread1 ended</span><br><span class="line">Tue Jun 14 22:51:49 CST 2016 Thread2 ended</span><br></pre></td></tr></table></figure><p>从运行结果可以看出</p><ul><li>thread1执行wait后，暂停执行</li><li>thread2执行notify后，thread1并没有继续执行，因为此时thread2尚未释放锁，thread1因为得不到锁而不能继续执行</li><li>thread2执行完synchronized语句块后释放锁，thread1得到通知并获得锁，进而继续执行</li></ul><p>注意：wait方法需要释放锁，前提条件是它已经持有锁。所以wait和notify（或者notifyAll）方法都必须被包裹在synchronized语句块中，并且synchronized后锁的对象应该与调用wait方法的对象一样。否则抛出<strong>IllegalMonitorStateException</strong></p><p>sleep方法告诉操作系统至少指定时间内不需为线程调度器为该线程分配执行时间片，并不释放锁（如果当前已经持有锁）。实际上，调用sleep方法时并不要求持有任何锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.test.thread;</span><br><span class="line">import java.util.Date;</span><br><span class="line">public class Sleep &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Thread thread1 = new Thread(() -&gt; &#123;</span><br><span class="line">      synchronized (Sleep.class) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          System.out.println(new Date() + &quot; Thread1 is running&quot;);</span><br><span class="line">          Thread.sleep(2000);</span><br><span class="line">          System.out.println(new Date() + &quot; Thread1 ended&quot;);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">          ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    </span><br><span class="line">    Thread thread2 = new Thread(() -&gt; &#123;</span><br><span class="line">      synchronized (Sleep.class) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          System.out.println(new Date() + &quot; Thread2 is running&quot;);</span><br><span class="line">          Thread.sleep(2000);</span><br><span class="line">          System.out.println(new Date() + &quot; Thread2 ended&quot;);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">          ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      for(long i = 0; i &lt; 200000; i++) &#123;</span><br><span class="line">        for(long j = 0; j &lt; 100000; j++) &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    // Don&apos;t use sleep method to avoid confusing</span><br><span class="line">    for(long i = 0; i &lt; 200000; i++) &#123;</span><br><span class="line">      for(long j = 0; j &lt; 100000; j++) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    thread2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thu Jun 16 19:46:06 CST 2016 Thread1 is running</span><br><span class="line">Thu Jun 16 19:46:08 CST 2016 Thread1 ended</span><br><span class="line">Thu Jun 16 19:46:13 CST 2016 Thread2 is running</span><br><span class="line">Thu Jun 16 19:46:15 CST 2016 Thread2 ended</span><br></pre></td></tr></table></figure><p>由于thread 1和thread 2的run方法实现都在同步块中，无论哪个线程先拿到锁，执行sleep时并不释放锁，因此其它线程无法执行。直到前面的线程sleep结束并退出同步块（释放锁），另一个线程才得到锁并执行。</p><p>注意：sleep方法并不需要持有任何形式的锁，也就不需要包裹在synchronized中。</p><p>本文所有示例均基于Java HotSpot(TM) 64-Bit Server VM</p><p>调用sleep方法的线程，在jstack中显示的状态为sleeping。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br></pre></td></tr></table></figure><p>调用wait方法的线程，在jstack中显示的状态为on object monitor</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Thread.State: WAITING (on object monitor)</span><br></pre></td></tr></table></figure><h2 id="synchronized几种用法"><a href="#synchronized几种用法" class="headerlink" title="synchronized几种用法"></a>synchronized几种用法</h2><blockquote><p>每个Java对象都可以用做一个实现同步的互斥锁，这些锁被称为内置锁。线程进入同步代码块或方法时自动获得内置锁，退出同步代码块或方法时自动释放该内置锁。进入同步代码块或者同步方法是获得内置锁的唯一途径。</p></blockquote><h3 id="实例同步方法"><a href="#实例同步方法" class="headerlink" title="实例同步方法"></a>实例同步方法</h3><p>synchronized用于修饰实例方法（非静态方法）时，执行该方法需要获得的是该类实例对象的内置锁（同一个类的不同实例拥有不同的内置锁）。如果多个实例方法都被synchronized修饰，则当多个线程调用同一实例的不同同步方法（或者同一方法）时，需要竞争锁。但当调用的是不同实例的方法时，并不需要竞争锁。</p><h3 id="静态同步方法"><a href="#静态同步方法" class="headerlink" title="静态同步方法"></a>静态同步方法</h3><p>synchronized用于修饰静态方法时，执行该方法需要获得的是该类的class对象的内置锁（一个类只有唯一一个class对象）。调用同一个类的不同静态同步方法时会产生锁竞争。</p><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>synchronized用于修饰代码块时，进入同步代码块需要获得synchronized关键字后面括号内的对象（可以是实例对象也可以是class对象）的内置锁。</p><h3 id="synchronized使用总结"><a href="#synchronized使用总结" class="headerlink" title="synchronized使用总结"></a>synchronized使用总结</h3><p>锁的使用是为了操作临界资源的正确性，而往往一个方法中并非所有的代码都操作临界资源。换句话说，方法中的代码往往并不都需要同步。此时建议不使用同步方法，而使用同步代码块，只对操作临界资源的代码，也即需要同步的代码加锁。这样做的好处是，当一个线程在执行同步代码块时，其它线程仍然可以执行该方法内同步代码块以外的部分，充分发挥多线程并发的优势，从而相较于同步整个方法而言提升性能。</p><p>释放Java内置锁的唯一方式是synchronized方法或者代码块执行结束。若某一线程在synchronized方法或代码块内发生死锁，则对应的内置锁无法释放，其它线程也无法获取该内置锁（即进入跟该内置锁相关的synchronized方法或者代码块）。</p><p>使用jstack dump线程栈时，可查看到相关线程通过synchronized获取到或等待的对象，但Locked ownable synchronizers仍然显示为None。下例中，线程thead-test-b已获取到类型为java.lang.Double的对象的内置锁（monitor），且该对象的内存地址为0x000000076ab95cb8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;thread-test-b&quot; #11 prio=5 os_prio=31 tid=0x00007fab0190b800 nid=0x5903 runnable [0x0000700010249000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at com.jasongj.demo.TestJstack.lambda$1(TestJstack.java:27)</span><br><span class="line">        - locked &lt;0x000000076ab95cb8&gt; (a java.lang.Double)</span><br><span class="line">        at com.jasongj.demo.TestJstack$$Lambda$2/1406718218.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:745)</span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - None</span><br></pre></td></tr></table></figure><h2 id="Java中的锁"><a href="#Java中的锁" class="headerlink" title="Java中的锁"></a>Java中的锁</h2><h3 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h3><p>Java中的重入锁（即ReentrantLock）与Java内置锁一样，是一种排它锁。使用synchronized的地方一定可以用ReentrantLock代替。</p><p>重入锁需要显示请求获取锁，并显示释放锁。为了避免获得锁后，没有释放锁，而造成其它线程无法获得锁而造成死锁，一般建议将释放锁操作放在finally块里，如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">  renentrantLock.lock();</span><br><span class="line">  // 用户操作</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  renentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果重入锁已经被其它线程持有，则当前线程的lock操作会被阻塞。除了lock()方法之外，重入锁（或者说锁接口）还提供了其它获取锁的方法以实现不同的效果。</p><ul><li>lockInterruptibly() 该方法尝试获取锁，若获取成功立即返回；若获取不成功则阻塞等待。与lock方法不同的是，在阻塞期间，如果当前线程被打断（interrupt）则该方法抛出InterruptedException。该方法提供了一种解除死锁的途径。</li><li>tryLock() 该方法试图获取锁，若该锁当前可用，则该方法立即获得锁并立即返回true；若锁当前不可用，则立即返回false。该方法不会阻塞，并提供给用户对于成功获利锁与获取锁失败进行不同操作的可能性。</li><li>tryLock(long time, TimeUnit unit) 该方法试图获得锁，若该锁当前可用，则立即获得锁并立即返回true。若锁当前不可用，则等待相应的时间（由该方法的两个参数决定）：1）若该时间内锁可用，则获得锁，并返回true；2）若等待期间当前线程被打断，则抛出InterruptedException；3）若等待时间结束仍未获得锁，则返回false。</li></ul><p>重入锁可定义为公平锁或非公平锁，默认实现为非公平锁。</p><ul><li>公平锁是指多个线程获取锁被阻塞的情况下，锁变为可用时，最新申请锁的线程获得锁。可通过在重入锁（RenentrantLock）的构造方法中传入true构建公平锁，如Lock lock = new RenentrantLock(true)</li><li>非公平锁是指多个线程等待锁的情况下，锁变为可用状态时，哪个线程获得锁是随机的。synchonized相当于非公平锁。可通过在重入锁的构造方法中传入false或者使用无参构造方法构建非公平锁。</li></ul><p>使用jstack dump线程栈时，可查看到获取到或正在等待的锁对象，获取到该锁的线程会在Locked ownable synchronizers处显示该锁的对象类型及内存地址。在下例中，从Locked ownable synchronizers部分可看到，线程thread-test-e获取到公平重入锁，且该锁对象的内存地址为0x000000076ae3d708</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;thread-test-e&quot; #17 prio=5 os_prio=31 tid=0x00007fefaa0b6800 nid=0x6403 runnable [0x0000700002939000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at com.jasongj.demo.TestJstack.lambda$4(TestJstack.java:64)</span><br><span class="line">        at com.jasongj.demo.TestJstack$$Lambda$5/466002798.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:745)</span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - &lt;0x000000076af86810&gt; (a java.util.concurrent.locks.ReentrantLock$FairSync)</span><br></pre></td></tr></table></figure><p>而线程thread-test-f由于未获取到锁，而处于WAITING(parking)状态，且它等待的锁正是上文线程thread-test-e获取的锁（内存地址0x000000076af86810）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&quot;thread-test-f&quot; #18 prio=5 os_prio=31 tid=0x00007fefaa9b2800 nid=0x6603 waiting on condition [0x0000700002a3c000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        - parking to wait for  &lt;0x000000076af86810&gt; (a java.util.concurrent.locks.ReentrantLock$FairSync)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:870)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:1199)</span><br><span class="line">        at java.util.concurrent.locks.ReentrantLock$FairSync.lock(ReentrantLock.java:224)</span><br><span class="line">        at java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:285)</span><br><span class="line">        at com.jasongj.demo.TestJstack.lambda$5(TestJstack.java:69)</span><br><span class="line">        at com.jasongj.demo.TestJstack$$Lambda$6/33524623.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:745)</span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - None</span><br></pre></td></tr></table></figure><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>锁可以保证原子性和可见性。而原子性更多是针对写操作而言。对于读多写少的场景，一个读操作无须阻塞其它读操作，只需要保证读和写或者写与写不同时发生即可。此时，如果使用重入锁（即排它锁），对性能影响较大。Java中的读写锁（ReadWriteLock）就是为这种读多写少的场景而创造的。</p><p>实际上，ReadWriteLock接口并非继承自Lock接口，ReentrantReadWriteLock也只实现了ReadWriteLock接口而未实现Lock接口。ReadLock和WriteLock，是ReentrantReadWriteLock类的静态内部类，它们实现了Lock接口。</p><p>一个ReentrantReadWriteLock实例包含一个ReentrantReadWriteLock.ReadLock实例和一个ReentrantReadWriteLock.WriteLock实例。通过readLock()和writeLock()方法可分别获得读锁实例和写锁实例，并通过Lock接口提供的获取锁方法获得对应的锁。</p><p>读写锁的锁定规则如下：</p><ul><li>获得读锁后，其它线程可获得读锁而不能获取写锁</li><li>获得写锁后，其它线程既不能获得读锁也不能获得写锁</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package com.test.thread;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line">public class ReadWriteLockDemo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    ReadWriteLock readWriteLock = new ReentrantReadWriteLock();</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">      readWriteLock.readLock().lock();</span><br><span class="line">      try &#123;</span><br><span class="line">        System.out.println(new Date() + &quot;\tThread 1 started with read lock&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">          Thread.sleep(2000);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(new Date() + &quot;\tThread 1 ended&quot;);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        readWriteLock.readLock().unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">      readWriteLock.readLock().lock();</span><br><span class="line">      try &#123;</span><br><span class="line">        System.out.println(new Date() + &quot;\tThread 2 started with read lock&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">          Thread.sleep(2000);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(new Date() + &quot;\tThread 2 ended&quot;);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        readWriteLock.readLock().unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">      Lock lock = readWriteLock.writeLock();</span><br><span class="line">      lock.lock();</span><br><span class="line">      try &#123;</span><br><span class="line">        System.out.println(new Date() + &quot;\tThread 3 started with write lock&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">          Thread.sleep(2000);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">          ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(new Date() + &quot;\tThread 3 ended&quot;);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sat Jun 18 21:33:46 CST 2016  Thread 1 started with read lock</span><br><span class="line">Sat Jun 18 21:33:46 CST 2016  Thread 2 started with read lock</span><br><span class="line">Sat Jun 18 21:33:48 CST 2016  Thread 2 ended</span><br><span class="line">Sat Jun 18 21:33:48 CST 2016  Thread 1 ended</span><br><span class="line">Sat Jun 18 21:33:48 CST 2016  Thread 3 started with write lock</span><br><span class="line">Sat Jun 18 21:33:50 CST 2016  Thread 3 ended</span><br></pre></td></tr></table></figure><p>从上面的执行结果可见，thread 1和thread 2都只需获得读锁，因此它们可以并行执行。而thread 3因为需要获取写锁，必须等到thread 1和thread 2释放锁后才能获得锁。</p><h3 id="条件锁"><a href="#条件锁" class="headerlink" title="条件锁"></a>条件锁</h3><p>条件锁只是一个帮助用户理解的概念，实际上并没有条件锁这种锁。对于每个重入锁，都可以通过newCondition()方法绑定若干个条件对象。</p><p>条件对象提供以下方法以实现不同的等待语义</p><ul><li>await() 调用该方法的前提是，当前线程已经成功获得与该条件对象绑定的重入锁，否则调用该方法时会抛出IllegalMonitorStateException。调用该方法外，当前线程会释放当前已经获得的锁（这一点与上文讲述的Java内置锁的wait方法一致），并且等待其它线程调用该条件对象的signal()或者signalAll()方法（这一点与Java内置锁wait后等待notify()或notifyAll()很像）。或者在等待期间，当前线程被打断，则wait()方法会抛出InterruptedException并清除当前线程的打断状态。</li><li>await(long time, TimeUnit unit) 适用条件和行为与await()基本一致，唯一不同点在于，指定时间之内没有收到signal()或signalALL()信号或者线程中断时该方法会返回false;其它情况返回true。</li><li>awaitNanos(long nanosTimeout) 调用该方法的前提是，当前线程已经成功获得与该条件对象绑定的重入锁，否则调用该方法时会抛出IllegalMonitorStateException。nanosTimeout指定该方法等待信号的的最大时间（单位为纳秒）。若指定时间内收到signal()或signalALL()则返回nanosTimeout减去已经等待的时间；若指定时间内有其它线程中断该线程，则抛出InterruptedException并清除当前线程的打断状态；若指定时间内未收到通知，则返回0或负数。</li><li>awaitUninterruptibly() 调用该方法的前提是，当前线程已经成功获得与该条件对象绑定的重入锁，否则调用该方法时会抛出IllegalMonitorStateException。调用该方法后，结束等待的唯一方法是其它线程调用该条件对象的signal()或signalALL()方法。等待过程中如果当前线程被中断，该方法仍然会继续等待，同时保留该线程的中断状态。</li><li>awaitUntil(Date deadline) 适用条件与行为与awaitNanos(long nanosTimeout)完全一样，唯一不同点在于它不是等待指定时间，而是等待由参数指定的某一时刻。</li></ul><p>调用条件等待的注意事项</p><ul><li>调用上述任意条件等待方法的前提都是当前线程已经获得与该条件对象对应的重入锁。</li><li>调用条件等待后，当前线程让出CPU资源。</li><li>上述等待方法结束后，方法返回的前提是它能重新获得与该条件对象对应的重入锁。如果无法获得锁，仍然会继续等待。这也是awaitNanos(long nanosTimeout)可能会返回负值的原因。</li><li>一旦条件等待方法返回，则当前线程肯定已经获得了对应的重入锁。</li><li>重入锁可以创建若干个条件对象，signal()和signalAll()方法只能唤醒相同条件对象的等待。</li><li>一个重入锁上可以生成多个条件变量，不同线程可以等待不同的条件，从而实现更加细粒度的的线程间通信。</li></ul><p>signal()与signalAll()</p><ul><li>signal() 若有一个或若干个线程在等待该条件变量，则该方法会唤醒其中的一个（具体哪一个，无法预测）。调用该方法的前提是当前线程持有该条件变量对应的锁，否则抛出IllegalMonitorStateException。</li><li>signalALL() 若有一个或若干个线程在等待该条件变量，则该方法会唤醒所有等待。调用该方法的前提是当前线程持有该条件变量对应的锁，否则抛出IllegalMonitorStateException。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package com.test.thread;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line">public class ConditionTest &#123;</span><br><span class="line">  public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Lock lock = new ReentrantLock();</span><br><span class="line">    Condition condition = lock.newCondition();</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      try &#123;</span><br><span class="line">        System.out.println(new Date() + &quot;\tThread 1 is waiting&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">          long waitTime = condition.awaitNanos(TimeUnit.SECONDS.toNanos(2));</span><br><span class="line">          System.out.println(new Date() + &quot;\tThread 1 remaining time &quot; + waitTime);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">          ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(new Date() + &quot;\tThread 1 is waken up&quot;);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    </span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      try&#123;</span><br><span class="line">        System.out.println(new Date() + &quot;\tThread 2 is running&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">          Thread.sleep(4000);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">          ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        condition.signal();</span><br><span class="line">        System.out.println(new Date() + &quot;\tThread 2 ended&quot;);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sun Jun 19 15:59:09 CST 2016  Thread 1 is waiting</span><br><span class="line">Sun Jun 19 15:59:09 CST 2016  Thread 2 is running</span><br><span class="line">Sun Jun 19 15:59:13 CST 2016  Thread 2 ended</span><br><span class="line">Sun Jun 19 15:59:13 CST 2016  Thread 1 remaining time -2003467560</span><br><span class="line">Sun Jun 19 15:59:13 CST 2016  Thread 1 is waken up</span><br></pre></td></tr></table></figure><p>从执行结果可以看出，虽然thread 2一开始就调用了signal()方法去唤醒thread 1，但是因为thread 2在4秒钟后才释放锁，也即thread 1在4秒后才获得锁，所以thread 1的await方法在4秒钟后才返回，并且返回负值。</p><h2 id="信号量Semaphore"><a href="#信号量Semaphore" class="headerlink" title="信号量Semaphore"></a>信号量Semaphore</h2><p>信号量维护一个许可集，可通过acquire()获取许可（若无可用许可则阻塞），通过release()释放许可，从而可能唤醒一个阻塞等待许可的线程。</p><p>与互斥锁类似，信号量限制了同一时间访问临界资源的线程的个数，并且信号量也分公平信号量与非公平信号量。而不同的是，互斥锁保证同一时间只会有一个线程访问临界资源，而信号量可以允许同一时间多个线程访问特定资源。所以信号量并不能保证原子性。</p><p>信号量的一个典型使用场景是限制系统访问量。每个请求进来后，处理之前都通过acquire获取许可，若获取许可成功则处理该请求，若获取失败则等待处理或者直接不处理该请求。</p><p>信号量的使用方法:</p><ul><li>acquire(int permits) 申请permits（必须为非负数）个许可，若获取成功，则该方法返回并且当前可用许可数减permits；若当前可用许可数少于permits指定的个数，则继续等待可用许可数大于等于permits；若等待过程中当前线程被中断，则抛出InterruptedException。</li><li>acquire() 等价于acquire(1)。</li><li>acquireUninterruptibly(int permits) 申请permits（必须为非负数）个许可，若获取成功，则该方法返回并且当前可用许可数减permits；若当前许可数少于permits，则继续等待可用许可数大于等于permits；若等待过程中当前线程被中断，继续等待可用许可数大于等于permits，并且获取成功后设置线程中断状态。</li><li>acquireUninterruptibly() 等价于acquireUninterruptibly(1)。</li><li>drainPermits() 获取所有可用许可，并返回获取到的许可个数，该方法不阻塞。</li><li>tryAcquire(int permits) 尝试获取permits个可用许可，如果当前许可个数大于等于permits，则返回true并且可用许可数减permits；否则返回false并且可用许可数不变。</li><li>tryAcquire() 等价于tryAcquire(1)。</li><li>tryAcquire(int permits, long timeout, TimeUnit unit) 尝试获取permits（必须为非负数）个许可，若在指定时间内获取成功则返回true并且可用许可数减permits；若指定时间内当前线程被中断，则抛出InterruptedException；若指定时间内可用许可数均小于permits，则返回false。</li><li>tryAcquire(long timeout, TimeUnit unit) 等价于tryAcquire(1, long timeout, TimeUnit unit)*</li><li>release(int permits) 释放permits个许可，该方法不阻塞并且某线程调用release方法前并不需要先调用acquire方法。</li><li>release() 等价于release(1)。</li></ul><p>注意：与wait/notify和await/signal不同，acquire/release完全与锁无关，因此acquire等待过程中，可用许可满足要求时acquire可立即返回，而不用像锁的wait和条件变量的await那样重新获取锁才能返回。或者可以理解成，只要可用许可满足需求，就已经获得了锁。</p>]]></content>
    
    <summary type="html">
    
      多线程开发涉及到的相关技术点
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>深入理解ThreadLocal</title>
    <link href="http://blog.linzhongtai.cn/2018/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ThreadLocal/"/>
    <id>http://blog.linzhongtai.cn/2018/08/深入理解ThreadLocal/</id>
    <published>2018-08-24T09:36:33.000Z</published>
    <updated>2018-08-24T09:36:33.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>本文转发自技术世界，原文链接　<a href="http://www.jasongj.com/java/threadlocal/" target="_blank" rel="noopener">http://www.jasongj.com/java/threadlocal/</a><br><a href="http://www.cnblogs.com/dolphin0520/p/3920407.html" target="_blank" rel="noopener">《Java并发编程：深入剖析ThreadLocal》</a></p></blockquote><h2 id="ThreadLocal的理解"><a href="#ThreadLocal的理解" class="headerlink" title="ThreadLocal的理解"></a>ThreadLocal的理解</h2><blockquote><p>ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储。ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被private static修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收</p></blockquote><p><strong>ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景</strong></p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class ConnectionManager &#123;</span><br><span class="line">     </span><br><span class="line">    private static Connection connect = null;</span><br><span class="line">     </span><br><span class="line">    public static Connection openConnection() &#123;</span><br><span class="line">        if(connect == null)&#123;</span><br><span class="line">            connect = DriverManager.getConnection();</span><br><span class="line">        &#125;</span><br><span class="line">        return connect;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void closeConnection() &#123;</span><br><span class="line">        if(connect!=null)</span><br><span class="line">            connect.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有这样一个数据库链接管理类，这段代码在单线程中使用是没有任何问题的，但是如果在多线程中使用呢？很显然，在多线程中使用会存在线程安全问题：第一，这里面的2个方法都没有进行同步，很可能在openConnection方法中会多次创建connect；第二，由于connect是共享变量，那么必然在调用connect的地方需要使用到同步来保障线程安全，因为很可能一个线程在使用connect进行数据库操作，而另外一个线程调用closeConnection关闭链接。<br>　　所以出于线程安全的考虑，必须将这段代码的两个方法进行同步处理，并且在调用connect的地方需要进行同步处理。<br>　　这样将会大大影响程序执行效率，因为一个线程在使用connect进行数据库操作的时候，其他线程只有等待。<br>　　那么大家来仔细分析一下这个问题，这地方到底需不需要将connect变量进行共享？事实上，是不需要的。假如每个线程中都有一个connect变量，各个线程之间对connect变量的访问实际上是没有依赖关系的，即一个线程不需要关心其他线程是否对这个connect进行了修改的。<br>　　到这里，可能会有朋友想到，既然不需要在线程之间共享这个变量，可以直接这样处理，在每个需要使用数据库连接的方法中具体使用时才创建数据库链接，然后在方法调用完毕再释放这个连接。比如下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class ConnectionManager &#123;</span><br><span class="line">     </span><br><span class="line">    private  Connection connect = null;</span><br><span class="line">     </span><br><span class="line">    public Connection openConnection() &#123;</span><br><span class="line">        if(connect == null)&#123;</span><br><span class="line">            connect = DriverManager.getConnection();</span><br><span class="line">        &#125;</span><br><span class="line">        return connect;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public void closeConnection() &#123;</span><br><span class="line">        if(connect!=null)</span><br><span class="line">            connect.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class Dao&#123;</span><br><span class="line">    public void insert() &#123;</span><br><span class="line">        ConnectionManager connectionManager = new ConnectionManager();</span><br><span class="line">        Connection connection = connectionManager.openConnection();</span><br><span class="line">         </span><br><span class="line">        //使用connection进行操作</span><br><span class="line">         </span><br><span class="line">        connectionManager.closeConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样处理确实也没有任何问题，由于每次都是在方法内部创建的连接，那么线程之间自然不存在线程安全问题。但是这样会有一个致命的影响：导致服务器压力非常大，并且严重影响程序执行性能。由于在方法中需要频繁地开启和关闭数据库连接，这样不尽严重影响程序执行效率，还可能导致服务器压力巨大。<br>　　那么这种情况下使用ThreadLocal是再适合不过的了，因为ThreadLocal在每个线程中对该变量会创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private static ThreadLocal&lt;Connection&gt; connectionHolder</span><br><span class="line">= new ThreadLocal&lt;Connection&gt;() &#123;</span><br><span class="line">public Connection initialValue() &#123;</span><br><span class="line">    return DriverManager.getConnection(DB_URL);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">public static Connection getConnection() &#123;</span><br><span class="line">return connectionHolder.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　但是要注意，虽然ThreadLocal能够解决上面说的问题，但是由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用ThreadLocal要大。</p><h2 id="深入解析ThreadLocal"><a href="#深入解析ThreadLocal" class="headerlink" title="深入解析ThreadLocal"></a>深入解析ThreadLocal</h2><p>先了解一下ThreadLocal类提供的几个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123; &#125;</span><br><span class="line">public void set(T value) &#123; &#125;</span><br><span class="line">public void remove() &#123; &#125;</span><br><span class="line">protected T initialValue() &#123; &#125;</span><br></pre></td></tr></table></figure></p><p>　get()方法是用来获取ThreadLocal在当前线程中保存的变量副本，set()用来设置当前线程中变量的副本，remove()用来移除当前线程中变量的副本，initialValue()是一个protected方法，一般是用来在使用时进行重写的，它是一个延迟加载方法</p><h3 id="ThreadLocal维护线程与实例的映射"><a href="#ThreadLocal维护线程与实例的映射" class="headerlink" title="ThreadLocal维护线程与实例的映射"></a>ThreadLocal维护线程与实例的映射</h3><p>既然每个访问 ThreadLocal 变量的线程都有自己的一个“本地”实例副本。一个可能的方案是 ThreadLocal 维护一个 Map，键是 Thread，值是它在该 Thread 内的实例。线程通过该 ThreadLocal 的 get() 方案获取实例时，只需要以线程为键，从 Map 中找出对应的实例即可。该方案如下图所示</p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-11bf844af8a2a95e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>该方案可满足上文提到的每个线程内一个独立备份的要求。每个新线程访问该 ThreadLocal 时，需要向 Map 中添加一个映射，而每个线程结束时，应该清除该映射。这里就有两个问题：</p><ul><li>增加线程与减少线程均需要写Map，故需保证该Map线程安全。</li><li>线程结束时，需要保证它所访问的所有 ThreadLocal 中对应的映射均删除，否则可能会引起内存泄漏。</li></ul><p>其中锁的问题，是 JDK 未采用该方案的一个原因。</p><h3 id="Thread维护ThreadLocal与实例的映射"><a href="#Thread维护ThreadLocal与实例的映射" class="headerlink" title="Thread维护ThreadLocal与实例的映射"></a>Thread维护ThreadLocal与实例的映射</h3><p>上述方案中，出现锁的问题，原因在于多线程访问同一个 Map。如果该 Map 由 Thread 维护，从而使得每个 Thread 只访问自己的 Map，那就不存在多线程写的问题，也就不需要锁。该方案如下图所示。</p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-3ff3760fd61744aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>该方案虽然没有锁的问题，但是由于每个线程访问某 ThreadLocal 变量后，都会在自己的 Map 内维护该 ThreadLocal 变量与具体实例的映射，如果不删除这些引用（映射），则这些 ThreadLocal 不能被回收，可能会造成内存泄漏。后文会介绍 JDK 如何解决该问题。</p><h3 id="ThreadLocal-在-JDK-8-中的实现"><a href="#ThreadLocal-在-JDK-8-中的实现" class="headerlink" title="ThreadLocal 在 JDK 8 中的实现"></a>ThreadLocal 在 JDK 8 中的实现</h3><h4 id="ThreadLocalMap与内存泄漏"><a href="#ThreadLocalMap与内存泄漏" class="headerlink" title="ThreadLocalMap与内存泄漏"></a>ThreadLocalMap与内存泄漏</h4><p>该方案中，Map 由 ThreadLocal 类的静态内部类 ThreadLocalMap 提供。该类的实例维护某个 ThreadLocal 与具体实例的映射。与 HashMap 不同的是，ThreadLocalMap 的每个 Entry 都是一个<strong>对键的弱引用</strong>，这一点从super(k)可看出。另外，每个 Entry 都包含了一个<strong>对值的强引用</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">  /** The value associated with this ThreadLocal. */</span><br><span class="line">  Object value;</span><br><span class="line">  Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">    super(k);</span><br><span class="line">    value = v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用弱引用的原因在于，当没有强引用指向 ThreadLocal 变量时，它可被回收，从而避免上文所述 ThreadLocal 不能被回收而造成的内存泄漏的问题。</p><p>但是，这里又可能出现另外一种内存泄漏的问题。ThreadLocalMap 维护 ThreadLocal 变量与具体实例的映射，当 ThreadLocal 变量被回收后，该映射的键变为 null，该 Entry 无法被移除。从而使得实例被该 Entry 引用而无法被回收造成内存泄漏。</p><p>注：Entry虽然是弱引用，但它是ThreadLocal类型的弱引用（也即上文所述它是对键的弱引用），而非具体实例的的弱引用，所以无法避免具体实例相关的内存泄漏。</p><h4 id="读取实例"><a href="#读取实例" class="headerlink" title="读取实例"></a>读取实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">  Thread t = Thread.currentThread();</span><br><span class="line">  ThreadLocalMap map = getMap(t);</span><br><span class="line">  if (map != null) &#123;</span><br><span class="line">    ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">    if (e != null) &#123;</span><br><span class="line">      @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">      T result = (T)e.value;</span><br><span class="line">      return result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取实例时，线程首先通过getMap(t)方法获取自身的 ThreadLocalMap。从如下该方法的定义可见，该 ThreadLocalMap 的实例是 Thread 类的一个字段，即由 Thread 维护 ThreadLocal 对象与具体实例的映射，这一点与上文分析一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">  return t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>获取到 ThreadLocalMap 后，通过map.getEntry(this)方法获取该 ThreadLocal 在当前线程的 ThreadLocalMap 中对应的 Entry。该方法中的 this 即当前访问的 ThreadLocal 对象。</p><p>如果获取到的 Entry 不为 null，从 Entry 中取出值即为所需访问的本线程对应的实例。如果获取到的 Entry 为 null，则通过setInitialValue()方法设置该 ThreadLocal 变量在该线程中对应的具体实例的初始值。</p><h4 id="设置初始值"><a href="#设置初始值" class="headerlink" title="设置初始值"></a>设置初始值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private T setInitialValue() &#123;</span><br><span class="line">  T value = initialValue();</span><br><span class="line">  Thread t = Thread.currentThread();</span><br><span class="line">  ThreadLocalMap map = getMap(t);</span><br><span class="line">  if (map != null)</span><br><span class="line">    map.set(this, value);</span><br><span class="line">  else</span><br><span class="line">    createMap(t, value);</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法为 private 方法，无法被重载。</p><p>首先，通过initialValue()方法获取初始值。该方法为public方法，且默认返回null。所以典型用法中常常重载该方法。上例中即在内部匿名类中将其重载。</p><p>然后拿到该线程对应的 ThreadLocalMap 对象，若该对象不为 null，则直接将该 ThreadLocal 对象与对应实例初始值的映射添加进该线程的 ThreadLocalMap中。若为 null，则先创建该 ThreadLocalMap 对象再将映射添加其中。</p><p>这里并不需要考虑 ThreadLocalMap 的线程安全问题。因为每个线程有且只有一个 ThreadLocalMap 对象，并且只有该线程自己可以访问它，其它线程不会访问该 ThreadLocalMap，也即该对象不会在多个线程中共享，也就不存在线程安全的问题。</p><h4 id="设置实例"><a href="#设置实例" class="headerlink" title="设置实例"></a>设置实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">  Thread t = Thread.currentThread();</span><br><span class="line">  ThreadLocalMap map = getMap(t);</span><br><span class="line">  if (map != null)</span><br><span class="line">    map.set(this, value);</span><br><span class="line">  else</span><br><span class="line">    createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法先获取该线程的 ThreadLocalMap 对象，然后直接将 ThreadLocal 对象（即代码中的 this）与目标实例的映射添加进 ThreadLocalMap 中。当然，如果映射已经存在，就直接覆盖。另外，如果获取到的 ThreadLocalMap 为 null，则先创建该 ThreadLocalMap 对象。</p><h4 id="防止内存泄漏"><a href="#防止内存泄漏" class="headerlink" title="防止内存泄漏"></a>防止内存泄漏</h4><p>对于已经不再被使用且已被回收的 ThreadLocal 对象，它在每个线程内对应的实例由于被线程的 ThreadLocalMap 的 Entry 强引用，无法被回收，可能会造成内存泄漏。</p><p>针对该问题，ThreadLocalMap 的 set 方法中，通过 replaceStaleEntry 方法将所有键为 null 的 Entry 的值设置为 null，从而使得该值可被回收。另外，会在 rehash 方法中通过 expungeStaleEntry 方法将键和值为 null 的 Entry 设置为 null 从而使得该 Entry 可被回收。通过这种方式，ThreadLocal 可防止内存泄漏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line">  Entry[] tab = table;</span><br><span class="line">  int len = tab.length;</span><br><span class="line">  int i = key.threadLocalHashCode &amp; (len-1);</span><br><span class="line">  for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">    if (k == key) &#123;</span><br><span class="line">      e.value = value;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (k == null) &#123;</span><br><span class="line">      replaceStaleEntry(key, value, i);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  tab[i] = new Entry(key, value);</span><br><span class="line">  int sz = ++size;</span><br><span class="line">  if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal的应用场景"><a href="#ThreadLocal的应用场景" class="headerlink" title="ThreadLocal的应用场景"></a>ThreadLocal的应用场景</h2><p>ThreadLocal适用于以下两种场景：</p><ul><li>每个线程需要有自己单独的实例</li><li>实例需要在多个方法中共享，但不希望被多线程共享</li></ul><p>最常见的ThreadLocal使用场景为用来解决数据库连接、Session管理等</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>ThreadLocal 并不解决线程间共享数据的问题</li><li>ThreadLocal 通过隐式的在不同线程内创建独立实例副本避免了实例线程安全的问题</li><li>每个线程持有一个 Map 并维护了 ThreadLocal 对象与具体实例的映射，该 Map 由于只被持有它的线程访问，故不存在线程安全以及锁的问题</li><li>ThreadLocalMap 的 Entry 对 ThreadLocal 的引用为弱引用，避免了 ThreadLocal 对象无法被回收的问题</li><li>ThreadLocalMap 的 set 方法通过调用 replaceStaleEntry 方法回收键为 null 的 Entry 对象的值（即为具体实例）以及 Entry 对象本身从而防止内存泄漏</li><li>ThreadLocal 适用于变量在线程间隔离且在方法间共享的场景</li></ul>]]></content>
    
    <summary type="html">
    
      ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>当我们说线程安全时，到底在说什么</title>
    <link href="http://blog.linzhongtai.cn/2018/08/%E5%BD%93%E6%88%91%E4%BB%AC%E8%AF%B4%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%97%B6%EF%BC%8C%E5%88%B0%E5%BA%95%E5%9C%A8%E8%AF%B4%E4%BB%80%E4%B9%88/"/>
    <id>http://blog.linzhongtai.cn/2018/08/当我们说线程安全时，到底在说什么/</id>
    <published>2018-08-08T09:33:42.000Z</published>
    <updated>2018-08-08T09:33:42.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>本文转发自技术世界，原文链接　<a href="http://www.jasongj.com/java/thread_safe/" target="_blank" rel="noopener">http://www.jasongj.com/java/thread_safe/</a></p></blockquote><h2 id="多线程编程中的三个核心概念"><a href="#多线程编程中的三个核心概念" class="headerlink" title="多线程编程中的三个核心概念"></a>多线程编程中的三个核心概念</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>这一点，跟数据库事务的原子性概念差不多，即一个操作（有可能包含有多个子操作）要么全部执行（生效），要么全部都不执行（都不生效）。</p><p>关于原子性，一个非常经典的例子就是银行转账问题：比如A和B同时向C转账10万元。如果转账操作不具有原子性，A在向C转账时，读取了C的余额为20万，然后加上转账的10万，计算出此时应该有30万，但还未来及将30万写回C的账户，此时B的转账请求过来了，B发现C的余额为20万，然后将其加10万并写回。然后A的转账操作继续——将30万写回C的余额。这种情况下C的最终余额为30万，而非预期的40万。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>可见性是指，当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。可见性问题是好多人忽略或者理解错误的一点。</p><p>CPU从主内存中读数据的效率相对来说不高，现在主流的计算机中，都有几级缓存。每个线程读取共享变量时，都会将该变量加载进其对应CPU的高速缓存里，修改该变量后，CPU会立即更新该缓存，但并不一定会立即将其写回主内存（实际上写回主内存的时间不可预期）。此时其它线程（尤其是不在同一个CPU上执行的线程）访问该变量时，从主内存中读到的就是旧的数据，而非第一个线程更新后的数据。</p><p>这一点是操作系统或者说是硬件层面的机制，所以很多应用开发人员经常会忽略。</p><h3 id="顺序性"><a href="#顺序性" class="headerlink" title="顺序性"></a>顺序性</h3><p>顺序性指的是，程序执行的顺序按照代码的先后顺序执行。</p><p>以下面这段代码为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">boolean started = false; // 语句1</span><br><span class="line">long counter = 0L; // 语句2</span><br><span class="line">counter = 1; // 语句3</span><br><span class="line">started = true; // 语句4</span><br></pre></td></tr></table></figure><p>从代码顺序上看，上面四条语句应该依次执行，但实际上JVM真正在执行这段代码时，并不保证它们一定完全按照此顺序执行。</p><p>处理器为了提高程序整体的执行效率，可能会对代码进行优化，其中的一项优化方式就是调整代码顺序，按照更高效的顺序执行代码。</p><p>讲到这里，有人要着急了——什么，CPU不按照我的代码顺序执行代码，那怎么保证得到我们想要的效果呢？实际上，大家大可放心，CPU虽然并不保证完全按照代码顺序执行，但它会保证程序最终的执行结果和代码顺序执行时的结果一致。</p><h2 id="Java如何解决多线程并发问题"><a href="#Java如何解决多线程并发问题" class="headerlink" title="Java如何解决多线程并发问题"></a>Java如何解决多线程并发问题</h2><h3 id="Java如何保证原子性"><a href="#Java如何保证原子性" class="headerlink" title="Java如何保证原子性"></a>Java如何保证原子性</h3><h4 id="锁和同步"><a href="#锁和同步" class="headerlink" title="锁和同步"></a>锁和同步</h4><p>常用的保证Java操作原子性的工具是锁和同步方法（或者同步代码块）。使用锁，可以保证同一时间只有一个线程能拿到锁，也就保证了同一时间只有一个线程能执行申请锁和释放锁之间的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void testLock () &#123;</span><br><span class="line">  lock.lock();</span><br><span class="line">  try&#123;</span><br><span class="line">    int j = i;</span><br><span class="line">    i = j + 1;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与锁类似的是同步方法或者同步代码块。使用非静态同步方法时，锁住的是当前实例；使用静态同步方法时，锁住的是该类的Class对象；使用静态代码块时，锁住的是synchronized关键字后面括号内的对象。下面是同步代码块示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void testLock () &#123;</span><br><span class="line">  synchronized (anyObject)&#123;</span><br><span class="line">    int j = i;</span><br><span class="line">    i = j + 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论使用锁还是synchronized，本质都是一样，通过锁来实现资源的排它性，从而实际目标代码段同一时间只会被一个线程执行，进而保证了目标代码段的原子性。这是一种以牺牲性能为代价的方法。</p><h4 id="CAS（compare-and-swap）"><a href="#CAS（compare-and-swap）" class="headerlink" title="CAS（compare and swap）"></a>CAS（compare and swap）</h4><p>基础类型变量自增（i++）是一种常被新手误以为是原子操作而实际不是的操作。Java中提供了对应的原子操作类来实现该操作，并保证原子性，其本质是利用了CPU级别的CAS指令。由于是CPU级别的指令，其开销比需要操作系统参与的锁的开销小。AtomicInteger使用方法如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger atomicInteger = new AtomicInteger();</span><br><span class="line">for(int b = 0; b &lt; numThreads; b++) &#123;</span><br><span class="line">  new Thread(() -&gt; &#123;</span><br><span class="line">    for(int a = 0; a &lt; iteration; a++) &#123;</span><br><span class="line">      atomicInteger.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java如何保证可见性"><a href="#Java如何保证可见性" class="headerlink" title="Java如何保证可见性"></a>Java如何保证可见性</h3><p>Java提供了volatile关键字来保证可见性。当使用volatile修饰某个变量时，它会保证对该变量的修改会立即被更新到内存中，并且将其它缓存中对该变量的缓存设置成无效，因此其它线程需要读取该值时必须从主内存中读取，从而得到最新的值。</p><h3 id="Java如何保证顺序性"><a href="#Java如何保证顺序性" class="headerlink" title="Java如何保证顺序性"></a>Java如何保证顺序性</h3><p>上文讲过编译器和处理器对指令进行重新排序时，会保证重新排序后的执行结果和代码顺序执行的结果一致，所以重新排序过程并不会影响单线程程序的执行，却可能影响多线程程序并发执行的正确性。</p><p>Java中可通过volatile在一定程序上保证顺序性，另外还可以通过synchronized和锁来保证顺序性。</p><p>synchronized和锁保证顺序性的原理和保证原子性一样，都是通过保证同一时间只会有一个线程执行目标代码段来实现的。</p><p>除了从应用层面保证目标代码段执行的顺序性外，JVM还通过被称为happens-before原则隐式地保证顺序性。两个操作的执行顺序只要可以通过happens-before推导出来，则JVM会保证其顺序性，反之JVM对其顺序性不作任何保证，可对其进行任意必要的重新排序以获取高效率。</p><h3 id="happens-before原则（先行发生原则）"><a href="#happens-before原则（先行发生原则）" class="headerlink" title="happens-before原则（先行发生原则）"></a>happens-before原则（先行发生原则）</h3><ul><li>传递规则：如果操作1在操作2前面，而操作2在操作3前面，则操作1肯定会在操作3前发生。该规则说明了happens-before原则具有传递性</li><li>锁定规则：一个unlock操作肯定会在后面对同一个锁的lock操作前发生。这个很好理解，锁只有被释放了才会被再次获取</li><li>volatile变量规则：对一个被volatile修饰的写操作先发生于后面对该变量的读操作</li><li>程序次序规则：一个线程内，按照代码顺序执行</li><li>线程启动规则：Thread对象的start()方法先发生于此线程的其它动作</li><li>线程终结原则：线程的终止检测后发生于线程中其它的所有操作</li><li>线程中断规则： 对线程interrupt()方法的调用先发生于对该中断异常的获取</li><li>对象终结规则：一个对象构造先于它的finalize发生</li></ul><h2 id="volatile适用场景"><a href="#volatile适用场景" class="headerlink" title="volatile适用场景"></a>volatile适用场景</h2><p>volatile适用于不需要保证原子性，但却需要保证可见性的场景。一种典型的使用场景是用它修饰用于停止线程的状态标记。如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">boolean isRunning = false;</span><br><span class="line">public void start () &#123;</span><br><span class="line">  new Thread( () -&gt; &#123;</span><br><span class="line">    while(isRunning) &#123;</span><br><span class="line">      someOperation();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">public void stop () &#123;</span><br><span class="line">  isRunning = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种实现方式下，即使其它线程通过调用stop()方法将isRunning设置为false，循环也不一定会立即结束。可以通过volatile关键字，保证while循环及时得到isRunning最新的状态从而及时停止循环，结束线程。</p><h2 id="线程安全十万个为什么"><a href="#线程安全十万个为什么" class="headerlink" title="线程安全十万个为什么"></a>线程安全十万个为什么</h2><p>问：平时项目中使用锁和synchronized比较多，而很少使用volatile，难道就没有保证可见性？<br>答：锁和synchronized即可以保证原子性，也可以保证可见性。都是通过保证同一时间只有一个线程执行目标代码段来实现的。</p><p>问：锁和synchronized为何能保证可见性？<br>答：根据JDK 7的Java doc中对concurrent包的说明，一个线程的写结果保证对另外线程的读操作可见，只要该写操作可以由happen-before原则推断出在读操作之前发生。</p><p>The results of a write by one thread are guaranteed to be visible to a read by another thread only if the write operation happens-before the read operation. The synchronized and volatile constructs, as well as the Thread.start() and Thread.join() methods, can form happens-before relationships.</p><p>问：既然锁和synchronized即可保证原子性也可保证可见性，为何还需要volatile？<br>答：synchronized和锁需要通过操作系统来仲裁谁获得锁，开销比较高，而volatile开销小很多。因此在只需要保证可见性的条件下，使用volatile的性能要比使用锁和synchronized高得多。</p><p>问：既然锁和synchronized可以保证原子性，为什么还需要AtomicInteger这种的类来保证原子操作？<br>答：锁和synchronized需要通过操作系统来仲裁谁获得锁，开销比较高，而AtomicInteger是通过CPU级的CAS操作来保证原子性，开销比较小。所以使用AtomicInteger的目的还是为了提高性能。</p><p>问：还有没有别的办法保证线程安全？<br>答：有。尽可能避免引起非线程安全的条件——共享变量。如果能从设计上避免共享变量的使用，即可避免非线程安全的发生，也就无须通过锁或者synchronized以及volatile解决原子性、可见性和顺序性的问题。</p><p>问：synchronized即可修饰非静态方式，也可修饰静态方法，还可修饰代码块，有何区别？<br>答：synchronized修饰非静态同步方法时，锁住的是当前实例；synchronized修饰静态同步方法时，锁住的是该类的Class对象；synchronized修饰静态代码块时，锁住的是synchronized关键字后面括号内的对象。</p>]]></content>
    
    <summary type="html">
    
      原子性/可见性/顺序性......
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>HashMap的ReHash图解</title>
    <link href="http://blog.linzhongtai.cn/2018/07/HashMap%E7%9A%84ReHash%E5%9B%BE%E8%A7%A3/"/>
    <id>http://blog.linzhongtai.cn/2018/07/HashMap的ReHash图解/</id>
    <published>2018-07-20T09:30:57.000Z</published>
    <updated>2018-07-20T09:30:57.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><ul><li>resize方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void resize(intnewCapacity)</span><br><span class="line">&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    intoldCapacity = oldTable.length;</span><br><span class="line">    ......</span><br><span class="line">    //创建一个新的Hash Table</span><br><span class="line">    Entry[] newTable =new Entry[newCapacity];</span><br><span class="line">    //将Old Hash Table上的数据迁移到New Hash Table上</span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (int)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>transfer方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] newTable)</span><br><span class="line">&#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    intnewCapacity = newTable.length;</span><br><span class="line">    //下面这段代码的意思是：</span><br><span class="line">    //  从OldTable里摘一个元素出来，然后放到NewTable中</span><br><span class="line">    for(intj = 0; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        if(e != null) &#123;</span><br><span class="line">            src[j] =null;</span><br><span class="line">            do&#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                inti = indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125;while (e != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单线程下的ReHash"><a href="#单线程下的ReHash" class="headerlink" title="单线程下的ReHash"></a>单线程下的ReHash</h2><ul><li>用key mod 一下表的大小（也就是数组的长度）。</li><li>最上面的是old hash 表，其中的Hash表的size=2, 所以key = 3, 7, 5，在mod 2以后都冲突在table[1]这里了。</li><li>接下来的三个步骤是Hash表 resize成4，然后所有的&lt;key,value&gt; 重新rehash的过程</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/5937589-5a476e5b596cbb98.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>详细描述可以看下面这张图：</p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-9731276c6b9937dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="并发下的Rehash"><a href="#并发下的Rehash" class="headerlink" title="并发下的Rehash"></a>并发下的Rehash</h2><ol><li>假设我们有两个线程。我用红色和浅蓝色标注了一下。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">    Entry&lt;K,V&gt; next = e.next;// &lt;--假设线程一执行到这里就被调度挂起了</span><br><span class="line">    inti = indexFor(e.hash, newCapacity);</span><br><span class="line">    e.next = newTable[i];</span><br><span class="line">    newTable[i] = e;</span><br><span class="line">    e = next;</span><br><span class="line">&#125;while (e != null);</span><br></pre></td></tr></table></figure><p>而我们的线程二执行完成了。于是我们有下面的这个样子。</p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-1a6fd03cdcee139e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>注意，因为Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。我们可以看到链表的顺序被反转后。</p><ol start="2"><li>线程一被调度回来执行。</li></ol><ul><li>先是执行 newTalbe[i] = e;</li><li>然后是e = next，导致了e指向了key(7)，</li><li>而下一次循环的next = e.next导致了next指向了key(3)</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/5937589-63a70821341b4cb2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><ol start="3"><li>线程一继续执行</li></ol><p>把key(7)摘下来，放到newTable[i]的第一个，然后把e和next往下移</p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-ee96974bcac48192.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><ol start="4"><li>环形链接出现</li></ol><p>e.next = newTable[i] 导致  key(3).next 指向了 key(7)<br>注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-508820052916f668.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>当我们的线程一调用到HashTable.get(11)时，悲剧就出现了——Infinite Loop</p>]]></content>
    
    <summary type="html">
    
      HashMap的ReHash
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>缓存与数据库一致性之缓存更新设计</title>
    <link href="http://blog.linzhongtai.cn/2018/06/%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7%E4%B9%8B%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E8%AE%BE%E8%AE%A1/"/>
    <id>http://blog.linzhongtai.cn/2018/06/缓存与数据库一致性之缓存更新设计/</id>
    <published>2018-06-25T09:28:02.000Z</published>
    <updated>2018-06-25T09:28:02.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="缓存更新场景介绍"><a href="#缓存更新场景介绍" class="headerlink" title="缓存更新场景介绍"></a>缓存更新场景介绍</h2><p>缓存是一种提高系统读性能的常见技术，对于读多写少的应用场景，我们经常使用缓存来进行优化.</p><p>例如对于用户的余额信息表account(uid, money)，业务上的需求是：</p><p>（1）查询用户的余额，SELECT money FROM account WHERE uid=XXX，占99%的请求</p><p>（2）更改用户余额，UPDATE account SET money=XXX WHERE uid=XXX，占1%的请求</p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-6ed7ba23bc14ce22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>由于大部分的请求是查询，我们在缓存中建立uid到money的键值对，能够极大降低数据库的压力。</p><h3 id="读操作流程"><a href="#读操作流程" class="headerlink" title="读操作流程"></a>读操作流程</h3><p>有了数据库和缓存两个地方存放数据之后（uid-&gt;money），每当需要读取相关数据时（money），操作流程一般是这样的：<br>（1）读取缓存中是否有相关数据，uid-&gt;money<br>（2）如果缓存中有相关数据money，则返回【这就是所谓的数据命中“hit”】<br>（3）如果缓存中没有相关数据money，则从数据库读取相关数据money【这就是所谓的数据未命中“miss”】，放入缓存中uid-&gt;money，再返回缓存的命中率 = 命中缓存请求个数/总缓存访问请求个数 = hit/(hit+miss)上面举例的余额场景，99%的读，1%的写，这个缓存的命中率是非常高的，会在95%以上。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>当数据money发生变化的时候：<br>（1）是更新缓存中的数据，还是淘汰缓存中的数据呢？<br>（2）是先操纵数据库中的数据再操纵缓存中的数据，还是先操纵缓存中的数据再操纵数据库中的数据呢？<br>（3）缓存与数据库的操作，在架构上是否有优化的空间呢？</p><h2 id="更新缓存-VS-淘汰缓存"><a href="#更新缓存-VS-淘汰缓存" class="headerlink" title="更新缓存 VS 淘汰缓存"></a>更新缓存 VS 淘汰缓存</h2><ul><li><p>更新缓存：数据不但写入数据库，还会写入缓存<br>优点：缓存不会增加一次miss，命中率高</p></li><li><p>淘汰缓存：数据只会写入数据库，不会写入缓存，只会把数据淘汰掉<br>优点：简单</p></li></ul><p>那到底是选择更新缓存还是淘汰缓存呢？<strong>主要取决于“更新缓存的复杂度”。</strong></p><p>例如，上述场景，只是简单的把余额money设置成一个值，那么：<br>（1）淘汰缓存的操作为deleteCache(uid)<br>（2）更新缓存的操作为setCache(uid, money)<br>更新缓存的代价很小，此时我们应该更倾向于更新缓存，以保证更高的缓存命中率。<br>如果余额是通过很复杂的数据计算得出来的，更新缓存的代价很大，此时我们应该更倾向于淘汰缓存。<br><strong>淘汰缓存操作简单，并且带来的副作用只是增加了一次cache miss，建议作为通用的处理方式。</strong></p><h2 id="先操作数据库-vs-先操作缓存"><a href="#先操作数据库-vs-先操作缓存" class="headerlink" title="先操作数据库 vs 先操作缓存"></a>先操作数据库 vs 先操作缓存</h2><p>当写操作发生时，假设淘汰缓存作为对缓存通用的处理方式，又面临两种抉择：<br>（1）先写数据库，再淘汰缓存<br>（2）先淘汰缓存，再写数据库</p><p>对于一个不能保证事务性的操作，一定涉及“哪个任务先做，哪个任务后做”的问题，解决这个问题的方向是：<br><strong>如果出现不一致，谁先做对业务的影响较小，就谁先执行。</strong><br>由于写数据库与淘汰缓存不能保证原子性，谁先谁后同样要遵循上述原则。</p><ul><li><strong>假设先写数据库，再淘汰缓存</strong><br>第一步写数据库操作成功，第二步淘汰缓存失败，则会出现DB中是新数据，Cache中是旧数据，数据不一致。<br><img src="http://upload-images.jianshu.io/upload_images/5937589-046e99f7e1f7ddad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li><li><strong>假设先淘汰缓存，再写数据库</strong><br>第一步淘汰缓存成功，第二步写数据库失败，则只会引发一次Cache miss。</li></ul><blockquote><p><strong>结论：数据和缓存的操作时序，结论是清楚的：先淘汰缓存，再写数据库。</strong></p></blockquote><h2 id="缓存架构优化"><a href="#缓存架构优化" class="headerlink" title="缓存架构优化"></a>缓存架构优化</h2><p><img src="http://upload-images.jianshu.io/upload_images/5937589-9b00c88b809a05f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>上述缓存架构有一个缺点：业务方需要同时关注缓存与DB，有没有进一步的优化空间呢？有两种常见的方案，一种主流方案(服务化)，一种非主流方案（异步缓存更新）</p><h3 id="服务化"><a href="#服务化" class="headerlink" title="服务化"></a>服务化</h3><p>加入一个服务层，向上游提供帅气的数据访问接口，向上游屏蔽底层数据存储的细节，这样业务线不需要关注数据是来自于cache还是DB</p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-e390cf4a5779b2e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="异步缓存更新"><a href="#异步缓存更新" class="headerlink" title="异步缓存更新"></a>异步缓存更新</h3><p>业务线所有的写操作都走数据库，所有的读操作都总缓存，由一个异步的工具来做数据库与缓存之间数据的同步</p><ol><li>要有一个init cache的过程，将需要缓存的数据全量写入cache</li><li>如果DB有写操作，异步更新程序读取binlog，更新cache</li></ol><p>在（1）和（2）的合作下，cache中有全部的数据，这样：<br>（a）业务线读cache，一定能够hit（很短的时间内，可能有脏数据），无需关注数据库<br>（b）业务线写DB，cache中能得到异步更新，无需关注缓存</p><blockquote><p>将大大简化业务线的调用逻辑，存在的缺点是，如果缓存的数据业务逻辑比较复杂，async-update异步更新的逻辑可能也会比较复杂</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>淘汰缓存是一种通用的缓存处理方式</li><li>先淘汰缓存，再写数据库的时序是毋庸置疑的</li><li>服务化是向业务方屏蔽底层数据库与缓存复杂性的一种通用方式</li></ol><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>我们在项目中使用缓存通常都是先检查缓存中是否存在，如果存在直接返回缓存内容，如果不存在就直接查询数据库然后再缓存查询结果返回。<br>这个时候如果我们查询的某一个数据在缓存中一直不存在，就会造成每一次请求都查询DB，这样缓存就失去了意义，在流量大时，可能DB就挂掉了。<br>要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。</p><p><strong>解决方案：</strong><br>（1）缓存空对象，设置短暂的过期时间<br>（2）布隆过滤器拦截</p><p>有一个比较巧妙的作法是，可以将这个不存在的key预先设定一个值，比如，”key” , “&amp;&amp;”。在返回这个&amp;&amp;值的时候，我们的应用就可以认为这是不存在的key，那我们的应用就可以决定是否继续等待继续访问，还是放弃掉这次操作。如果继续等待访问，过一个时间轮询点后，再次请求这个key，如果取到的值不再是&amp;&amp;，则可以认为这时候key有值了，从而避免了透传到数据库，从而把大量的类似请求挡在了缓存之中。</p><h3 id="缓存并发-缓存击穿"><a href="#缓存并发-缓存击穿" class="headerlink" title="缓存并发-缓存击穿"></a>缓存并发-缓存击穿</h3><p>有时候如果网站并发访问高，一个缓存如果失效，可能出现多个进程同时查询DB，同时设置缓存的情况，如果并发确实很大，这也可能造成DB压力过大，还有缓存频繁更新的问题。</p><p><strong>解决方案：</strong><br>锁、互斥锁</p><h3 id="缓存失效-缓存雪崩"><a href="#缓存失效-缓存雪崩" class="headerlink" title="缓存失效-缓存雪崩"></a>缓存失效-缓存雪崩</h3><p>引起这个问题的主要原因还是高并发的时候，平时我们设定一个缓存的过期时间时，可能有一些会设置1分钟啊，5分钟这些，并发很高时可能会出在某一个时间同时生成了很多的缓存，并且过期时间都一样，这个时候就可能引发一当过期时间到后，这些缓存同时失效，请求全部转发到DB，DB可能会压力过重。</p><p><strong>解决方案：</strong><br>随机过期时间，降低过期时间的重复率</p>]]></content>
    
    <summary type="html">
    
      先更新缓存中的数据，还是淘汰缓存中的数据呢
    
    </summary>
    
      <category term="缓存" scheme="http://blog.linzhongtai.cn/categories/%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="缓存" scheme="http://blog.linzhongtai.cn/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构</title>
    <link href="http://blog.linzhongtai.cn/2018/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://blog.linzhongtai.cn/2018/06/Redis底层数据结构/</id>
    <published>2018-06-22T09:20:40.000Z</published>
    <updated>2018-06-22T09:20:40.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="Redis底层数据结构类型"><a href="#Redis底层数据结构类型" class="headerlink" title="Redis底层数据结构类型"></a>Redis底层数据结构类型</h2><h3 id="简单动态字符串（simple-dynamic-string）SDS"><a href="#简单动态字符串（simple-dynamic-string）SDS" class="headerlink" title="简单动态字符串（simple dynamic string）SDS"></a>简单动态字符串（simple dynamic string）SDS</h3><blockquote><p>Redis 没有直接使用C语言传统的字符串表示，而是自己构建了一种名为简单动态字符串（simple dynamic string SDS）的抽象类型，并将SDS用作Redis 的默认字符串表示;<br>除了用来保存字符串以外，SDS还被用作缓冲区（buffer）AOF(<a href="http://blog.linzhongtai.cn/2018/05/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/">持久化</a>)模块中的AOF缓冲区</p></blockquote><h4 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h4><blockquote><p>区别于C语言字符串，具有良好的伸缩性，在获取字符串长度，字符串修改，防止缓存区溢出等性能都比C语言字符串好</p></blockquote><p>Redis 中定义动态字符串的结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*  </span><br><span class="line"> * 保存字符串对象的结构  </span><br><span class="line"> */  </span><br><span class="line">struct sdshdr &#123;  </span><br><span class="line">      </span><br><span class="line">    // buf 中已占用空间的长度  </span><br><span class="line">    int len;  </span><br><span class="line">  </span><br><span class="line">    // buf 中剩余可用空间的长度(初次分配空间，一般没有空余，在对字符串修改的时候，会有剩余空间出现)-预分配  </span><br><span class="line">    int free;  </span><br><span class="line">  </span><br><span class="line">    // 数据空间  </span><br><span class="line">    char buf[];  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="SDS-与-C-字符串的区别"><a href="#SDS-与-C-字符串的区别" class="headerlink" title="SDS 与 C 字符串的区别"></a>SDS 与 C 字符串的区别</h4><ul><li>获取字符串长度（<strong>SDS O（1）/C 字符串 O(n)</strong>）<br>  <strong>传统的C字符串</strong>: 使用长度为N+1 的字符串数组来表示长度为N 的字符串，所以为了获取一个长度为C字符串的长度，必须遍历整个字符串。<br>  <strong>SDS</strong>：SDS 的数据结构中，有专门用于保存字符串长度的变量，我们可以通过获取len 属性的值，直接知道字符串长度</li></ul><h4 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h4><blockquote><p>C 字符串 不记录字符串长度，除了获取的时候复杂度高以外，还容易忘了为字符串重新分配足够的空间，从而导致缓冲区溢出</p></blockquote><p> Redis 中SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性：<br> 当我们需要对一个SDS进行修改的时候，redis会在执行拼接操作之前，预先检查给定SDS空间是否足够，如果不够，会先拓展SDS 的空间，然后再执行拼接操作</p><h4 id="减少修改字符串时带来的内存重分配次数"><a href="#减少修改字符串时带来的内存重分配次数" class="headerlink" title="减少修改字符串时带来的内存重分配次数"></a>减少修改字符串时带来的内存重分配次数</h4><blockquote><p>C语言字符串在进行字符串的扩充和收缩的时候，都会面临着内存空间的重新分配问题</p></blockquote><ol><li>字符串拼接会产生字符串的内存空间的扩充，在拼接的过程中，原来的字符串的大小很可能小于拼接后的字符串的大小，那么这样的话，就会导致一旦忘记申请分配空间，就会导致内存的溢出。</li><li>字符串在进行收缩的时候，内存空间会相应的收缩，而如果在进行字符串的切割的时候，没有对内存的空间进行一个重新分配，那么这部分多出来的空间就成为了内存泄露</li></ol><p><strong>SDS</strong>：对SDS进行拓展，则需要进行空间的拓展，这时候redis 会将SDS的长度修改为N字节，并且将未使用空间同样修改为N字节，此时如果再次进行修改，因为在上一次修改字符串的时候已经拓展了空间，再次进行修改字符串的时候如果发现空间足够使用，因此无须进行空间拓展<br><strong>通过这种预分配策略，SDS将连续增长N次字符串所需的内存重分配次数从必定N次降低为最多N次</strong></p><h4 id="惰性空间释放"><a href="#惰性空间释放" class="headerlink" title="惰性空间释放"></a>惰性空间释放</h4><p>SDS 提供了相应的API，让我们可以在有需要的时候，自行释放SDS的空余空间<br>通过惰性空间释放，SDS避免了缩短字符串时所需的内存重分配操作，并未将来可能有的增长操作提供了优化</p><h4 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h4><ul><li><p>C 字符串中的字符必须符合某种编码，并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存想图片，音频，视频，压缩文件这样的二进制数据</p></li><li><p>在Redis中，不是靠空字符来判断字符串的结束的，而是通过len这个属性。那么，即便是中间出现了空字符对于SDS来说，读取该字符仍然是可以的</p></li></ul><h4 id="兼容部分C字符串函数"><a href="#兼容部分C字符串函数" class="headerlink" title="兼容部分C字符串函数"></a>兼容部分C字符串函数</h4><p>虽然SDS 的API 都是二进制安全的，但他们一样遵循C字符串以空字符串结尾的惯例</p><h4 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h4><table><thead><tr><th style="text-align:center">C 字符串</th><th style="text-align:center">SDS</th></tr></thead><tbody><tr><td style="text-align:center">获取字符串长度的复杂度为O（N)</td><td style="text-align:center">获取字符串长度的复杂度为O(1)</td></tr><tr><td style="text-align:center">API 是不安全的，可能会造成缓冲区溢出</td><td style="text-align:center">API 是安全的，不会造成缓冲区溢出</td></tr><tr><td style="text-align:center">修改字符串长度N次必然需要执行N次内存重分配</td><td style="text-align:center">修改字符串长度N次最多执行N次内存重分配</td></tr><tr><td style="text-align:center">只能保存文本数据</td><td style="text-align:center">可以保存二进制数据和文本文数据</td></tr><tr><td style="text-align:center">可以使用所有&lt;String.h&gt;库中的函数</td><td style="text-align:center">可以使用一部分&lt;string.h&gt;库中的函数</td></tr></tbody></table><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><blockquote><p><strong>顺序存储对象信息，有用于缓存链表长度的属性，在插入删除对象功能中有良好性能，避免环的产生</strong></p></blockquote><blockquote><p>链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。链表在Redis 中的应用非常广泛，比如<strong>列表键的底层实现之一就是链表</strong>。当一个列表键包含了数量较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis 就会使用链表作为列表键的底层实现。</p></blockquote><h4 id="链表的数据结构"><a href="#链表的数据结构" class="headerlink" title="链表的数据结构"></a>链表的数据结构</h4><p>每个链表节点使用一个 listNode结构表示（adlist.h/listNode）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct listNode&#123;</span><br><span class="line">      struct listNode *prev;</span><br><span class="line">      struct listNode * next;</span><br><span class="line">      void * value;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>多个链表节点组成的双端链表：<br><img src="http://upload-images.jianshu.io/upload_images/5937589-919359a5901757d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>通过直接操作list 来操作链表会更加方便:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct list&#123;</span><br><span class="line">    //表头节点</span><br><span class="line">    listNode  * head;</span><br><span class="line">    //表尾节点</span><br><span class="line">    listNode  * tail;</span><br><span class="line">    //链表长度</span><br><span class="line">    unsigned long len;</span><br><span class="line">    //节点值复制函数</span><br><span class="line">    void *(*dup) (void *ptr);</span><br><span class="line">    //节点值释放函数</span><br><span class="line">    void (*free) (void *ptr);</span><br><span class="line">    //节点值对比函数</span><br><span class="line">    int (*match)(void *ptr, void *key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>dup 函数用于复制链表节点所保存的值；</li><li>free 函数用于释放链表节点所保存的值；</li><li>match 函数则用于对比链表节点所保存的值和另一个输入值是否相等。<br>list 组成的结构图：<br><img src="http://upload-images.jianshu.io/upload_images/5937589-a0fe4b6fd64e90e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li></ul><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>双端：链表节点带有prev 和next 指针，获取某个节点的前置节点和后置节点的时间复杂度都是O（N）</li><li>无环：表头节点的 prev 指针和表尾节点的next 都指向NULL，对立案表的访问时以NULL为截止</li><li>表头和表尾：因为链表带有head指针和tail 指针，程序获取链表头结点和尾节点的时间复杂度为O(1)</li><li>长度计数器：链表中存有记录链表长度的属性 len</li><li>多态：链表节点使用 void* 指针来保存节点值，并且可以通过list 结构的dup 、 free、 match三个属性为节点值设置类型特定函数。</li></ul><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><blockquote><p><strong>key-value 存储方式，通过hash值计算，判断key的存储，当容量过大，会通过rehash重新分配字典大小</strong></p></blockquote><blockquote><p>字典，又称为符号表（symbol table）、关联数组（associative array）或映射（map），是一种用于保存键值对的抽象数据结构。<br>在字典中，一个键（key）可以和一个值（value）进行关联，字典中的每个键都是独一无二的。在C语言中，并没有这种数据结构，但是Redis 中构建了自己的字典实现</p></blockquote><h4 id="字典的定义"><a href="#字典的定义" class="headerlink" title="字典的定义"></a>字典的定义</h4><ol><li>哈希表<br>Redis 字典所使用的哈希表由 dict.h/dictht 结构定义：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictht &#123;</span><br><span class="line">   //哈希表数组</span><br><span class="line">   dictEntry **table;</span><br><span class="line">   //哈希表大小</span><br><span class="line">   unsigned long size;</span><br><span class="line"></span><br><span class="line">   //哈希表大小掩码，用于计算索引值</span><br><span class="line">   unsigned long sizemask;</span><br><span class="line">   //该哈希表已有节点的数量</span><br><span class="line">   unsigned long used;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>一个空的字典的结构图如下：<br><img src="http://upload-images.jianshu.io/upload_images/5937589-c140f7cef2dc39a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>可以看到，在结构中存有指向dictEntry 数组的指针，而我们用来存储数据的空间既是dictEntry</p><ol start="2"><li>哈希表节点（ dictEntry ）<br>dictEntry 结构定义：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typeof struct dictEntry&#123;</span><br><span class="line">   //键</span><br><span class="line">   void *key;</span><br><span class="line">   //值</span><br><span class="line">   union&#123;</span><br><span class="line">      void *val;</span><br><span class="line">      uint64_tu64;</span><br><span class="line">      int64_ts64;</span><br><span class="line">   &#125;</span><br><span class="line">   struct dictEntry *next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在数据结构中，我们清楚key 是唯一的，但是我们存入里面的key 并不是直接的字符串，而是一个hash 值，通过hash 算法，将字符串转换成对应的hash 值，然后在dictEntry 中找到对应的位置。<br>这时候我们会发现一个问题，如果出现hash 值相同的情况怎么办？Redis 采用了链地址法：<br><img src="http://upload-images.jianshu.io/upload_images/5937589-b8c796e3bf89ab8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>当k1 和k0 的hash 值相同时，将k1中的next 指向k0 想成一个链表。</p><ol start="3"><li>字典<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dict &#123;</span><br><span class="line">    // 类型特定函数</span><br><span class="line">    dictType *type;</span><br><span class="line">    // 私有数据</span><br><span class="line">    void *privedata;</span><br><span class="line">    // 哈希表</span><br><span class="line">    dictht  ht[2];</span><br><span class="line">    // rehash 索引</span><br><span class="line">    in trehashidx;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>type 属性 和privdata 属性是针对不同类型的键值对，为创建多态字典而设置的。<br>ht 属性是一个包含两个项（两个哈希表）的数组</p><p>普通状态下的字典：<br><img src="http://upload-images.jianshu.io/upload_images/5937589-c8a06ee0e7857e24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h4 id="解决哈希冲突"><a href="#解决哈希冲突" class="headerlink" title="解决哈希冲突"></a>解决哈希冲突</h4><blockquote><p>在上述分析哈希节点的时候我们有讲到：在插入一条新的数据时，会进行哈希值的计算，如果出现了hash值相同的情况，Redis 中采用了连地址法（separate chaining）来解决键冲突。每个哈希表节点都有一个next 指针，多个哈希表节点可以使用next 构成一个单向链表，被分配到同一个索引上的多个节点可以使用这个单向链表连接起来解决hash值冲突的问题。</p></blockquote><p><strong>举个栗子：</strong><br>现在哈希表中有以下的数据：k0 和k1<br><img src="http://upload-images.jianshu.io/upload_images/5937589-f6f397286303a9fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>我们现在要插入k2，通过hash 算法计算到k2 的hash 值为2，即我们需要将k2 插入到dictEntry[2]中：</p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-29dba56d52905787.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>在插入后我们可以看到，dictEntry指向了k2，k2的next指向了k1，从而完成了一次插入操作（这里选择表头插入是因为哈希表节点中没有记录链表尾节点位置）</p><h4 id="Rehash"><a href="#Rehash" class="headerlink" title="Rehash"></a>Rehash</h4><blockquote><p>随着对哈希表的不断操作，哈希表保存的键值对会逐渐的发生改变，为了让哈希表的负载因子维持在一个合理的范围之内，我们需要对哈希表的大小进行相应的扩展或者压缩，这时候，我们可以通过 rehash（重新散列）操作来完成</p></blockquote><ol><li>目前的哈希表状态<br>我们可以看到，哈希表中的每个节点都已经使用到了，这时候我们需要对哈希表进行拓展<br><img src="http://upload-images.jianshu.io/upload_images/5937589-0bfcc5304648688b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li><li>为哈希表分配空间<br>哈希表空间分配规则：<br> 如果执行的是拓展操作，那么ht[1] 的大小为第一个大于等于ht[0] 的2的n次幂<br> 如果执行的是收缩操作，那么ht[1] 的大小为第一个大于等于ht[0] 的2的n次幂<br>因此这里我们为ht[1] 分配 空间为8，<br><img src="http://upload-images.jianshu.io/upload_images/5937589-511688a5cc08ff3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li><li>数据转移<br>将ht[0]中的数据转移到ht[1]中，在转移的过程中，需要对哈希表节点的数据重新进行哈希值计算<br>数据转移后的结果：<br><img src="http://upload-images.jianshu.io/upload_images/5937589-9426b397abe01e6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li><li>释放ht[0]<br>将ht[0]释放，然后将ht[1]设置成ht[0]，最后为ht[1]分配一个空白哈希表：<br><img src="http://upload-images.jianshu.io/upload_images/5937589-afa38b7543e6afc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li><li>渐进式 rehash<br>上面我们说到，在进行拓展或者压缩的时候，可以直接将所有的键值对rehash 到ht[1]中，这是因为数据量比较小。在实际开发过程中，这个rehash 操作并不是一次性、集中式完成的，而是分多次、渐进式地完成的。<br>渐进式rehash 的详细步骤：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、为ht[1] 分配空间，让字典同时持有ht[0]和ht[1]两个哈希表</span><br><span class="line">2、在几点钟维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash 开始</span><br><span class="line">3、在rehash 进行期间，每次对字典执行CRUD操作时，程序除了执行指定的操作以外，</span><br><span class="line">还会将ht[0]中的数据rehash 到ht[1]表中，并且将rehashidx加一</span><br><span class="line">4、当ht[0]中所有数据转移到ht[1]中时，将rehashidx 设置成-1，表示rehash 结束</span><br></pre></td></tr></table></figure></li></ol><p>采用渐进式rehash 的好处在于它采取分而治之的方式，避免了集中式rehash 带来的庞大计算量</p><blockquote><p><strong>哈希表的扩展与收缩</strong></p></blockquote><p><strong>当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1 ；</span><br><span class="line">服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5 ；</span><br></pre></td></tr></table></figure></p><p>其中哈希表的负载因子可以通过公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 负载因子 = 哈希表已保存节点数量 / 哈希表大小</span><br><span class="line">load_factor = ht[0].used / ht[0].size</span><br></pre></td></tr></table></figure></p><h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。跳跃表是一种随机化的数据,跳跃表以有序的方式在层次化的链表中保存元素，效率和平衡树媲美——查找、删除、添加等操作都可以在对数期望时间下完成，并且比起平衡树来说，跳跃表的实现要简单直观得多。</p><blockquote><p>Redis 只在两个地方用到了跳跃表，一个是<strong>实现有序集合键</strong>，另外一个是<strong>在集群节点中用作内部数据结构</strong></p></blockquote><h4 id="跳跃表的定义"><a href="#跳跃表的定义" class="headerlink" title="跳跃表的定义"></a>跳跃表的定义</h4><p>跳跃表的完整结构：<br><img src="http://upload-images.jianshu.io/upload_images/5937589-e7c686894349d1d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><center>Redis 的跳跃表 主要由两部分组成：zskiplist（链表）和zskiplistNode （节点）</center><ol><li>zskiplistNode（节点） 数据结构：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplistNode&#123;</span><br><span class="line">　　　//层</span><br><span class="line">     struct zskiplistLevel&#123;</span><br><span class="line">　　　　　//前进指针</span><br><span class="line">        struct zskiplistNode *forward;</span><br><span class="line">　　　　//跨度</span><br><span class="line">        unsigned int span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">　　//后退指针</span><br><span class="line">    struct zskiplistNode *backward;</span><br><span class="line">　　//分值</span><br><span class="line">    double score;</span><br><span class="line">　　//成员对象</span><br><span class="line">    robj *obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>层：level 数组可以包含多个元素，每个元素都包含一个指向其他节点的指针。</li><li>前进指针：用于指向表尾方向的前进指针</li><li>跨度：用于记录两个节点之间的距离</li><li>后退指针：用于从表尾向表头方向访问节点</li><li>分值和成员：跳跃表中的所有节点都按分值从小到大排序。成员对象指向一个字符串，这个字符串对象保存着一个SDS值</li></ul><ol start="2"><li>zskiplist 数据结构：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplist &#123;</span><br><span class="line">     //表头节点和表尾节点</span><br><span class="line">     structz skiplistNode *header,*tail;</span><br><span class="line">     //表中节点数量</span><br><span class="line">     unsigned long length;</span><br><span class="line">     //表中层数最大的节点的层数</span><br><span class="line">     int level;</span><br><span class="line"></span><br><span class="line">&#125;zskiplist;</span><br></pre></td></tr></table></figure></li></ol><p><img src="http://upload-images.jianshu.io/upload_images/5937589-b7b5a0611ccbae2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>从结构图中我们可以清晰的看到，header，tail分别指向跳跃表的头结点和尾节点。level 用于记录最大的层数，length 用于记录我们的节点数量。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>跳跃表是有序集合的底层实现之一</li><li>主要有zskiplist 和zskiplistNode两个结构组成</li><li>每个跳跃表节点的层高都是1至32之间的随机数</li><li>在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的对象必须是唯一的</li><li>节点按照分值的大小从大到小排序，如果分值相同，则按成员对象大小排序</li></ol><h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><blockquote><p>整数集合是集合建的底层实现之一，当一个集合中只包含整数，且这个集合中的元素数量不多时，redis就会使用整数集合intset作为集合的底层实现</p></blockquote><p>【其实就是一个特殊的集合，里面存储的数据只能够是整数，并且数据量不能过大】</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset&#123;</span><br><span class="line">    //编码方式</span><br><span class="line">    uint32_t enconding;</span><br><span class="line">   // 集合包含的元素数量</span><br><span class="line">    uint32_t length;</span><br><span class="line">    //保存元素的数组    </span><br><span class="line">    int8_t contents[];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">1、encoding：用于定义整数集合的编码方式</span><br><span class="line">2、length：用于记录整数集合中变量的数量</span><br><span class="line">3、contents：用于保存元素的数组，虽然我们在数据结构图中看到，intset将数组定义为int8_t，</span><br><span class="line">但实际上数组保存的元素类型取决于encoding</span><br></pre></td></tr></table></figure><h4 id="整数集合的升级"><a href="#整数集合的升级" class="headerlink" title="整数集合的升级"></a>整数集合的升级</h4><blockquote><p>intset 在默认情况下会帮我们设定整数集合中的编码方式，但是当我们存入的整数不符合整数集合中的编码格式时，就需要使用到Redis 中的升级策略来解决</p></blockquote><ul><li>Intset 中升级整数集合并添加新元素共分为三步进行：</li></ul><ol><li>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间</li><li>将底层数组现有的所有元素都转换成新的编码格式，重新分配空间</li><li>将新元素加入到底层数组中</li></ol><ul><li>整数集合升级的好处</li></ul><ol><li>提升灵活性</li><li>节约内存</li></ol><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li>整数集合是集合建的底层实现之一</li><li>整数集合的底层实现为数组，这个数组以有序，无重复的范式保存集合元素，在有需要时，程序会根据新添加的元素类型改变这个数组的类型</li><li>升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存</li><li>整数集合只支持升级操作，不支持降级操作</li></ul><h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><blockquote><p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值， 要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p></blockquote><h4 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h4><p>压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。<br>一个压缩列表可以包含任意多个节点（entry）， 每个节点可以保存一个字节数组或者一个整数值。<br><img src="http://upload-images.jianshu.io/upload_images/5937589-3389fa57757200cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">类型</th><th style="text-align:center">长度</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center">zlbytes</td><td style="text-align:center">uint32_t</td><td style="text-align:center">4 字节</td><td style="text-align:center">记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 zlend 的位置时使用。</td></tr><tr><td style="text-align:center">zltail</td><td style="text-align:center">uint32_t</td><td style="text-align:center">4 字节</td><td style="text-align:center">记录压缩列表表尾节点距离压缩列表的起始地址有多少字节： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。</td></tr><tr><td style="text-align:center">zllen</td><td style="text-align:center">uint16_t</td><td style="text-align:center">2 字节</td><td style="text-align:center">记录了压缩列表包含的节点数量： 当这个属性的值小于 UINT16_MAX （65535）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 UINT16_MAX 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。</td></tr><tr><td style="text-align:center">entryX</td><td style="text-align:center">列表节点</td><td style="text-align:center">不定</td><td style="text-align:center">压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td></tr><tr><td style="text-align:center">zlend</td><td style="text-align:center">uint8_t</td><td style="text-align:center">1 字节</td><td style="text-align:center">特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端。</td></tr></tbody></table><h4 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h4><blockquote><p>添加新节点可能会引发连锁更新之外， 删除节点也可能会引发连锁更新</p></blockquote><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul><li>压缩列表是一种为了节约内存而开发的顺序型数据结构</li><li>压缩列表被用作列表键和哈希键的底层实现之一</li><li>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值</li><li>添加新节点到压缩列表，可能会引发连锁更新操作，删除节点也可能会引发连锁更新</li></ul><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><p>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于39字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值</p><p>embstr 编码是专门用于保存短字符串的一种优化编码方式， 这种编码和 raw 编码一样， 都使用 redisObject 结构和 sdshdr 结构来表示字符串对象， 但 raw 编码会调用两次内存分配函数来分别创建 redisObject 结构和 sdshdr 结构， 而 embstr 编码则通过调用一次内存分配函数来分配一块连续的空间， 空间中依次包含 redisObject 和 sdshdr 两个结构</p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-54293d165d3a29d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>embstr 编码的字符串对象在执行命令时， 产生的效果和 raw 编码的字符串对象执行命令时产生的效果是相同的，但使用embstr 编码的字符串对象来保存短字符串值有以下好处：</p><ul><li>embstr 编码将创建字符串对象所需的内存分配次数从 raw 编码的两次降低为一次。</li><li>释放 embstr 编码的字符串对象只需要调用一次内存释放函数， 而释放 raw 编码的字符串对象需要调用两次内存释放函数。</li><li>因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码的字符串对象能够更好地利用缓存带来的优势。</li></ul><p><strong>字符串对象保存各类型值的编码方式：</strong></p><table><thead><tr><th style="text-align:center">值</th><th style="text-align:center">编码</th></tr></thead><tbody><tr><td style="text-align:center">可以用 long 类型保存的整数。</td><td style="text-align:center">int</td></tr><tr><td style="text-align:center">可以用 long double 类型保存的浮点数。</td><td style="text-align:center">embstr 或者 raw</td></tr><tr><td style="text-align:center">字符串值， 或者因为长度太大而没办法用 long 类型表示的整数， 又或者因为长度太大而没办法用 long double 类型表示的浮点数。</td><td style="text-align:center">embstr 或者 raw</td></tr></tbody></table><p>int 编码的字符串对象和 embstr 编码的字符串对象在条件满足的情况下， 会被转换为 raw 编码的字符串对象。<br>对于 int 编码的字符串对象来说， 如果我们向对象执行了一些命令， 使得这个对象保存的不再是整数值， 而是一个字符串值， 那么字符串对象的编码将从 int 变为 raw 。</p><h4 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h4><blockquote><p>列表对象的编码可以是 ziplist 或者 linkedlist 。</p></blockquote><ol><li>ziplist 编码的列表对象使用压缩列表作为底层实现， 每个压缩列表节点（entry）保存了一个列表元素</li><li>linkedlist 编码的列表对象使用双端链表作为底层实现， 每个双端链表节点（node）都保存了一个字符串对象， 而每个字符串对象都保存了一个列表元素</li></ol><p>当列表对象可以同时满足以下两个条件时， 列表对象使用 ziplist 编码：</p><ul><li>列表对象保存的所有字符串元素的长度都小于 64 字节；</li><li>列表对象保存的元素数量小于 512 个；</li></ul><blockquote><p>以上两个条件的上限值是可以修改的， 具体请看配置文件中关于 list-max-ziplist-value 选项和 list-max-ziplist-entries 选项的说明</p></blockquote><p>不能满足这两个条件的列表对象需要使用 linkedlist 编码。</p><h4 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h4><blockquote><p>哈希对象的编码可以是 ziplist 或者 hashtable </p></blockquote><ol><li>ziplist 编码的哈希对象使用压缩列表作为底层实现， 每当有新的键值对要加入到哈希对象时， 程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾， 因此：</li></ol><ul><li>保存了同一键值对的两个节点总是紧挨在一起， 保存键的节点在前， 保存值的节点在后；</li><li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向， 而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li></ul><ol start="2"><li>hashtable 编码的哈希对象使用字典作为底层实现， 哈希对象中的每个键值对都使用一个字典键值对来保存</li></ol><p>当哈希对象可以同时满足以下两个条件时， 哈希对象使用 ziplist 编码：</p><ul><li>哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；</li><li>哈希对象保存的键值对数量小于 512 个；</li></ul><blockquote><p>这两个条件的上限值是可以修改的， 具体请看配置文件中关于 hash-max-ziplist-value 选项和 hash-max-ziplist-entries 选项的说明</p></blockquote><p>不能满足这两个条件的哈希对象需要使用 hashtable 编码。</p><h4 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h4><blockquote><p>集合对象的编码可以是 intset 或者 hashtable </p></blockquote><ol><li>intset 编码的集合对象使用整数集合作为底层实现， 集合对象包含的所有元素都被保存在整数集合里面</li><li>hashtable 编码的集合对象使用字典作为底层实现， 字典的每个键都是一个字符串对象， 每个字符串对象包含了一个集合元素， 而字典的值则全部被设置为 NULL </li></ol><p>当集合对象可以同时满足以下两个条件时， 对象使用 intset 编码：</p><ul><li>集合对象保存的所有元素都是整数值；</li><li>集合对象保存的元素数量不超过 512 个；</li></ul><blockquote><p>第二个条件的上限值是可以修改的， 具体请看配置文件中关于 set-max-intset-entries 选项的说明。</p></blockquote><p>不能满足这两个条件的集合对象需要使用 hashtable 编码。</p><h4 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h4><blockquote><p>有序集合的编码可以是 ziplist 或者 skiplist</p></blockquote><ol><li><p>ziplist 编码的有序集合对象使用压缩列表作为底层实现<br>每个集合元素使用两个紧挨在一起的压缩列表节点来保存， 第一个节点保存元素的成员（member）， 而第二个元素则保存元素的分值（score）<br>压缩列表内的集合元素按分值从小到大进行排序， 分值较小的元素被放置在靠近表头的方向， 而分值较大的元素则被放置在靠近表尾的方向</p></li><li><p>skiplist 编码的有序集合对象使用 zset 结构作为底层实现<br>一个 zset 结构同时包含一个字典和一个跳跃表</p></li></ol><h4 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h4><p>因为 C 语言并不具备自动的内存回收功能， 所以 Redis 在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制， 通过这一机制， 程序可以通过跟踪对象的引用计数信息， 在适当的时候自动释放对象并进行内存回收</p><p>对象的引用计数信息会随着对象的使用状态而不断变化：</p><ul><li>在创建一个新对象时， 引用计数的值会被初始化为 1 ；</li><li>当对象被一个新程序使用时， 它的引用计数值会被增一；</li><li>当对象不再被一个程序使用时， 它的引用计数值会被减一；</li><li>当对象的引用计数值变为 0 时， 对象所占用的内存会被释放。</li></ul><p>对象的整个生命周期可以划分为创建对象、操作对象、释放对象三个阶段。</p><h4 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h4><p>除了用于实现引用计数内存回收机制之外， 对象的引用计数属性还带有对象共享的作用</p><p>在 Redis 中， 让多个键共享同一个值对象需要执行以下两个步骤：</p><ol><li>将数据库键的值指针指向一个现有的值对象；</li><li>将被共享的值对象的引用计数增一。</li></ol><p>目前来说， Redis 会在初始化服务器时， 创建一万个字符串对象， 这些对象包含了从 0 到 9999 的所有整数值， 当服务器需要用到值为 0 到 9999 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象</p><blockquote><p>创建共享字符串对象的数量可以通过修改 redis.h/REDIS_SHARED_INTEGERS 常量来修改</p></blockquote><p>如果我们创建一个值为 100 的键 A ， 并使用 OBJECT REFCOUNT 命令查看键 A 的值对象的引用计数， 我们会发现值对象的引用计数为 2 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET A 100</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT REFCOUNT A</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></p><p>引用这个值对象的两个程序分别是持有这个值对象的服务器程序， 以及共享这个值对象的键 A </p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-7574de56cd896183.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>如果这时我们再创建一个值为 100 的键 B ， 那么键 B 也会指向包含整数值 100 的共享对象， 使得共享对象的引用计数值变为 3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET B 100</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT REFCOUNT A</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT REFCOUNT B</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/5937589-ee362ddaba231709.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这些共享对象不单单只有字符串键可以使用， 那些在数据结构中嵌套了字符串对象的对象（linkedlist 编码的列表对象、 hashtable 编码的哈希对象、 hashtable 编码的集合对象、以及 zset 编码的有序集合对象）都可以使用这些共享对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">为什么 Redis 不共享包含字符串的对象？</span><br><span class="line"></span><br><span class="line">当服务器考虑将一个共享对象设置为键的值对象时， 程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同， </span><br><span class="line">只有在共享对象和目标对象完全相同的情况下， 程序才会将共享对象用作键的值对象，</span><br><span class="line"> 而一个共享对象保存的值越复杂， 验证共享对象和目标对象是否相同所需的复杂度就会越高， 消耗的 CPU 时间也会越多：</span><br><span class="line"></span><br><span class="line">  如果共享对象是保存整数值的字符串对象， 那么验证操作的复杂度为 O(1) ；</span><br><span class="line">  如果共享对象是保存字符串值的字符串对象， 那么验证操作的复杂度为 O(N) ；</span><br><span class="line">  如果共享对象是包含了多个值（或者对象的）对象， 比如列表对象或者哈希对象， 那么验证操作的复杂度将会是 O(N^2) 。</span><br><span class="line">因此， 尽管共享更复杂的对象可以节约更多的内存， 但受到 CPU 时间的限制， Redis 只对包含整数值的字符串对象进行共享。</span><br></pre></td></tr></table></figure><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><ul><li>Redis 数据库中的每个键值对的键和值都是一个对象。</li><li>Redis 共有字符串、列表、哈希、集合、有序集合五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率。</li><li>服务器在执行某些命令之前， 会先检查给定键的类型能否执行指定的命令， 而检查一个键的类型就是检查键的值对象的类型。</li><li>Redis 的对象系统带有引用计数实现的内存回收机制， 当一个对象不再被使用时， 该对象所占用的内存就会被自动释放。</li><li>Redis 会共享值为 0 到 9999 的字符串对象。</li><li>对象会记录自己的最后一次被访问的时间， 这个时间可以用于计算对象的空转时间</li></ul><center><a href="http://redisbook.com/index.html" target="_blank" rel="noopener">参考文档传送门</a></center>]]></content>
    
    <summary type="html">
    
      SDS/链表/字典/跳跃表/整数集合/压缩列表...
    
    </summary>
    
      <category term="redis" scheme="http://blog.linzhongtai.cn/categories/redis/"/>
    
    
      <category term="redis" scheme="http://blog.linzhongtai.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>maven依赖关系中Scope的作用</title>
    <link href="http://blog.linzhongtai.cn/2018/06/maven%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E4%B8%ADScope%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://blog.linzhongtai.cn/2018/06/maven依赖关系中Scope的作用/</id>
    <published>2018-06-22T09:17:05.000Z</published>
    <updated>2018-06-22T09:17:05.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在POM 4中，中还引入了，它主要管理依赖的部署。目前可以使用5个值：</p><ul><li>compile，缺省值，适用于所有阶段，会随着项目一起发布。 </li><li>provided，类似compile，期望JDK、容器或使用者会提供这个依赖。如servlet.jar。 </li><li>runtime，只在运行时使用，如JDBC驱动，适用运行和测试阶段。 </li><li>test，只在测试时使用，用于编译和运行测试代码。不会随项目发布。 </li><li>system，类似provided，需要显式提供包含依赖的jar，Maven不会在Repository中查找它。</li></ul><h2 id="compile-（编译范围）"><a href="#compile-（编译范围）" class="headerlink" title="compile （编译范围）"></a>compile （编译范围）</h2><p>compile是默认的范围；如果没有提供一个范围，那该依赖的范围就是编译范围。编译范围依赖在所有的classpath 中可用,同时它们也会被打包</p><h2 id="provided-（已提供范围）"><a href="#provided-（已提供范围）" class="headerlink" title="provided （已提供范围）"></a>provided （已提供范围）</h2><p>provided 依赖只有在当JDK 或者一个容器已提供该依赖之后才使用。例如， 如果你开发了一个web 应用，你可能在编译classpath 中需要可用的Servlet API 来编译一个servlet，但是你不会想要在打包好的WAR 中包含这个Servlet API；这个Servlet API JAR 由你的应用服务器或者servlet 容器提供。已提供范围的依赖在编译classpath （不是运行时）可用。它们不是传递性的，也不会被打包</p><h2 id="runtime-（运行时范围）"><a href="#runtime-（运行时范围）" class="headerlink" title="runtime （运行时范围）"></a>runtime （运行时范围）</h2><p>runtime依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如，你可能在编译的时候只需要JDBC API JAR，而只有在运行的时候才需要JDBC驱动实现。</p><h2 id="test-（测试范围）"><a href="#test-（测试范围）" class="headerlink" title="test （测试范围）"></a>test （测试范围）</h2><p>test范围依赖 在一般的编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用</p><h2 id="system-（系统范围）"><a href="#system-（系统范围）" class="headerlink" title="system （系统范围）"></a>system （系统范围）</h2><p>system范围依赖与provided 类似，但是你必须显式的提供一个对于本地系统中JAR 文件的路径。这么做是为了允许基于本地对象编译，而这些对象是系统类库的一部分。这样的构件应该是一直可用的，Maven也不会在仓库中去寻找它。如果你将一个依赖范围设置成系统范围，你必须同时提供一个 systemPath 元素。注意该范围是不推荐使用的（你应该一直尽量去从公共或定制的 Maven 仓库中引用依赖）</p>]]></content>
    
    <summary type="html">
    
      compile/system/test/runtime/provided
    
    </summary>
    
      <category term="Maven" scheme="http://blog.linzhongtai.cn/categories/Maven/"/>
    
    
      <category term="小知识" scheme="http://blog.linzhongtai.cn/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
      <category term="Maven" scheme="http://blog.linzhongtai.cn/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>cron表达式</title>
    <link href="http://blog.linzhongtai.cn/2018/06/cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://blog.linzhongtai.cn/2018/06/cron表达式/</id>
    <published>2018-06-15T09:10:33.000Z</published>
    <updated>2018-06-15T09:10:33.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><p>1、Seconds Minutes Hours DayofMonth Month DayofWeek Year<br>2、Seconds Minutes Hours DayofMonth Month DayofWeek</p><h2 id="对应的含义"><a href="#对应的含义" class="headerlink" title="对应的含义"></a>对应的含义</h2><p>Seconds:可出现”, - <em> /“四个字符，有效范围为0-59的整数<br>Minutes:可出现”, - </em> /“四个字符，有效范围为0-59的整数<br>Hours:可出现”, - <em> /“四个字符，有效范围为0-23的整数<br>DayofMonth:可出现”, - </em> / ? L W C”八个字符，有效范围为0-31的整数<br>Month:可出现”, - <em> /“四个字符，有效范围为1-12的整数或JAN-DEc<br>DayofWeek:可出现”, - </em> / ? L C #”八个字符，有效范围为1-7的整数或SUN-SAT两个范围。<br>1表示星期天，2表示星期一， 依次类推<br>Year:可出现”, - * /“四个字符，有效范围为1970-2099年</p><h2 id="特殊字符含义"><a href="#特殊字符含义" class="headerlink" title="特殊字符含义"></a>特殊字符含义</h2><ul><li>* 表示所有值</li><li>? 表示未说明的值，即不关心它为何值</li><li>- 表示一个指定的范围</li><li>, 表示附加一个可能值</li><li>/ 符号前表示开始时间，符号后表示每次递增的值</li><li>L</li></ul><p>用在day-of-month字段意思是 “这个月最后一天”；<br>用在 day-of-week字段, 它简单意思是 “7” or “SAT”。 如果在day-of-week字段里和数字联合使用，<br>它的意思就是 “这个月的最后一个星期几” – 例如： “6L” means “这个月的最后一个星期五”. 当我们用“L”时，不指明一个列表值或者范围是很重要的，不然的话，我们会得到一些意想不到的结果</p><ul><li><p>W<br>只能用在day-of-month字段。用来描叙最接近指定天的工作日（周一到周五）。<br>例如：在day-of-month字段用“15W”指“最接近这个 月第15天的工作日”，即如果这个月第15天是周六，<br>那么触发器将会在这个月第14天即周五触发；<br>如果这个月第15天是周日，那么触发器将会在这个月第16天即周一触发；<br>如果这个月第15天是周二，那么就在触发器这天触发。注意一点：这个用法只会在当前月计算值，不会越过当前月。<br>“W”字符仅能在 day-of-month指明一天，不能是一个范围或列表。也可以用“LW”来指定这个月的最后一个工作日。</p></li><li><p>#</p></li></ul><p>只能用在day-of-week字段。用来指定这个月的第几个周几。<br>例：在day-of-week字段用”6#3”指这个月第3个周五（6指周五，3指第3个）。如果指定的日期不存在，触发器就不会触发</p><ul><li>C<br>指和calendar联系后计算过的值。<br>例：在day-of-month字段用“5C”指在这个月第5天或之后包括calendar的第一天；<br>在day-of-week字段用“1C”指在这周日或之后包括calendar的第一天</li></ul><h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">每隔5秒执行一次：*/5 * * * * ?</span><br><span class="line"></span><br><span class="line">每隔1分钟执行一次：0 */1 * * * ?</span><br><span class="line"></span><br><span class="line">每天23点执行一次：0 0 23 * * ?</span><br><span class="line"></span><br><span class="line">每天凌晨1点执行一次：0 0 1 * * ?</span><br><span class="line"></span><br><span class="line">每月1号凌晨1点执行一次：0 0 1 1 * ?</span><br><span class="line"></span><br><span class="line">每月最后一天23点执行一次：0 0 23 L * ?</span><br><span class="line"></span><br><span class="line">每周星期天凌晨1点实行一次：0 0 1 ? * L</span><br><span class="line"></span><br><span class="line">在26分、29分、33分执行一次：0 26,29,33 * * * ?</span><br><span class="line"></span><br><span class="line">每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ?</span><br><span class="line"></span><br><span class="line">每隔5分钟执行一次：0 0/5 * * * ?</span><br><span class="line"></span><br><span class="line">每天中午12点触发 ：0 0 12 * * ?</span><br><span class="line"></span><br><span class="line">每天上午10:15触发 :0 15 10 ? * *</span><br><span class="line"></span><br><span class="line">每天上午10:15触发 :0 15 10 * * ?</span><br><span class="line"></span><br><span class="line">每天上午10:15触发：0 15 10 * * ? *</span><br><span class="line"></span><br><span class="line">2005年的每天上午10:15触发 ：0 15 10 * * ? 2005</span><br><span class="line"></span><br><span class="line">在每天下午2点到下午2:59期间的每1分钟触发 ：0 * 14 * * ?</span><br><span class="line"></span><br><span class="line">在每天下午2点到下午2:55期间的每5分钟触发 ：0 0/5 14 * * ?</span><br><span class="line"></span><br><span class="line">在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 ：0 0/5 14,18 * * ?</span><br><span class="line"></span><br><span class="line">在每天下午2点到下午2:05期间的每1分钟触发 ：0 0-5 14 * * ?</span><br><span class="line"></span><br><span class="line">每年三月的星期三的下午2:10和2:44触发 ：0 10,44 14 ? 3 WED</span><br><span class="line"></span><br><span class="line">周一至周五的上午10:15触发 ：0 15 10 ? * MON-FRI</span><br><span class="line"></span><br><span class="line">每月15日上午10:15触发 ：0 15 10 15 * ?</span><br><span class="line"></span><br><span class="line">每月最后一日的上午10:15触发 ：0 15 10 L * ?</span><br><span class="line"></span><br><span class="line">每月的最后一个星期五上午10:15触发 ：0 15 10 ? * 6L</span><br><span class="line"></span><br><span class="line">2002年至2005年的每月的最后一个星期五上午10:15触发 ：0 15 10 ? * 6L 2002-2005</span><br><span class="line"></span><br><span class="line">每月的第三个星期五上午10:15触发 ：0 15 10 ? * 6#3</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      cron表达式语法以及范例
    
    </summary>
    
      <category term="cron" scheme="http://blog.linzhongtai.cn/categories/cron/"/>
    
    
      <category term="小知识" scheme="http://blog.linzhongtai.cn/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
      <category term="cron" scheme="http://blog.linzhongtai.cn/tags/cron/"/>
    
  </entry>
  
</feed>
