<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林林总总</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.linzhongtai.cn/"/>
  <updated>2018-05-17T02:46:25.000Z</updated>
  <id>http://blog.linzhongtai.cn/</id>
  
  <author>
    <name>Soul</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis常见数据类型操作命令</title>
    <link href="http://blog.linzhongtai.cn/2018/05/Redis%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.linzhongtai.cn/2018/05/Redis常见数据类型操作命令/</id>
    <published>2018-05-17T02:46:25.000Z</published>
    <updated>2018-05-17T02:46:25.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h2><ul><li>keys *—查询所有key</li><li>exists key—判断key是否存在</li><li>move key db—移除当前库的key值</li><li>expire key  秒钟—设定过期时间</li><li>ttl key —查看多少秒后过期，-1永不过期，-2已过期</li><li>type key —查看key类型</li><li>FLUSHALL—清空所有数据库<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2></li><li>set/get/del/append（追加）/strlen（获取key长度）</li><li>incr（递增1）/decr（递减1）/incrby（指定递增多少）/decrby（指定递减多少）—数字才行</li><li>getrange（区间范围内取值）/setrange（区间范围内覆盖设值）</li><li>setex（set with expire）设值以及过期时间/setnx（set if not exist 不存在则写入）</li><li>mset（多值设置）/mget（多值获取）/msetnx（全部不存在才进行插入）</li><li>getset 先获取再设值<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2></li><li>hset/hget/hmset/hmget/hgetall/hdel</li><li>hlen获取键值个数</li><li>hexist key keyname 判断keyname是否在key中 </li><li>hkeys（获取所有key）/hvals（获取所有values）</li><li>hincrby/hincrbyfloat（指定递增）</li><li>hsetnx（键值不存在则进行设值）<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2></li><li>lpush（添加左边元素）/rpush（添加右边元素）/lrange（LRANGE key start stop 获取列表片段，0 -1 返回整个列表）</li><li>lindex （返回索引的元素值，-1表示从最右边的第一位）</li><li>llen（获取list长度）</li><li>lrem（LREM key count value，返回被删除的个数）<br>count&gt;0，从左边开始删除前count个值为value的元素<br>count&lt;0，从右边开始删除前|count|个值为value的元素<br>count=0，删除所有值为value的元素</li><li>ltrim （根据传入索引截取保留对应列表片段）</li><li>rpoplpush（一个列表右移除转移另一个列表左插入）</li><li>lset（设值元素值）</li><li>linsert key  before/after val01 val02 （在val01之前或者之后插入val02）<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2></li><li>sadd（新增set元素，去重）/smembers（获取set集合）/sismember（判断是否set里的值）</li><li>scard（返回集合元素个数）</li><li>srem（ 删除集合中一个或多个元素，返回成功删除的个数）</li><li>srandmember（SRANDMEMBER key [count]）<br>根据count不同有不同结果，count大于元素总数时返回全部元素<br>count&gt;0 ，返回集合中count不重复的元素<br>count&lt;0，返回集合中count的绝对值个元素，但元素可能会重复</li><li>spop（随机出栈）</li><li>smove（smove k1 k2 val -&gt;将k1的val剪切到k2上）</li><li>sdiff【差集】（sdiff A B —-&gt;集合A和集合B，差集表示A-B，在A里有的元素B里没有，返回差集合；多个集合(A-B)-C）</li><li>sinter【交集】</li><li>sunion【并集】<h2 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h2></li><li>zadd（不存在添加，存在更新）</li><li>zscore（获取元素分数）</li><li>zrange（元素从小到大:加上withscores 返回带元素，即元素，分数，当分数一样时，按元素排序）</li><li>zrevrange（元素从大到小）</li><li>zrangebyscore（指定分数范围元素）<br>返回从小到大的在min和max之间的元素，( 左括号表示不包含，例如：80-100—&gt;(80 100<br>withscore返回带分数<br>limit offest count 向左偏移offest个元素，并获取前count个元素</li><li>zrevrangebyscore（从大到小排序）</li><li>zrem（删除元素）</li><li>zcard（计算集合内个数）</li><li>zcount（计算对应范围内个数）<br>eg：ZCOUNT salary 2000 5000          —-&gt;计算薪水在 2000-5000 之间的人数</li><li>zrank（获取下标值）</li><li>zrevrank（逆序获取下标值）</li><li>zscore（获取对应的分数）</li></ul>]]></content>
    
    <summary type="html">
    
      redis常用五种数据类型:string,hash,list,set,zset(sorted set).
    
    </summary>
    
      <category term="redis" scheme="http://blog.linzhongtai.cn/categories/redis/"/>
    
    
      <category term="redis" scheme="http://blog.linzhongtai.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程之synchronized、Lock、volatile</title>
    <link href="http://blog.linzhongtai.cn/2018/05/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8Bsynchronized%E3%80%81Lock%E3%80%81volatile/"/>
    <id>http://blog.linzhongtai.cn/2018/05/Java多线程之synchronized、Lock、volatile/</id>
    <published>2018-05-16T08:36:25.000Z</published>
    <updated>2018-05-16T08:36:25.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><blockquote><p>Java的关键字，是Java的内置特性，在JVM层面实现了对临界资源的同步互斥访问，通过对对象的头文件来操作，从而达到加锁和释放锁的目的</p></blockquote><ul><li>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生</li><li>不能响应中断</li><li>同一时刻不管是读还是写都只能有一个线程对共享资源操作，其他线程只能等待，性能不高</li></ul><blockquote><p>synchronized是Java中的关键字，是一种同步锁：</p></blockquote><ol><li>无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁对应的是类，该类所有的对象同一把锁。 </li><li>每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。 </li><li>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制</li></ol><h2 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h2><ul><li>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现</li><li>Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁</li><li>Lock可以让等待锁的线程响应中断，synchronized不可以</li><li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到</li><li>Lock可以提高多个线程进行读操作的效率<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public interface Lock &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 获取锁，如果锁被其他线程获取，则进行等待</span><br><span class="line">     */</span><br><span class="line">    void lock();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，</span><br><span class="line">     * 即中断线程的等待状态。也就是说，</span><br><span class="line">     * 当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，</span><br><span class="line">     * 假若此时线程A获取到了锁，而线程B只有在等待，</span><br><span class="line">     * 那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。</span><br><span class="line">     *</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     */</span><br><span class="line">    void lockInterruptibly() throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成</span><br><span class="line">     * 功，则返回true，如果获取失败（即锁已被其他线程获取），则返回</span><br><span class="line">     * false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</span><br><span class="line">     */</span><br><span class="line">    boolean tryLock();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，</span><br><span class="line">     * 只不过区别在于这个方法在拿不到锁时会等待一定的时间，</span><br><span class="line">     * 在时间期限之内如果还拿不到锁，就返回false。</span><br><span class="line">     * 如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</span><br><span class="line">     *</span><br><span class="line">     * @param time</span><br><span class="line">     * @param unit</span><br><span class="line">     * @return</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     */</span><br><span class="line">    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    void unlock(); //释放锁</span><br><span class="line"></span><br><span class="line">    Condition newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul><li>可见性：保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的</li><li>有序性：禁止进行指令重排序</li></ul><p>加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p><ol><li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成</li><li>它会强制将对缓存的修改操作立即写入主存</li><li>如果是写操作，它会导致其他CPU中对应的缓存行无效</li></ol><h2 id="lock和synchronized的区别"><a href="#lock和synchronized的区别" class="headerlink" title="lock和synchronized的区别"></a>lock和synchronized的区别</h2><ol><li>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</li><li>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</li><li>Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</li><li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</li><li>Lock可以提高多个线程进行读操作的效率。<br>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized</li></ol><h2 id="volatile和synchronized区别"><a href="#volatile和synchronized区别" class="headerlink" title="volatile和synchronized区别"></a>volatile和synchronized区别</h2><ol><li>volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取,synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住.</li><li>volatile仅能使用在变量级别,synchronized则可以使用在变量,方法.</li><li>volatile仅能实现变量的修改可见性,而synchronized则可以保证变量的修改可见性和原子性.<blockquote><p>《Java编程思想》上说，定义long或double变量时，如果使用volatile关键字，就会获得（简单的赋值与返回操作）原子性。 </p></blockquote></li><li>volatile不会造成线程的阻塞,而synchronized可能会造成线程的阻塞.</li><li>当一个域的值依赖于它之前的值时，volatile就无法工作了，如n=n+1,n++等。如果某个域的值受到其他域的值的限制，那么volatile也无法工作，如Range类的lower和upper边界，必须遵循lower&lt;=upper的限制。</li><li>使用volatile而不是synchronized的唯一安全的情况是类中只有一个可变的域</li></ol><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>如果锁具备可重入性，则称作为可重入锁。像<strong>synchronized和ReentrantLock（唯一实现了Lock接口的类）都是可重入锁</strong>，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2</p><h3 id="可中断锁"><a href="#可中断锁" class="headerlink" title="可中断锁"></a>可中断锁</h3><p><strong>在Java中，synchronized就不是可中断锁，而Lock是可中断锁</strong><br>如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁</p><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。<br>非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。<br><strong>在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序</strong>。<br>而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁</p><p>参考：<a href="https://blog.csdn.net/ztchun/article/details/60778950" target="_blank" rel="noopener">java中volatile、synchronized和lock解析</a>、<a href="http://www.cnblogs.com/dolphin0520/p/3923167.html" target="_blank" rel="noopener">Java并发编程：Lock</a></p>]]></content>
    
    <summary type="html">
    
      synchronized、Lock、volatile 特点以及区别
    
    </summary>
    
      <category term="JAVA" scheme="http://blog.linzhongtai.cn/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://blog.linzhongtai.cn/tags/JAVA/"/>
    
      <category term="多线程" scheme="http://blog.linzhongtai.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Springboot学习之禁用数据库自动配置</title>
    <link href="http://blog.linzhongtai.cn/2018/05/Springboot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%A6%81%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.linzhongtai.cn/2018/05/Springboot学习之禁用数据库自动配置/</id>
    <published>2018-05-15T07:16:45.000Z</published>
    <updated>2018-05-15T07:16:45.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>SpringBoot默认会自动配置数据库，如果业务不需要，就要手动禁用数据库自动配置,在Application的SpringBootApplication注解里加上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication(exclude = &#123;</span><br><span class="line">DataSourceAutoConfiguration.class,</span><br><span class="line">DataSourceTransactionManagerAutoConfiguration.class,</span><br><span class="line">HibernateJpaAutoConfiguration.class</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      springboot项目启动时，如果没有配置数据库配置，启动时会抛出异常...
    
    </summary>
    
      <category term="SpringBoot" scheme="http://blog.linzhongtai.cn/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://blog.linzhongtai.cn/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>MySQL两种引擎的区别</title>
    <link href="http://blog.linzhongtai.cn/2018/05/MySQL%E4%B8%A4%E7%A7%8D%E5%BC%95%E6%93%8E%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://blog.linzhongtai.cn/2018/05/MySQL两种引擎的区别/</id>
    <published>2018-05-11T02:58:59.000Z</published>
    <updated>2018-05-11T02:58:59.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="Innodb引擎"><a href="#Innodb引擎" class="headerlink" title="Innodb引擎"></a>Innodb引擎</h2><p>Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。</p><h2 id="MyISAM引擎"><a href="#MyISAM引擎" class="headerlink" title="MyISAM引擎"></a>MyISAM引擎</h2><p>MyISAM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，MyISAM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyISAM也是很好的选择。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol><li><p>MyISAM是非事务安全的，而InnoDB是事务安全的</p></li><li><p>MyISAM锁的粒度是表级的，而InnoDB支持行级锁</p></li><li><p>MyISAM支持全文类型索引，而InnoDB不支持全文索引</p></li><li><p>MyISAM相对简单，效率上要优于InnoDB，小型应用可以考虑使用MyISAM</p></li><li><p>MyISAM表保存成文件形式，跨平台使用更加方便</p></li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>MyIASM管理非事务表，提供高速存储和检索以及全文搜索能力，如果再应用中执行大量select操作，应该选择MyIASM</li><li>InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量insert和update操作，应该选择InnoDB</li></ol><p>摘抄：<a href="https://blog.csdn.net/ls5718/article/details/52248040" target="_blank" rel="noopener">MySQL两种引擎的区别</a></p>]]></content>
    
    <summary type="html">
    
      Innodb、MyISAM
    
    </summary>
    
      <category term="Mysql" scheme="http://blog.linzhongtai.cn/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://blog.linzhongtai.cn/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制</title>
    <link href="http://blog.linzhongtai.cn/2018/05/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://blog.linzhongtai.cn/2018/05/Redis主从复制/</id>
    <published>2018-05-10T14:44:20.000Z</published>
    <updated>2018-05-10T14:44:20.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="配置从库，不配主库"><a href="#配置从库，不配主库" class="headerlink" title="配置从库，不配主库"></a>配置从库，不配主库</h2><h2 id="从库配置：slaveof-主库ip-主库端口"><a href="#从库配置：slaveof-主库ip-主库端口" class="headerlink" title="从库配置：slaveof 主库ip 主库端口"></a>从库配置：slaveof <strong>主库ip</strong> <strong>主库端口</strong></h2><p>每次与master断开后，都需要重新连接，除非配置redis.conf文件</p><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><h2 id="常用3招"><a href="#常用3招" class="headerlink" title="常用3招"></a>常用3招</h2><ul><li>一主二仆</li><li>薪火相传</li><li>反客为主（slaveof no one）</li></ul><h2 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h2><p>salve 启动成功连接到master后会发送一个sync命令，master接到命令后启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，进程执行完毕后，master将传送整个数据文件到slave，以完成一次完全同步，也就是<strong>全量复制</strong>，而slave服务在接收到数据后，存盘到内存中；master将新的修改命令依次传给slave，完成同步，此时为<strong>增量复制</strong></p><blockquote><p>只要重新连接master，一次完全同步（全量复制）将被自动执行</p></blockquote><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><blockquote><p>反客为主的自动版本，监控主机是否故障，当主库挂了，根据投票数重新选定master</p></blockquote><ul><li>新建sentinel.conf</li><li><p>配置文件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor 自定义名称 监控库ip 监控库端口 1</span><br></pre></td></tr></table></figure></li><li><p>启动哨兵</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /usr/local/redis/sentinel.conf</span><br></pre></td></tr></table></figure></li></ul><p>自动监控，选好新master后，原master恢复后会变成slave</p><blockquote><p>一组sentinel可以同时监控多个master</p></blockquote><h2 id="复制的缺点"><a href="#复制的缺点" class="headerlink" title="复制的缺点"></a>复制的缺点</h2><p>由于所有的写操作都在master上，然后同步更新到slave上，所以从master同步到slave   机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，slave机器数量的增加也会使得这个问题更加严重</p>]]></content>
    
    <summary type="html">
    
      一主二仆/薪火相传/反客为主...
    
    </summary>
    
      <category term="redis" scheme="http://blog.linzhongtai.cn/categories/redis/"/>
    
    
      <category term="redis" scheme="http://blog.linzhongtai.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化存储</title>
    <link href="http://blog.linzhongtai.cn/2018/05/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/"/>
    <id>http://blog.linzhongtai.cn/2018/05/Redis持久化存储/</id>
    <published>2018-05-09T13:14:11.000Z</published>
    <updated>2018-05-09T13:14:11.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="Redis中数据存储模式"><a href="#Redis中数据存储模式" class="headerlink" title="Redis中数据存储模式"></a>Redis中数据存储模式</h2><blockquote><p>cache-only<br>persistence</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cache-only：只做为“缓存”服务，不持久数据，数据在服务终止后将消失，</span><br><span class="line">此模式下也将不存在“数据恢复”的手段，是一种安全性低/效率高/容易扩展的方式；</span><br><span class="line">persistence：为内存中的数据持久备份到磁盘文件，在服务重启后可以恢复，</span><br><span class="line">此模式下数据相对安全。</span><br></pre></td></tr></table></figure><p>对于persistence持久化存储，Redis提供了两种持久化方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Redis DataBase(简称RDB)</span><br><span class="line">Append-only file (简称AOF)</span><br></pre></td></tr></table></figure></p><blockquote><p>如果同时开启两种持久化，会优先加载AOF进行恢复</p></blockquote><h2 id="RDB持久化：默认开启"><a href="#RDB持久化：默认开启" class="headerlink" title="RDB持久化：默认开启"></a>RDB持久化：默认开启</h2><blockquote><p>指定时间间隔进行快照存储</p></blockquote><p>优点：使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了redis的高性能<br>缺点：RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候</p><ul><li>save：服务器进程进行快照存储（阻塞）</li><li>bgsave：进行异步快照存储（派生子进程处理，非阻塞）</li><li>异常恢复：redis-check-rdb<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#dbfilename：持久化数据存储在本地的文件</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">#dir：持久化数据存储在本地的路径，如果是在/redis/redis-3.0.6/src下</span><br><span class="line">启动的redis-cli，则数据会存储在当前src目录下</span><br><span class="line">dir ./</span><br><span class="line">##snapshot触发的时机，save &lt;seconds&gt; &lt;changes&gt;  </span><br><span class="line">##如下为900秒后，至少有一个变更操作，才会snapshot  </span><br><span class="line">##对于此值的设置，</span><br><span class="line">需要谨慎，评估系统的变更操作密集程度  </span><br><span class="line">##可以通过save “”来关闭snapshot功能  </span><br><span class="line">#持久化(以快照的方式) 策略（默认）</span><br><span class="line">save 900 1       （15分钟变更一次）</span><br><span class="line">save 300 10     （5分钟变更10次）</span><br><span class="line">save 60 10000  （1分钟变更1万次）</span><br><span class="line">##当snapshot时出现错误无法继续时，是否阻塞客户端“变更操作”，</span><br><span class="line">“错误”可能因为磁盘已满/磁盘故障/OS级别异常等  </span><br><span class="line">stop-writes-on-bgsave-error yes  </span><br><span class="line">##是否启用rdb文件压缩，默认为“yes”，压缩往往意味着“额外的cpu消耗”，</span><br><span class="line">同时也意味这较小的文件尺寸以及较短的网络传输时间  </span><br><span class="line">rdbcompression yes</span><br></pre></td></tr></table></figure></li></ul><h2 id="AOF持久化：默认不开启"><a href="#AOF持久化：默认不开启" class="headerlink" title="AOF持久化：默认不开启"></a>AOF持久化：默认不开启</h2><blockquote><p>以日志的形式来记录每个写操作，将redis执行过的所有写指令记录下来（读操作不记录），只许追加但不可以改写文件，redis启动之初会读取改文件进行重新构建数据</p></blockquote><ul><li>AOF通过保存所有修改数据库的写命令请求来记录服务器的数据库状态</li><li><p>AOF文件中的所有命令都会以Redis命令请求协议的格式保存<br>优点：可以保持更高的数据完整性，如果设置追加file的时间是1s，如果redis发生故障，最多会丢失1s的数据（appendfsync—&gt;everysec）；且如果日志写入不完整支持redis-check-aof来进行日志修复；AOF文件没被rewrite之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的flushall）。<br>缺点：AOF文件比RDB文件大，且恢复速度慢，运行效率也比rdb慢。</p><h3 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a>重写机制</h3><blockquote><p>当超过阈值，则启动内容压缩，只保留最小指令集，可使用命令：bgrewriteaof</p></blockquote></li><li><p>定义：AOF采用文件追加的方式持久化数据，所以文件会越来越大，为了避免这种情况发生，增加了重写机制<br>当AOF文件的大小超过了配置所设置的阙值时，Redis就会启动AOF文件压缩，只保留可以恢复数据的最小指令集，可以使用命令bgrewriteaof</p></li><li>原理：当AOF增长过大时，会fork出一条新的进程将文件重写(也是先写临时文件最后rename)，遍历新进程的内存数据，每条记录有一条set语句。<br>重写AOF文件并没有操作旧的AOF文件，而是将整个内存中的数据内容用命令的方式重写了一个新的aof文件（有点类似快照）</li><li>触发机制：Redis会记录上次重写时的AOF文件大小，默认配置时当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100  （一倍）</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure></li></ul><h3 id="持久化策略"><a href="#持久化策略" class="headerlink" title="持久化策略"></a>持久化策略</h3><ul><li>appendfsync always (同步持久化，每次发生数据变更会被立即记录到磁盘，性能差但数据完整性比较好)</li><li>appendfsync everysec (异步操作，每秒记录，如果一秒钟内宕机，有数据丢失)</li><li>appendfsync no  （将缓存回写的策略交给系统，linux 默认是30秒将缓冲区的数据回写硬盘的）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">##此选项为aof功能的开关，默认为“no”，可以通过“yes”来开启aof功能  </span><br><span class="line">##只有在“yes”下，aof重写/文件同步等特性才会生效  </span><br><span class="line">appendonly yes  </span><br><span class="line"></span><br><span class="line">##指定aof文件名称  </span><br><span class="line">appendfilename appendonly.aof  </span><br><span class="line"></span><br><span class="line">##指定aof操作中文件同步策略，有三个合法值：always(记录立即同步，性能较差) everysec(每秒同步，官方推荐) no(将缓存回写的策略交给系统，linux 默认是30秒将缓冲区的数据回写硬盘的)，默认为everysec  </span><br><span class="line">appendfsync everysec  </span><br><span class="line">##在aof-rewrite期间，appendfsync是否暂缓文件同步，&quot;no&quot;表示“不暂缓”，“yes”表示“暂缓”，默认为“no”  </span><br><span class="line">no-appendfsync-on-rewrite no  </span><br><span class="line"></span><br><span class="line">##aof文件rewrite触发的最小文件尺寸(mb,gb),只有大于此aof文件大于此尺寸是才会触发rewrite，默认“64mb”  </span><br><span class="line">auto-aof-rewrite-min-size 64mb  </span><br><span class="line"></span><br><span class="line">##相对于“上一次”rewrite，本次rewrite触发时aof文件应该增长的百分比。  </span><br><span class="line">##每一次rewrite之后，redis都会记录下此时“新aof”文件的大小(例如A)，那么当aof文件增长到A*(1 + p)之后  </span><br><span class="line">##触发下一次rewrite，每一次aof记录的添加，都会检测当前aof文件的尺寸。  </span><br><span class="line">auto-aof-rewrite-percentage 100</span><br></pre></td></tr></table></figure></li></ul><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><ul><li>RDB与AOF同时开启  默认先加载AOF的配置文件</li><li>相同数据集，AOF文件要远大于RDB文件，恢复速度慢于RDB</li><li>AOF运行效率慢于RDB,但是同步策略效率好，不同步效率和RDB相同</li></ul>]]></content>
    
    <summary type="html">
    
      AOF、RDB
    
    </summary>
    
      <category term="redis" scheme="http://blog.linzhongtai.cn/categories/redis/"/>
    
    
      <category term="redis" scheme="http://blog.linzhongtai.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Java常见设计模式</title>
    <link href="http://blog.linzhongtai.cn/2018/04/Java%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.linzhongtai.cn/2018/04/Java常见设计模式/</id>
    <published>2018-04-16T05:30:03.000Z</published>
    <updated>2018-04-16T05:30:03.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点</p></blockquote><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */  </span><br><span class="line">    private static Singleton instance = null;  </span><br><span class="line">  </span><br><span class="line">    /* 私有构造方法，防止被实例化 */  </span><br><span class="line">    private Singleton() &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    /* 1:懒汉式，静态工程方法，创建实例 */  </span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">        if (instance == null) &#123;  </span><br><span class="line">            instance = new Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：<br>Singleton.getInstance().method();<br><strong>优点</strong>：延迟加载（需要的时候才去加载）,适合单线程操作<br><strong>缺点</strong>： 线程不安全，在多线程中很容易出现不同步的情况，如在数据库对象进行的频繁读写操作时。</p><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><blockquote><p>在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class EagerSingleton &#123;</span><br><span class="line">    //饿汉单例模式</span><br><span class="line">    //在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快</span><br><span class="line">    private static EagerSingleton instance = new EagerSingleton();//静态私有成员，已初始化</span><br><span class="line"></span><br><span class="line">    private EagerSingleton() </span><br><span class="line">    &#123;</span><br><span class="line">        //私有构造函数</span><br><span class="line">    &#125;</span><br><span class="line">    public static EagerSingleton getInstance()    //静态，不用同步（类加载时已初始化，不会有多线程的问题）</span><br><span class="line">    &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双重线程检查模式"><a href="#双重线程检查模式" class="headerlink" title="双重线程检查模式"></a>双重线程检查模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonInner &#123;  </span><br><span class="line">    private static volatile SingletonInner sInst = null;  // &lt;&lt;&lt; 这里添加了 volatile  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 私有的构造函数 </span><br><span class="line">     */  </span><br><span class="line">    private SingletonInner() &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    public static SingletonInner getInstance() &#123;  </span><br><span class="line">        SingletonInner inst = sInst;  // &lt;&lt;&lt; 在这里创建临时变量</span><br><span class="line">        if (inst == null) &#123;</span><br><span class="line">            synchronized (SingletonInner.class) &#123;</span><br><span class="line">                inst = sInst;</span><br><span class="line">                if (inst == null) &#123;</span><br><span class="line">                    inst = new SingletonInner();</span><br><span class="line">                    sInst = inst;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return inst;  // &lt;&lt;&lt; 注意这里返回的是临时变量</span><br><span class="line">    &#125;</span><br><span class="line">    protected void method() &#123;  </span><br><span class="line">        System.out.println(&quot;SingletonInner&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>volatile</strong>：<br><strong>可见性</strong>（volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新）<br><strong>防止指令重排序</strong>（赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障）<br>调用：<br>Singleton.getInstance().method();<br><strong>优点</strong>：延迟加载，线程安全<br><strong>缺点</strong>：写法复杂，不简洁</p><h3 id="内部类模式"><a href="#内部类模式" class="headerlink" title="内部类模式"></a>内部类模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonInner &#123;  </span><br><span class="line">    /** </span><br><span class="line">     * 内部类实现单例模式 </span><br><span class="line">     * 延迟加载，减少内存开销   </span><br><span class="line">     */  </span><br><span class="line">    private static class SingletonHolder &#123;  </span><br><span class="line">        private static SingletonInner instance = new SingletonInner();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 私有的构造函数 </span><br><span class="line">     */  </span><br><span class="line">    private SingletonInner() &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    public static SingletonInner getInstance() &#123;  </span><br><span class="line">        return SingletonHolder.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    protected void method() &#123;  </span><br><span class="line">        System.out.println(&quot;SingletonInner&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：<br>Singleton.getInstance().method();<br><strong>优点</strong>：延迟加载，线程安全（java中class加载时互斥的），也减少了内存消耗，推荐使用内部类方式。</p>]]></content>
    
    <summary type="html">
    
      单例/工厂/代理/适配...
    
    </summary>
    
      <category term="JAVA" scheme="http://blog.linzhongtai.cn/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://blog.linzhongtai.cn/tags/JAVA/"/>
    
      <category term="设计模式" scheme="http://blog.linzhongtai.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工作中的代码优化</title>
    <link href="http://blog.linzhongtai.cn/2018/04/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    <id>http://blog.linzhongtai.cn/2018/04/工作中的代码优化/</id>
    <published>2018-04-13T07:24:59.000Z</published>
    <updated>2018-04-13T07:24:59.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="函数式接口改造"><a href="#函数式接口改造" class="headerlink" title="函数式接口改造"></a>函数式接口改造</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private TopModel generateTopDetailModel(TopModel topModel, List&lt;PlayerWithData&gt; playerWithDataList) &#123;</span><br><span class="line">       List&lt;TopDetailModel&gt; shotsTopDetail = playerWithDataList.stream()</span><br><span class="line">               .filter(p -&gt; p.getShots() != null &amp;&amp; p.getShots() != 0)//要过滤掉空值再比较,且要过滤掉0值</span><br><span class="line">               .sorted(Comparator.comparing(PlayerWithData::getShots).reversed()</span><br><span class="line">                       .thenComparing(PlayerWithData::getName)).</span><br><span class="line">                       limit(3).map(StatsPlayer -&gt; &#123;</span><br><span class="line">                   TopDetailModel model = new TopDetailModel();</span><br><span class="line">                   BeanUtils.copyProperties(StatsPlayer, model);</span><br><span class="line">                   model.setDataCount(StatsPlayer.getShots());</span><br><span class="line">                   return model;</span><br><span class="line">               &#125;).collect(Collectors.toList());</span><br><span class="line">       topModel.setShots(shotsTopDetail);</span><br><span class="line"></span><br><span class="line">       List&lt;TopDetailModel&gt; maxDribbSpTopDetail = playerWithDataList.stream().</span><br><span class="line">               filter(p -&gt; p.getMaxDribbSp() != null &amp;&amp; p.getMaxDribbSp() != 0.0)</span><br><span class="line">               .sorted(Comparator.comparing(PlayerWithData::getMaxDribbSp).reversed()</span><br><span class="line">                       .thenComparing(PlayerWithData::getName)).</span><br><span class="line">                       limit(3).map(StatsPlayer -&gt; &#123;</span><br><span class="line">                   TopDetailModel model = new TopDetailModel();</span><br><span class="line">                   BeanUtils.copyProperties(StatsPlayer, model);</span><br><span class="line">                   model.setDataCount(StatsPlayer.getMaxDribbSp());</span><br><span class="line">                   return model;</span><br><span class="line">               &#125;).collect(Collectors.toList());</span><br><span class="line">       topModel.setMaxDribbSp(maxDribbSpTopDetail);</span><br><span class="line">       //省略N个字段的获取设值...</span><br><span class="line">       return topModel;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;TopDetailModel&gt; setIntegerTopModel(List&lt;PlayerWithData&gt; playerWithDataList,</span><br><span class="line">                                                   Function&lt;PlayerWithData, Integer&gt; function, Integer count) &#123;</span><br><span class="line">       return playerWithDataList.stream()</span><br><span class="line">               .filter(p -&gt; function.apply(p) != null &amp;&amp; function.apply(p) != 0)</span><br><span class="line">               .sorted(Comparator.comparing(function).reversed()</span><br><span class="line">                       .thenComparing(PlayerWithData::getName)).</span><br><span class="line">                       limit(count).map(stasPlayer -&gt; &#123;</span><br><span class="line">                   TopDetailModel model = new TopDetailModel();</span><br><span class="line">                   BeanUtils.copyProperties(stasPlayer, model);</span><br><span class="line">                   model.setDataCount(function);</span><br><span class="line">                   return model;</span><br><span class="line">               &#125;).collect(Collectors.toList());</span><br><span class="line">   &#125;</span><br><span class="line"> 之后每个参数传入函数方法调用设值即可：</span><br><span class="line"> topModel.setShots(setIntegerTopModel(playerWithDataList, PlayerWithData::getShots, count));</span><br></pre></td></tr></table></figure><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (PenaltyModel penaltyModel : penaltyModels) &#123;</span><br><span class="line">            String eventType = &quot;PENALTY.&quot;;</span><br><span class="line">            if (penaltyModel.getIsGoal()) &#123;</span><br><span class="line">                eventType = eventType + &quot;TRUE&quot;;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                eventType = eventType + &quot;FALSE&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">            每次循环都会创建新对象，造成内存资源浪费</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，</span><br><span class="line">即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的</span><br><span class="line">String：适用于少量的字符串操作的情况</span><br><span class="line">StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况</span><br><span class="line">StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</span><br></pre></td></tr></table></figure><h2 id="枚举命名"><a href="#枚举命名" class="headerlink" title="枚举命名"></a>枚举命名</h2><p>建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开<br>正例：BallEnum    反例：BallType</p><h2 id="避免在循环中进行数据库操作"><a href="#避免在循环中进行数据库操作" class="headerlink" title="避免在循环中进行数据库操作"></a>避免在循环中进行数据库操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void uploadTeamConfig(List&lt;TeamConfig&gt; teamConfigList, String matchId) &#123;</span><br><span class="line">      if (!CollectionUtils.isEmpty(teamConfigList)) &#123;</span><br><span class="line">          for (TeamConfig teamConfig : teamConfigList) &#123;</span><br><span class="line">              PerMatchTeamConfig perMatchTeamConfig = new PerMatchTeamConfig();</span><br><span class="line">              BeanUtils.copyProperties(teamConfig, perMatchTeamConfig);</span><br><span class="line">              perMatchTeamConfig.setMatchId(matchId);</span><br><span class="line">              perMatchTeamConfigService.saveOrUpdateByMatchIdAndTeamId(perMatchTeamConfig);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      记录一些工作中遇到的可优化的代码片段
    
    </summary>
    
      <category term="优化" scheme="http://blog.linzhongtai.cn/categories/%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="JAVA" scheme="http://blog.linzhongtai.cn/tags/JAVA/"/>
    
      <category term="优化" scheme="http://blog.linzhongtai.cn/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习之actuator</title>
    <link href="http://blog.linzhongtai.cn/2018/04/SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8Bactuator/"/>
    <id>http://blog.linzhongtai.cn/2018/04/SpringBoot学习之actuator/</id>
    <published>2018-04-12T08:50:14.000Z</published>
    <updated>2018-04-12T08:50:14.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="应用配置类"><a href="#应用配置类" class="headerlink" title="应用配置类"></a>应用配置类</h2><h3 id="autoconfig"><a href="#autoconfig" class="headerlink" title="/autoconfig"></a>/autoconfig</h3><p>用来获取应用的自动化配置报告，其中包括所有自动化配置的候选项。该端点可以帮助我们方便找到一些自动化配置为什么没有生效的具体原因。</p><ul><li>positiveMatches：返回条件匹配成功的自动化配置</li><li>negativeMatches：返回条件匹配不成功的自动化配置</li></ul><h3 id="beans"><a href="#beans" class="headerlink" title="/beans"></a>/beans</h3><p>获取应用上下文创建的所有Bean</p><h3 id="configprops"><a href="#configprops" class="headerlink" title="/configprops"></a>/configprops</h3><p>获取应用中配置的属性信息报告。prefix属性代表了属性的配置前缀，properties代表了各个属性的名称和值。如果要关闭该端点，通过使用endpoints.configprops.enabled=false来完成设置</p><h3 id="env"><a href="#env" class="headerlink" title="/env"></a>/env</h3><p>该端点主要是用来获取应用中所有可用的环境属性报告。包括环境变量、JVM属性、应用的配置属性、命令行的参数。该端点会进行隐私保护，对于password、serect、key等关键词会使用*来替代实际的属性值</p><h3 id="mappings"><a href="#mappings" class="headerlink" title="/mappings"></a>/mappings</h3><p>返回所有SpringMVC的控制器映射关系报告</p><h3 id="info"><a href="#info" class="headerlink" title="/info"></a>/info</h3><p>返回自定义的配置信息，该自定义配置信息需要以info为前缀进行配置，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">info.app.name=spring-hello</span><br><span class="line">info.app.version=v0.0.1</span><br></pre></td></tr></table></figure></p><h2 id="度量指标类"><a href="#度量指标类" class="headerlink" title="度量指标类"></a>度量指标类</h2><h3 id="metrics"><a href="#metrics" class="headerlink" title="/metrics"></a>/metrics</h3><p>返回当前应用的各类重要度量指标，比如内存信息、线程信息、垃圾回收信息等。</p><ul><li>系统信息：包括处理器数量processors、运行时间uptime和instance.uptime、系统平均负载systemload.average</li><li>mem.* ：内存概要情况</li><li>heap.* ：堆内存使用情况</li><li>noheap.* ： 非堆内存使用情况</li><li>threads.*：线程使用情况，包括线程数、守护线程数（daemon）、线程峰值（peak）等</li><li>classes.*：应用加载和卸载的类统计</li><li>gc.*：垃圾收集器的详细信息，包括垃圾回收次数gc.ps_scavenge.count、垃圾回收消耗时间gc.ps_scavenge.time、标记-清楚算法的次数gc.ps_marksweep.count、标记-清楚算法的消耗时间gc.ps_marksweep.time</li><li>httpsessions.*：Tomcat容器的会话使用情况，包括最大会话数httpsessions.max和活跃会话数httpsessions.active，该度量指标仅在引入嵌入式Tomcat作为应用容器才会提供</li><li>gauge.* ：HTTP请求的性能指标之一，主要用来反映一个绝对数值，比如gauge.response.hello:5，表示上一次hello请求的延迟时间为5毫秒</li><li>counter.*：HTTP请求的性能指标之一，主要作为计数器使用，记录了增加量和减少量，counter.status.200.hello:11，表示hello请求返回200状态的次数为11</li></ul><blockquote><p>可以通过/metrics/{name}接口来获取更细粒度的度量信息，比如通过/metrics/mem.free来获取当前可用内存数量</p></blockquote><h3 id="health"><a href="#health" class="headerlink" title="/health"></a>/health</h3><p>获取应用的各类健康指标信息</p><h3 id="dump"><a href="#dump" class="headerlink" title="/dump"></a>/dump</h3><p>用来暴露程序运行中的线程信息</p><h3 id="trace"><a href="#trace" class="headerlink" title="/trace"></a>/trace</h3><p>返回基本的HTTP跟踪信息，始终保留最近的100条请求记录</p><h2 id="操作控制类"><a href="#操作控制类" class="headerlink" title="操作控制类"></a>操作控制类</h2><p>在原生端点中，只提供了一个用来关闭应用的端点：/shutdown，通过如下配置开启<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">endpoints.shutdown.enabled=true</span><br></pre></td></tr></table></figure></p><p>配置好了之后，只要访问该端点，就能实现关闭该应用的远程操作，后续Eureka中还会有许多控制端点…</p>]]></content>
    
    <summary type="html">
    
      提供一系列用户监控的端点
    
    </summary>
    
      <category term="SpringBoot" scheme="http://blog.linzhongtai.cn/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://blog.linzhongtai.cn/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>JAVA集合总结</title>
    <link href="http://blog.linzhongtai.cn/2018/04/JAVA%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.linzhongtai.cn/2018/04/JAVA集合总结/</id>
    <published>2018-04-12T02:49:27.000Z</published>
    <updated>2018-04-12T02:49:27.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>Collection接口是集合类的根接口，Java中没有提供这个接口的直接的实现类。但是却让其被继承产生了两个接口，就是Set和List。Set中不能包含重复的元素。List是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式</p></blockquote><p>Map是Java.util包中的另一个接口，它和Collection接口没有关系，是相互独立的，但是都属于集合类的一部分。Map包含了key-value对。Map不能包含重复的key，但是可以包含相同的value</p><p>Iterator，所有的集合类，都实现了Iterator接口，这是一个用于遍历集合中元素的接口，主要包含以下三种方法：</p><ul><li>hasNext()是否还有下一个元素。</li><li>next()返回下一个元素。</li><li>remove()删除当前元素</li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><blockquote><p>List里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。</p></blockquote><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li>ArrayList在内存不够时默认是扩展50% + 1个，Vector是默认扩展1倍。</li><li>Vector属于线程安全级别的，但是大多数情况下不使用Vector，因为线程安全需要更大的系统开销。</li><li>一般使用ArrayList和LinkedList比较多，LinkedList不存在get()的操作，不能单个定位，ArrayList是顺序存储结构，LinkedList是链表存储结构</li><li>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针</li><li>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据</li></ul><h3 id="ArrayList（常用、数组实现，对元素快速随机访问）"><a href="#ArrayList（常用、数组实现，对元素快速随机访问）" class="headerlink" title="ArrayList（常用、数组实现，对元素快速随机访问）"></a>ArrayList（常用、数组实现，对元素快速随机访问）</h3><p>ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除</p><h3 id="Vector（数组实现、线程同步、需高花费）"><a href="#Vector（数组实现、线程同步、需高花费）" class="headerlink" title="Vector（数组实现、线程同步、需高花费）"></a>Vector（数组实现、线程同步、需高花费）</h3><p>Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢</p><h3 id="LinkedList（链表结构、Queue）"><a href="#LinkedList（链表结构、Queue）" class="headerlink" title="LinkedList（链表结构、Queue）"></a>LinkedList（链表结构、Queue）</h3><p>LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用</p><blockquote><p>ArrayList和LinkedList在用法上没有区别，但是在功能上还是有区别的。LinkedList经常用在增删操作较多而查询操作很少的情况下，ArrayList则相反</p></blockquote><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><blockquote><p>Set集合不允许出现重复数据<br>允许包含值为null的元素，但最多只能有一个null元素。</p></blockquote><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><ul><li>HashSet中不能有重复的元素</li><li>HashSet是无序的</li><li>HashSet也是基于HashMap实现</li></ul><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><ul><li>TreeSet中不能有重复的元素；</li><li>TreeSet具有排序功能，缺省是按照自然排序进行排列</li><li>TreeSet中的元素必须实现Comparable接口并重写compareTo()方法，TreeSet判断元素是否重复 、以及确定元素的顺序靠的都是这个方法</li><li>基于TreeMap实现</li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><blockquote><p>Map集合中存储的是键值对，键不能重复，值可以重复。根据键得到值，对map集合遍历时先得到键的set集合，对set集合进行遍历，得到相应的值</p></blockquote><p>Map遍历：KeySet()、entrySet()<br>keySet其实是遍历了2次，一次是转为iterator，一次就是从HashMap中取出key所对于的value。而entryset只是遍历了第一次，它把key和value都放到了entry中，所以<strong>entrySet效率较高</strong></p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap是最常用的Map，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。因为键对象不可以重复，所以HashMap最多只允许一条记录的键为Null，允许多条记录的值为Null，是非同步的</p><ul><li>HashMap是无序的散列映射表；</li><li>HashMap通过Hash 算法来决定存储位置</li><li>底层实现是哈希表</li></ul><h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>Hashtable与HashMap类似，是HashMap的线程安全版，它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢，它继承自Dictionary类，不同的是它不允许记录的键或者值为null，同时效率较低</p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序（自然顺序），也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。不允许key值为空，非同步的</p><ul><li>适用于按自然顺序或自定义顺序遍历键(key)。</li><li>底层是二叉树</li><li>提供compareTo，可以定义排序方法</li></ul><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>LinkedHashMap保存了记录的插入顺序，在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢，有HashMap的全部特性。</p><h3 id="ConcurrentHashMap-线程安全"><a href="#ConcurrentHashMap-线程安全" class="headerlink" title="ConcurrentHashMap 线程安全"></a>ConcurrentHashMap 线程安全</h3><ul><li>JDK1.7分析：ConcurrentHashMap采用 分段锁的机制，实现并发的更新操作，底层采用数组+链表的存储结构</li><li>JDK1.8分析：1.8的实现已经抛弃了Segment分段锁机制，利用CAS+Synchronized来保证并发更新的安全，底层采用数组+链表+红黑树的存储结构</li><li>CAS的思想：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。</li></ul><h2 id="主要实现类区别"><a href="#主要实现类区别" class="headerlink" title="主要实现类区别"></a>主要实现类区别</h2><h3 id="Vector-VS-ArrayList"><a href="#Vector-VS-ArrayList" class="headerlink" title="Vector VS ArrayList"></a>Vector VS ArrayList</h3><ul><li>vector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用arraylist效率比较高。</li><li>如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%，而arraylist增长率为目前数组长度的50%。如果在集合中使用数据量比较大的数据，用vector有一定的优势。</li><li>如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，如果频繁的访问数据，这个时候使用vector和arraylist都可以。而如果移动一个指定位置会导致后面的元素都发生移动，这个时候就应该考虑到使用linklist,因为它移动一个指定位置的数据时其它元素不移动。</li><li>ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要涉及到数组元素移动等内存操作，所以索引数据快，插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快</li></ul><h3 id="ArrayList-VS-LinkedList"><a href="#ArrayList-VS-LinkedList" class="headerlink" title="ArrayList VS LinkedList"></a>ArrayList VS LinkedList</h3><ul><li>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</li><li>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</li><li>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据</li></ul><h3 id="HashMap-VS-TreeMap"><a href="#HashMap-VS-TreeMap" class="headerlink" title="HashMap VS TreeMap"></a>HashMap VS TreeMap</h3><ul><li>HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。</li><li>在Map 中插入、删除和定位元素，HashMap是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。<br>两个map中的元素一样，但顺序不一样，导致hashCode()不一样。<br>同样做测试：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在HashMap中，同样的值的map,顺序不同，equals时，false;</span><br><span class="line">而在treeMap中，同样的值的map,顺序不同,equals时，true，</span><br><span class="line">说明treeMap在equals()时是整理了顺序了的</span><br></pre></td></tr></table></figure></li></ul><h3 id="HashTable-VS-HashMap"><a href="#HashTable-VS-HashMap" class="headerlink" title="HashTable VS HashMap"></a>HashTable VS HashMap</h3><ul><li>同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的。</li><li>HashMap允许存在一个为null的key，多个为null的value 。</li><li>hashtable的key和value都不允许为null</li></ul><p>参考：<a href="https://www.cnblogs.com/leeplogs/p/5891861.html" target="_blank" rel="noopener">JAVA集合类汇总</a>、<a href="https://blog.csdn.net/initphp/article/details/8264219" target="_blank" rel="noopener">深入理解Java集合</a></p>]]></content>
    
    <summary type="html">
    
      List/Set/Map
    
    </summary>
    
      <category term="JAVA" scheme="http://blog.linzhongtai.cn/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://blog.linzhongtai.cn/tags/JAVA/"/>
    
      <category term="Collection" scheme="http://blog.linzhongtai.cn/tags/Collection/"/>
    
  </entry>
  
  <entry>
    <title>《书单》</title>
    <link href="http://blog.linzhongtai.cn/2018/04/%E3%80%8A%E4%B9%A6%E5%8D%95%E3%80%8B/"/>
    <id>http://blog.linzhongtai.cn/2018/04/《书单》/</id>
    <published>2018-04-09T11:52:33.000Z</published>
    <updated>2018-04-09T11:52:33.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><ul><li>锋利的Jquery</li><li>JavaScript高级程序设计</li><li>Maven</li><li>Spring实战 第四版</li></ul><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><ul><li>Java8实战</li><li>Redis设计与实现</li><li>SpringBoot实战</li><li>深入理解Java虚拟机</li><li>Spring Cloud与Docker微服务架构实战</li><li>SpringCloud微服务实战</li><li>鸟哥的linux私房菜-服务器架设（待定）</li></ul>]]></content>
    
    <summary type="html">
    
      书中自有颜如玉
    
    </summary>
    
      <category term="书单" scheme="http://blog.linzhongtai.cn/categories/%E4%B9%A6%E5%8D%95/"/>
    
    
      <category term="书单" scheme="http://blog.linzhongtai.cn/tags/%E4%B9%A6%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Stream结合RabbitMQ简单实例</title>
    <link href="http://blog.linzhongtai.cn/2018/03/Spring-Cloud-Stream%E7%BB%93%E5%90%88RabbitMQ%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/"/>
    <id>http://blog.linzhongtai.cn/2018/03/Spring-Cloud-Stream结合RabbitMQ简单实例/</id>
    <published>2018-03-27T06:10:18.000Z</published>
    <updated>2018-03-27T06:10:18.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="了解Spring-Cloud-Stream"><a href="#了解Spring-Cloud-Stream" class="headerlink" title="了解Spring Cloud Stream"></a><a href="https://springcloud.cc/spring-cloud-dalston.html#_spring_cloud_stream" target="_blank" rel="noopener">了解Spring Cloud Stream</a></h2><h2 id="了解RabbitMQ"><a href="#了解RabbitMQ" class="headerlink" title="了解RabbitMQ"></a><a href="http://blog.linzhongtai.cn/2018/03/%E4%B9%9D%E6%B5%85%E4%B8%80%E6%B7%B1%E4%B9%8BRabbitMQ/">了解RabbitMQ</a></h2><h2 id="各项目中引入依赖"><a href="#各项目中引入依赖" class="headerlink" title="各项目中引入依赖"></a>各项目中引入依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="生产者A"><a href="#生产者A" class="headerlink" title="生产者A"></a>生产者A</h2><h3 id="A项目中新建一个接口作为通道"><a href="#A项目中新建一个接口作为通道" class="headerlink" title="A项目中新建一个接口作为通道"></a>A项目中新建一个接口作为通道</h3><blockquote><p>NotifyChannelConstant为自定义常量<br>@Output注解代表这是一个输出通道</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public interface PdfNotifyChannel &#123;</span><br><span class="line"></span><br><span class="line">    @Output(NotifyChannelConstant.PDF_NOTIFY_CHANNEL)</span><br><span class="line">    MessageChannel output();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绑定接口-EnableBinding"><a href="#绑定接口-EnableBinding" class="headerlink" title="绑定接口@EnableBinding"></a>绑定接口@EnableBinding</h3><ul><li>进行消息通知的类，需要添加@EnableBinding(PdfNotifyChannel.class)，指定绑定的接口通道</li><li><p>在类中进行初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private PdfNotifyChannel pdfNotifyChannel;</span><br></pre></td></tr></table></figure></li><li><p>业务方法中进行调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pdfNotifyChannel.output().send(MessageBuilder.withPayload(msg).build());</span><br></pre></td></tr></table></figure></li></ul><h2 id="消费者B"><a href="#消费者B" class="headerlink" title="消费者B"></a>消费者B</h2><h3 id="B项目中新建一个接口作为通道"><a href="#B项目中新建一个接口作为通道" class="headerlink" title="B项目中新建一个接口作为通道"></a>B项目中新建一个接口作为通道</h3><blockquote><p>NotifyChannelConstant为自定义常量，此处引用的是A项目中的常量<br>@Input注解代表这是一个输入通道，通道名需要与生产者对应才能接收消息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public interface PdfNotifyChannel &#123;</span><br><span class="line">    @Input(NotifyChannelConstant.PDF_NOTIFY_CHANNEL)</span><br><span class="line">    MessageChannel input();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="绑定接口-EnableBinding-1"><a href="#绑定接口-EnableBinding-1" class="headerlink" title="绑定接口@EnableBinding"></a>绑定接口@EnableBinding</h3><ul><li>进行消息接收的类，需要添加@EnableBinding(PdfNotifyChannel.class)，指定绑定的接口通道</li><li>监听<br>使用@StreamListener进行监听该通道中的信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 监听推送信息</span><br><span class="line">  * @param message</span><br><span class="line">  */</span><br><span class="line"> @StreamListener(NotifyChannelConstant.PDF_NOTIFY_CHANNEL)</span><br><span class="line"> public void receiverPdfNotify(Message&lt;String&gt; message) &#123;</span><br><span class="line">        LOGGER.info(&quot;频道[&#123;&#125;]监听信息为:[&#123;&#125;]&quot;, </span><br><span class="line">        NotifyChannelConstant.PDF_NOTIFY_CHANNEL, message.getPayload());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="配置RabbitMQ"><a href="#配置RabbitMQ" class="headerlink" title="配置RabbitMQ"></a>配置RabbitMQ</h2><blockquote><p>需要AB配置一致<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.host=localhost</span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br><span class="line">#默认5672</span><br><span class="line">spring.rabbitmq.port=5673</span><br><span class="line">#默认/</span><br><span class="line">spring.rabbitmq.virtual-host=/</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="RabbitMQ相关命令"><a href="#RabbitMQ相关命令" class="headerlink" title="RabbitMQ相关命令"></a>RabbitMQ相关命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前所有用户</span><br><span class="line">$ sudo rabbitmqctl list_users</span><br><span class="line"></span><br><span class="line"># 查看默认guest用户的权限</span><br><span class="line">$ sudo rabbitmqctl list_user_permissions guest</span><br><span class="line"></span><br><span class="line"># 由于RabbitMQ默认的账号用户名和密码都是guest。为了安全起见, 先删掉默认用户</span><br><span class="line">$ sudo rabbitmqctl delete_user guest</span><br><span class="line"></span><br><span class="line"># 添加新用户</span><br><span class="line">$ sudo rabbitmqctl add_user username password</span><br><span class="line"></span><br><span class="line"># 设置用户tag</span><br><span class="line">$ sudo rabbitmqctl set_user_tags username administrator</span><br><span class="line"></span><br><span class="line"># 赋予用户默认vhost的全部操作权限</span><br><span class="line">$ sudo rabbitmqctl set_permissions -p / username &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class="line"></span><br><span class="line"># 查看用户的权限</span><br><span class="line">$ sudo rabbitmqctl list_user_permissions username</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Spring Cloud Stream是一个用来为微服务应用构建消息驱动能力的框架。它可以基于Spring Boot 来创建独立的，可用于生产的Spring 应用程序。他通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动。Spring Cloud Stream 为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了发布-订阅、消费组、分区的三个核心概念。目前仅支持RabbitMQ、Kafka。
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://blog.linzhongtai.cn/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.linzhongtai.cn/tags/RabbitMQ/"/>
    
      <category term="Stream" scheme="http://blog.linzhongtai.cn/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>九浅一深之RabbitMQ</title>
    <link href="http://blog.linzhongtai.cn/2018/03/%E4%B9%9D%E6%B5%85%E4%B8%80%E6%B7%B1%E4%B9%8BRabbitMQ/"/>
    <id>http://blog.linzhongtai.cn/2018/03/九浅一深之RabbitMQ/</id>
    <published>2018-03-22T12:41:00.000Z</published>
    <updated>2018-03-22T12:41:00.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>RabbitMQ是一个开源的AMQP实现：AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。 AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。</p></blockquote><hr><blockquote><p>ConnectionFactory、Connection、Channel都是RabbitMQ对外提供的API中最基本的对象。Connection是RabbitMQ的socket链接，它封装了socket协议相关部分逻辑。ConnectionFactory为Connection的制造工厂。 Channel是我们与RabbitMQ打交道的最重要的一个接口，我们大部分的业务操作是在Channel这个接口中完成的，包括定义Queue、定义Exchange、绑定Queue与Exchange、发布消息等。</p></blockquote><p><img src="http://otkzd4sua.bkt.clouddn.com/RabbitMQ.png" alt=""></p><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p>消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</p><h3 id="Publisher"><a href="#Publisher" class="headerlink" title="Publisher"></a>Publisher</h3><p>消息的生产者，也是一个向交换器发布消息的客户端应用程序。</p><h3 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h3><p>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</p><h3 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h3><p>绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</p><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><p>网络连接，比如一个TCP连接。</p><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内地虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</p><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</p><h3 id="Virtual-Host"><a href="#Virtual-Host" class="headerlink" title="Virtual Host"></a>Virtual Host</h3><p>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</p><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>表示消息队列服务器实体。</p><h2 id="AMQP-中的消息路由"><a href="#AMQP-中的消息路由" class="headerlink" title="AMQP 中的消息路由"></a>AMQP 中的消息路由</h2><blockquote><p>AMQP 中消息的路由过程和 Java 开发者熟悉的 JMS 存在一些差别，AMQP 中增加了 Exchange 和 Binding 的角色。生产者把消息发布到 Exchange 上，消息最终到达队列并被消费者接收，而 Binding 决定交换器的消息应该发送到那个队列。</p></blockquote><p><img src="http://otkzd4sua.bkt.clouddn.com/RabbitMQ-1.png" alt=""></p><h2 id="Exchange-类型"><a href="#Exchange-类型" class="headerlink" title="Exchange 类型"></a>Exchange 类型</h2><p>Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键，此外 headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了</p><h3 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h3><p><img src="http://otkzd4sua.bkt.clouddn.com/RabbitMQ-2.png" alt=""><br>消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只转发 routing key 标记为“dog”的消息，不会转发“dog.puppy”，也不会转发“dog.guard”等等。它是完全匹配、单播的模式。</p><h3 id="fanout"><a href="#fanout" class="headerlink" title="fanout"></a>fanout</h3><p><img src="http://otkzd4sua.bkt.clouddn.com/RabbitMQ-3.png" alt=""><br>每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的。</p><h3 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h3><p><img src="http://otkzd4sua.bkt.clouddn.com/RabbitMQ-4.png" alt=""><br><img src="http://otkzd4sua.bkt.clouddn.com/RabbitMQ-5.png" alt=""></p><ul><li>routing key为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit”</li><li>binding key与routing key一样也是句点号“. ”分隔的字符串</li><li>binding key中可以存在两种特殊字符’*’与“#”，用于做模糊匹配，其中“**”用于匹配一个单词，“#”用于匹配多个单词（可以是零个）</li></ul><h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><p>headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。 在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue。</p><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>MQ本身是基于异步的消息处理，前面的示例中所有的生产者（P）将消息发送到RabbitMQ后不会知道消费者（C）处理成功或者失败（甚至连有没有消费者来处理这条消息都不知道）。 但实际的应用场景中，我们很可能需要一些同步处理，需要同步等待服务端将我的消息处理完成后再进行下一步处理。这相当于RPC（Remote Procedure Call，远程过程调用）。在RabbitMQ中也支持RPC。<br><img src="http://otkzd4sua.bkt.clouddn.com/RabbitMQ-6.png" alt=""></p><p>  RabbitMQ  中实现RPC 的机制是：</p><ul><li>客户端发送请求（消息）时，在消息的属性（MessageProperties ，在AMQP 协议中定义了14中properties ，这些属性会随着消息一起发送）中设置两个值replyTo （一个Queue 名称，用于告诉服务器处理完成后将通知我的消息发送到这个Queue 中）和correlationId （此次请求的标识号，服务器处理完成后需要将此属性返还，客户端将根据这个id了解哪条请求被成功执行了或执行失败）</li><li>服务器端收到消息并处理</li><li>服务器端处理完消息后，将生成一条应答消息到replyTo 指定的Queue ，同时带上correlationId 属性</li><li>客户端之前已订阅replyTo 指定的Queue ，从中收到服务器的应答消息后，根据其中的correlationId 属性分析哪条请求被执行了，根据执行结果进行后续业务处理</li></ul><h2 id="RabbitMQ-选型和对比"><a href="#RabbitMQ-选型和对比" class="headerlink" title="RabbitMQ 选型和对比"></a>RabbitMQ 选型和对比</h2><ul><li>从社区活跃度<br>按照目前网络上的资料，RabbitMQ 、activeM 、ZeroMQ 三者中，综合来看，RabbitMQ 是首选。 </li><li>持久化消息比较<br>ZeroMq 不支持，ActiveMq 和RabbitMq 都支持。持久化消息主要是指我们机器在不可抗力因素等情况下挂掉了，消息不会丢失的机制。</li><li>综合技术实现<br>可靠性、灵活的路由、集群、事务、高可用的队列、消息排序、问题追踪、可视化管理工具、插件系统等等。<br>RabbitMq / Kafka 最好，ActiveMq 次之，ZeroMq 最差。当然ZeroMq 也可以做到，不过自己必须手动写代码实现，代码量不小。尤其是可靠性中的：持久性、投递确认、发布者证实和高可用性。</li><li>高并发<br>毋庸置疑，RabbitMQ 最高，原因是它的实现语言是天生具备高并发高可用的erlang 语言。</li><li>比较关注的比较， RabbitMQ 和 Kafka<br>RabbitMq 比Kafka 成熟，在可用性上，稳定性上，可靠性上，  RabbitMq  胜于  Kafka  （理论上）。</li></ul><p>另外，Kafka 的定位主要在日志等方面， 因为Kafka 设计的初衷就是处理日志的，可以看做是一个日志（消息）系统一个重要组件，针对性很强，所以 如果业务方面还是建议选择 RabbitMq 。<br>还有就是，Kafka 的性能（吞吐量、TPS ）比RabbitMq 要高出来很多。</p><p>原文：<a href="https://www.jianshu.com/p/79ca08116d57" target="_blank" rel="noopener">消息队列之 RabbitMQ</a>  、 <a href="https://www.sojson.com/blog/48.html" target="_blank" rel="noopener">我为什么要选择RabbitMQ</a></p>]]></content>
    
    <summary type="html">
    
      RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://blog.linzhongtai.cn/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.linzhongtai.cn/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>事务管理@Transactional</title>
    <link href="http://blog.linzhongtai.cn/2018/03/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86-Transactional/"/>
    <id>http://blog.linzhongtai.cn/2018/03/事务管理-Transactional/</id>
    <published>2018-03-21T05:12:07.000Z</published>
    <updated>2018-03-21T05:12:07.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="传播行为（生命周期）-Propagation"><a href="#传播行为（生命周期）-Propagation" class="headerlink" title="传播行为（生命周期）-Propagation"></a>传播行为（生命周期）-Propagation</h2><blockquote><p>所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为（org.springframework.transaction.annotation.Propagation）</p></blockquote><ul><li><strong>REQUIRED</strong>（默认）<br>方法A调用时没有事务新建一个事务，当在方法A调用另一个方法B的时候，方法B将使用同一个事务；如果方法B发生异常需要数据回滚的时候，整个事务回滚</li><li>REQUIRED_NEW<br>对于方法A与B，在方法调用的时候无论是否有事务，都要开启一个新的事；如果这样方法B有异常不会导致方法A的数据回滚</li><li>NESTED<br>和REQUIRED_NEW类似，但支持JDBC，不支持JPA或者Hibernate</li><li>SUPPORTS<br>方法调用时有事务就用事务，没有就不用</li><li>NOT_SUPPORTS<br>强制方法不在事务中执行，若有事务，在方法调用到结束阶段事务都将会被挂起</li><li>NEVER<br>强制方法不在事务中执行，若有事务则抛出异常</li><li>MANDATORY<br>强制方法在事务中执行，若无事务则抛出异常<br>指定方法：通过使用propagation属性设置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(propagation = Propagation.REQUIRED)</span><br></pre></td></tr></table></figure></li></ul><h2 id="隔离级别-Isolation"><a href="#隔离级别-Isolation" class="headerlink" title="隔离级别-Isolation"></a>隔离级别-Isolation</h2><blockquote><p>隔离级别是指若干个并发的事务之间的隔离程度，与我们开发时候主要相关的场景包括：脏读取、重复读、幻读；<br>Isolation（隔离）决定了事务的完整性，处理在多事务对相同数据下的处理机制</p></blockquote><ul><li>READ_UNCOMMITED<br>对于在A事务里修改了一条记录但没有提交事务，在B事务可以读取到修改后的记录。可导致脏读，不可重复读以及幻读</li><li>READ_COMMITED<br>只有当在A事务里修改了一条记录且提交记录之后，B事务才可以读取到提交后的记录；阻止脏读，但可能导致不可重复读和幻读</li><li>REPEATABLE_READ<br>不仅能实现READ_COMMITED的功能，而且还能阻止当A事务读取了一条记录，B事务将不允许修改这条记录；阻止脏读和不可重复读，但可出现幻读</li><li>SERIALIZABLE<br>此级别下事务是顺序执行的，可以避免上述级别的缺陷，但开销较大</li><li><strong>DEFAULT</strong>（默认）<br>使用当前数据库的默认隔离界级别，如Oracle、SqlServer是READ_COMMITED；Mysql是REPEATABLE_READ<br>指定方法：通过使用isolation属性设置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(isolation = Isolation.DEFAULT)</span><br></pre></td></tr></table></figure></li></ul><h2 id="timeout（默认TIMEOUT-DEFAULT）"><a href="#timeout（默认TIMEOUT-DEFAULT）" class="headerlink" title="timeout（默认TIMEOUT_DEFAULT）"></a>timeout（默认TIMEOUT_DEFAULT）</h2><p>timeout指定事务过期时间，默认为当前数据库的事务过期时间</p><h2 id="readonly（默认false）"><a href="#readonly（默认false）" class="headerlink" title="readonly（默认false）"></a>readonly（默认false）</h2><p>指定当前事务是否是只读事务</p><h2 id="rollbackFor（默认Throwable的子类）"><a href="#rollbackFor（默认Throwable的子类）" class="headerlink" title="rollbackFor（默认Throwable的子类）"></a>rollbackFor（默认Throwable的子类）</h2><p>指定哪个或者哪些异常可以引起事务回滚</p><h2 id="noRollBackFor（默认Throwable的子类）"><a href="#noRollBackFor（默认Throwable的子类）" class="headerlink" title="noRollBackFor（默认Throwable的子类）"></a>noRollBackFor（默认Throwable的子类）</h2><p>指定哪个或者哪些异常不可以引起事务回滚</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(propagation=Propagation.REQUIRED)           //控制事务传播。默认是Propagation.REQUIRED</span><br><span class="line">@Transactional(isolation=Isolation.DEFAULT)                //控制事务隔离级别。默认跟数据库的默认隔离级别相同</span><br><span class="line">@Transactional(readOnly=false)                             //控制事务可读写还是只可读。默认可读写</span><br><span class="line">@Transactional(timeout=30)                                 //控制事务的超时时间，单位秒。默认跟数据库的事务控制系统相同，又说是30秒</span><br><span class="line">@Transactional(rollbackFor=RuntimeException.class)         //控制事务遇到哪些异常才会回滚。默认是RuntimeException</span><br><span class="line">@Transactional(rollbackForClassName=RuntimeException)      //同上</span><br><span class="line">@Transactional(noRollbackFor=NullPointerException.class)   //控制事务遇到哪些异常不会回滚。默认遇到非RuntimeException不会回滚</span><br><span class="line">@Transactional(noRollbackForClassName=NullPointerException)//同上</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      事务的作用就是为了保证用户的每一个操作都是可靠的，事务中的每一步操作都必须成功执行，只要有发生异常就回退到事务开始未进行操作的状态。
    
    </summary>
    
      <category term="事务" scheme="http://blog.linzhongtai.cn/categories/%E4%BA%8B%E5%8A%A1/"/>
    
    
      <category term="事务" scheme="http://blog.linzhongtai.cn/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java元注解</title>
    <link href="http://blog.linzhongtai.cn/2018/03/Java%E5%85%83%E6%B3%A8%E8%A7%A3/"/>
    <id>http://blog.linzhongtai.cn/2018/03/Java元注解/</id>
    <published>2018-03-19T08:43:53.000Z</published>
    <updated>2018-03-19T08:43:53.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="Retention-定义注解的保留策略"><a href="#Retention-定义注解的保留策略" class="headerlink" title="@Retention: 定义注解的保留策略"></a>@Retention: 定义注解的保留策略</h2><p>@Retention(RetentionPolicy.SOURCE) // 注解仅存在于源码中，在 class 字节码文件中不包含<br>@Retention(RetentionPolicy.CLASS) // 默认的保留策略，注解会在 class 字节码文件中存在，但运行时无法获得，<br>@Retention(RetentionPolicy.RUNTIME) // 注解会在 class 字节码文件中存在，在运行时可以通过反射获取到<br>首 先要明确生命周期长度 SOURCE &lt; CLASS &lt; RUNTIME ，所以前者能作用的地方后者一定也能作用。一般如果需要在运行时去动态获取注解信息，那只能用 RUNTIME 注解；如果要在编译时进行一些预处理操作，比如生成一些辅助代码（如 ButterKnife），就用 CLASS 注解；如果只是做一些检查性的操作，比如 @Override 和 @SuppressWarnings，则可选用 SOURCE 注解。</p><h2 id="Target：定义注解的作用目标"><a href="#Target：定义注解的作用目标" class="headerlink" title="@Target：定义注解的作用目标"></a>@Target：定义注解的作用目标</h2><p>源码为：<br>@Documented<br>@Retention(RetentionPolicy.RUNTIME)<br>@Target(ElementType.ANNOTATION_TYPE)<br>public @interface Target {<br>ElementType[] value();<br>}<br>@Target(ElementType.TYPE) // 接口、类、枚举、注解<br>@Target(ElementType.FIELD) // 字段、枚举的常量<br>@Target(ElementType.METHOD) // 方法<br>@Target(ElementType.PARAMETER) // 方法参数<br>@Target(ElementType.CONSTRUCTOR) // 构造函数<br>@Target(ElementType.LOCAL_VARIABLE)// 局部变量<br>@Target(ElementType.ANNOTATION_TYPE)// 注解<br>@Target(ElementType.PACKAGE) /// 包</p><h2 id="Document：说明该注解将被包含在-javadoc-中"><a href="#Document：说明该注解将被包含在-javadoc-中" class="headerlink" title="@Document：说明该注解将被包含在 javadoc 中"></a>@Document：说明该注解将被包含在 javadoc 中</h2><h2 id="Inherited：说明子类可以继承父类中的该注解"><a href="#Inherited：说明子类可以继承父类中的该注解" class="headerlink" title="@Inherited：说明子类可以继承父类中的该注解"></a>@Inherited：说明子类可以继承父类中的该注解</h2><p>作者：JavaIsRubbish<br>链接：<a href="http://pipe.b3log.org/blogs/JavaIsRubbish/articles/2018/03/16/1521171085983" target="_blank" rel="noopener">http://pipe.b3log.org/blogs/JavaIsRubbish/articles/2018/03/16/1521171085983</a></p>]]></content>
    
    <summary type="html">
    
      元注解是指注解的注解，包括@Retention @Target @Document @Inherited
    
    </summary>
    
      <category term="JAVA" scheme="http://blog.linzhongtai.cn/categories/JAVA/"/>
    
    
      <category term="小知识" scheme="http://blog.linzhongtai.cn/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
      <category term="JAVA" scheme="http://blog.linzhongtai.cn/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>JVM系列：垃圾收集器与内存分配策略</title>
    <link href="http://blog.linzhongtai.cn/2018/03/JVM%E7%B3%BB%E5%88%97%EF%BC%9A%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <id>http://blog.linzhongtai.cn/2018/03/JVM系列：垃圾收集器与内存分配策略/</id>
    <published>2018-03-18T03:02:50.000Z</published>
    <updated>2018-03-18T03:02:50.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a>判断对象是否存活</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><blockquote><p>实现简单，判定效率高</p></blockquote><p>Java虚拟机没有使用，主要原因是此算法很难解决对象之间相互循环引用的问题</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><blockquote><p>通过一系列的称为”GC Roots”的对象作为起始点，从这些节点向下搜索，搜索走过的路径称为引用链；当一个对象跟”GC Roots”没有任何引用链的关系，则证明此对象不可达。</p></blockquote><blockquote><p>在进行可达性分析后发现此对象没有与”GC Roots”相连的引用链，则会被第一次标记并且进行一次筛选，条件是此对象是否有必要执行finalize()方法。<br>当对象没有覆盖finalize()方法，或者说finalize()方法已被虚拟机调用过，则没有必要执行<br>如果该对象判定有必要执行，则会放到F-Quene队列，并在稍后由一个虚拟机自动建立、低优先级的Finalize线程去执行（会触发，但并不一定会等这个方法执行结束，以避免该方法执行缓慢或者死循环）<br>finalize方法是对象逃脱死亡的最后一次机会，GC会对F-Quene中的对象进行第二次小规模标记，只有重新与引用链上的任何一个对象建立关联， 那么第二次标记，将会被移出”即将回收”集合，否则，就进行回收。<br><strong>一个对象的finalize方法只会被虚拟机调用一次</strong></p></blockquote><p>在Java中，可作为”GC Roots”的对象包括下面几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（一般说的是Native方法）引用的对象<blockquote><p>引用又分为：强、软、弱、虚</p></blockquote></li></ul><h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><blockquote><p>永久代的垃圾收集主要是：废弃常量和无用的类</p></blockquote><p>无用的类：</p><ul><li>该类所有的实例都已经被回收</li><li>加载该类的ClassLoader已经被回收</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法<br>满足以上3个条件，可以进行回收，而不是必然回收。</li></ul><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除—-gt-老年代"><a href="#标记-清除—-gt-老年代" class="headerlink" title="标记-清除—-&gt;老年代"></a>标记-清除—-&gt;老年代</h3><blockquote><p>效率不高，产生大量不连续内存碎片</p></blockquote><h3 id="复制—-gt-新生代"><a href="#复制—-gt-新生代" class="headerlink" title="复制—-&gt;新生代"></a>复制—-&gt;新生代</h3><blockquote><p>实现简单，运行高效，但是将内存缩小了一半</p></blockquote><p>将可用内存划分为（A，B）2块，每次只用A块，将A块存活对象复制到B块，然后将A块一次清理，每次都对半区进行回收</p><h3 id="标记-整理—-gt-老年代"><a href="#标记-整理—-gt-老年代" class="headerlink" title="标记-整理—-&gt;老年代"></a>标记-整理—-&gt;老年代</h3><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>单线程：进行垃圾收集时，必须暂停其他所有的工作线程，直到收集结束。<br>在Client模式下，简单高效，没有线程交互的开销</p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>Serial收集器的多线程版本</p><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>使用复制算法，达到可控制的吞吐量</p><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>使用标记-整理算法</p><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>使用标记整理算法</p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><blockquote><p>以获取最短回收停顿时间为目标的收集器</p></blockquote><p>步骤：</p><ul><li>初始标记（stop the world）</li><li>并发标记（stop the world）</li><li>重新标记</li><li>并发清除<br>缺点：</li><li>对CPU资源非常敏感</li><li>无法处理浮动垃圾，可能导致Full GC产生</li><li>标记-清除算法，会导致大量内存碎片，从而引起Full GC</li></ul><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><blockquote><p>面向服务器应用的垃圾收集器</p></blockquote><p>特点：</p><ul><li>并行与并发</li><li>分代收集</li><li>空间整合（标记-整理算法）</li><li>可预测的停顿：明确指定在一个长度为M毫秒的时间片段里，消耗在垃圾收集上的时间不得超过N毫秒</li></ul><p>将Java堆划分为多个大小相等的独立区域Region，G1跟踪各个Region里面的价值大小（回收获得的空间大小以及需要花费的时间的经验值），在后台维护一个优先列表，每一次根据允许的收集时间（可预测的停顿）优先回收价值最大的Region（每个Region都有Remembered Set 避免全堆扫描）</p><p>步骤：</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ul><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><blockquote><p>对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配<br>少数情况下分配到老年代</p></blockquote><h3 id="对象优先在Eden区分配"><a href="#对象优先在Eden区分配" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h3><p>当Eden区没有足够的空间分配时，虚拟机将会发起一次Minor GC（新生代GC，速度较快）</p><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><h3 id="长期存活对象将进入老年代"><a href="#长期存活对象将进入老年代" class="headerlink" title="长期存活对象将进入老年代"></a>长期存活对象将进入老年代</h3><p>年龄计数器：在Survivor没熬过一次Minor GC，年龄加1，当达到阈值，则进入老年代；阈值设置（-XX:MaxTenuringThreshold）</p><h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>如果Survivor 中相同年龄所有对象的大小总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象都直接进入老年代</p><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>在Minor GC，虚拟机会检查老年代中最大可用的连续空间是否大于新生代所有对象总空间。如果成立，则Minor GC安全；不成立，查看HandlePromotionFailure是否允许担保失败；如果允许，则检查老年代可用连续空间是否大于之前每次晋升老年代的平均值大小，如果大于，则冒险进行Minor GC，如果小于或者设置不允许担保失败的话，则进行Full GC。</p>]]></content>
    
    <summary type="html">
    
      哪些内存需要回收？什麽時候回收？  怎麽回收？怎麽分配？
    
    </summary>
    
      <category term="jvm" scheme="http://blog.linzhongtai.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://blog.linzhongtai.cn/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM系列：Java内存区域与内存溢出异常</title>
    <link href="http://blog.linzhongtai.cn/2018/03/JVM%E7%B3%BB%E5%88%97%EF%BC%9AJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
    <id>http://blog.linzhongtai.cn/2018/03/JVM系列：Java内存区域与内存溢出异常/</id>
    <published>2018-03-13T05:23:29.000Z</published>
    <updated>2018-03-13T05:23:29.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img src="http://otkzd4sua.bkt.clouddn.com/jvm-1.png" alt="JVM运行时的数据区结构"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ul><li>作用<br>记录当前线程所执行到的字节码的行号。字节码解释器工作的时候就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li><li>意义<br>JVM的多线程是通过线程轮流切换并分配处理器来实现的，对于我们来说的并行事实上一个处理器也只会执行一条线程中的指令。所以，为了保证各线程指令的安全顺利执行，每条线程都有独立的私有的程序计数器。</li><li>存储内容<br>当线程中执行的是一个Java方法时，程序计数器中记录的是正在执行的线程的虚拟机字节码指令的地址。<br>当线程中执行的是一个本地方法时，程序计数器中的值为空。</li><li>可能出现的异常<br>此内存区域是唯一一个在JVM上不会发生内存溢出异常（OutOfMemoryError）的区域。</li></ul><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><blockquote><p><strong>Java内存区常被分为堆内存（Heap）和栈内存（Stack），其中栈内存其实指的就是虚拟机栈，或者说是虚拟机栈中的局部变量表部分</strong></p></blockquote><ul><li>作用<br>描述Java方法执行的内存模型。每个方法在执行的同时都会开辟一段内存区域用于存放方法运行时所需的数据，成为栈帧，一个栈帧包含如：局部变量表、操作数栈、动态链接、方法出口等信息。</li><li>意义<br>JVM是基于栈的，所以<strong>每个方法从调用到执行结束，就对应着一个栈帧在虚拟机栈中入栈和出栈的整个过程。</strong></li><li>存储内容<br>局部变量表（编译期可知的各种基本数据类型、引用类型和指向一条字节码指令的returnAddress类型）、操作数栈、动态链接、方法出口等信息。<br>值得注意的是：<strong>局部变量表所需的内存空间在编译期间完成分配。在方法运行的阶段是不会改变局部变量表的大小的</strong></li><li>可能出现的异常<br><strong>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。</strong><br><strong>如果在动态扩展内存的时候无法申请到足够的内存，就会抛出OutOfMemoryError异常。</strong><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><strong>与虚拟机栈类似，区别在于虚拟机栈为虚拟机执行java方法（字节码）服务，而本地方法则为虚拟机所使用的Native方法服务</strong><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><blockquote><p><strong>Java堆是垃圾收集器管理的主要区域（GC堆），可细分为：新生代，老年代，按空间可细分为：Eden空间，From Survivor空间，To Survivor空间</strong></p></blockquote></li><li>作用<br><strong>所有线程共享一块内存区域，在虚拟机开启的时候创建</strong></li><li>意义<br>存储对象实例，更好地分配内存。<br>垃圾回收（GC）。堆是垃圾收集器管理的主要区域。更好地回收内存</li><li>存储内容<br>存放对象实例，几乎所有的对象实例都在这里进行分配。堆可以处于物理上不连续的内存空间，只要逻辑上是连续的就可以。<br>值得注意的是：在JIT编译器等技术的发展下，所有对象都在堆上进行分配已变得不那么绝对。有些对象实例也可以分配在栈中</li><li>可能出现的异常<br>实现堆可以是固定大小的，也可以通过设置配置文件设置该为可扩展的。<br>如果堆上没有内存进行分配，并无法进行扩展时，将会抛出OutOfMemoryError异常<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3></li><li>作用<br>用于存储运行时常量池、已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li><li>意义<br>对运行时常量池、常量、静态变量等数据做出了规定。</li><li>存储内容<br>运行时常量池（具有动态性）、已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li><li>可能出现的异常<br>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><blockquote><p>运行时常量池对于Class文件常量池的另一个特征是具备<strong>动态性</strong>，在运行期间也可能将新的常量放入池中，例如String类的intern()</p></blockquote></li></ul><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><blockquote><p>JDK1.4中新加入NIO类，引入一种基于通道与缓冲的IO方式，它可以使用Native函数库<strong>直接分配堆外内存</strong>，然后通过一个存储在Java堆中的DirectByteBuffeer对象作为这块内存的引用进行操作。（在一些场景中显著提高性能，因为避免了Java堆和Native堆中来回复制数据）</p></blockquote><p>如果服务器管理员在配置虚拟机参数时，忽略了直接内存，就有可能导致动态扩展时，出现OutOfMemoryError异常</p><h2 id="HotSpot虚拟机对象"><a href="#HotSpot虚拟机对象" class="headerlink" title="HotSpot虚拟机对象"></a>HotSpot虚拟机对象</h2><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><blockquote><p>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程，类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。</p></blockquote><p>内存分配的2种方式：</p><blockquote><p><strong>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong></p></blockquote><ul><li><strong>指针碰撞</strong><br>Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离</li><li><strong>空闲列表</strong><br>Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录</li></ul><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><blockquote><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）</p></blockquote><p>HotSpot虚拟机的对象头包括两部分信息：</p><ul><li>Mark Word<br>第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit。</li><li>类型指针<br>对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><blockquote><p>建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象</p></blockquote></li></ul><p>目前主流的访问方式有使用句柄和直接指针两种：</p><ul><li>句柄访问<br><img src="http://otkzd4sua.bkt.clouddn.com/20170406152152314.png" alt=""></li><li>直接指针访问<br><img src="http://otkzd4sua.bkt.clouddn.com/20170406152212892.png" alt=""><br>对比优势：</li><li>使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。</li><li>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。Sun HotSpot虚拟机是使用第二种方式进行对象虚拟机访问的。<h2 id="OutOfMemoryError-异常"><a href="#OutOfMemoryError-异常" class="headerlink" title="OutOfMemoryError 异常"></a>OutOfMemoryError 异常</h2><blockquote><p>除了程序计数器，其他运行时区域都有可能抛出OutOfMemoryError异常</p></blockquote></li></ul><h3 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h3><ul><li>内存泄露<br>查看泄露对象到GC Roots的引用链，定位泄露代码位置。</li><li>内存溢出<br>如果不存在泄露，即内存中的对象确实都还必须活着，检查JVM堆参数（-Xmx与-Xms），调大参数，检查代码是否存在某些对象生命周期过长，持有状态过长的情况，减少程序运行期的内存消耗。<h3 id="虚拟机栈、本地方法栈溢出"><a href="#虚拟机栈、本地方法栈溢出" class="headerlink" title="虚拟机栈、本地方法栈溢出"></a>虚拟机栈、本地方法栈溢出</h3>HotSpot不区分虚拟机栈和本地方法栈，栈容量只能由-Xss参数设定。</li><li>StackOverFlow：线程申请的栈深度超过允许的最大深度</li><li>OutOfMemoryError： 虚拟机扩展时无法申请到足够的内存空间<br>StackOverFlow的情况：递归调用方法，定义大量的本地变量，增大此方法帧中本地变量表的长度。<br>OutOfMemoryError：多线程下的内存溢出，与栈空间是否足够大并不存在任何联系。为每个线程的栈分配的内存越大（参数-Xss），那么可以建立的线程数量就越少，建立线程时就越容易把剩下的内存耗尽，越容易内存溢出。在这种情况下，如果不能减少线程数目或者更换64位虚拟机时，减少最大堆和减少栈容量能够换区更多的线程。<h3 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h3></li><li>运行时常量池<br>String.intern()是一个Native方法，它的作用是：如果运行时常量池中已经包含一个等于此String对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此String内容相同的字符串，并返回常量池中创建的字符串的引用。JDK7的intern()方法的实现有所不同，当常量池中没有该字符串时，不再是在常量池中创建与此String内容相同的字符串，而改为在常量池中记录堆中首次出现的该字符串的引用，并返回该引用</li><li>方法区<br><strong>方法区用于存放Class的相关信息</strong>，如果运行时产生大量的类去填满方法区，就可能发生方法区的内存溢出。 例如主流框架Spring、Hibernate对大量的类进行增强时，利用CGLib字节码生成动态类；大量JSP或动态JSP(JSP第一次运行时需要编译为Java类）。<h3 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h3>Java虚拟机可以通过参数<strong>-XX:MaxDirectMemorySize</strong>设定本机直接内存可用大小，如果不指定，则默认与java堆内存大小相同。JDK中可以通过反射获取Unsafe类(Unsafe的getUnsafe()方法只有启动类加载器Bootstrap才能返回实例)直接操作本机直接内存。通过使用-XX:MaxDirectMemorySize=10M，限制最大可使用的本机直接内存大小为10MB。</li></ul>]]></content>
    
    <summary type="html">
    
      Java内存区域与内存溢出异常
    
    </summary>
    
      <category term="jvm" scheme="http://blog.linzhongtai.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://blog.linzhongtai.cn/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Cache声名式缓存注解</title>
    <link href="http://blog.linzhongtai.cn/2018/03/Cache%E5%A3%B0%E5%90%8D%E5%BC%8F%E7%BC%93%E5%AD%98%E6%B3%A8%E8%A7%A3/"/>
    <id>http://blog.linzhongtai.cn/2018/03/Cache声名式缓存注解/</id>
    <published>2018-03-11T10:06:38.000Z</published>
    <updated>2018-03-11T10:06:38.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h2><p>在方法执行前Spring先查看缓存中是否有数据，如果有，则直接返回缓存数据；若没有，调用方法并将方法返回值放入缓存</p><ul><li>value：缓存的名称，在 spring 配置文件中定义，必须指定至少一个    例如：<br>@Cacheable(value=”mycache”) 或者<br>@Cacheable(value={”cache1”,”cache2”}</li><li>key：缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合    例如：<br>@Cacheable(value=”testcache”,key=”#userName”)</li><li>condition：缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存    例如：<br>@Cacheable(value=”testcache”,condition=”#userName.length()&gt;2”)</li></ul><h2 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut"></a>@CachePut</h2><p>无论怎么样，都会把方法的返回值放进缓存中，属性与@Cacheable一致</p><h2 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h2><p>将一条或者多条数据从缓存中删除</p><ul><li>value：缓存的名称，在 spring 配置文件中定义，必须指定至少一个    例如：<br>@CachEvict(value=”mycache”) 或者<br>@CachEvict(value={”cache1”,”cache2”}</li><li>key：缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合    例如：<br>@CachEvict(value=”testcache”,key=”#userName”)</li><li>condition：缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才清空缓存    例如：<br>@CachEvict(value=”testcache”, condition=”#userName.length()&gt;2”)</li><li>allEntrie：是否清空所有缓存内容，缺省为 false，如果指定为 true，则方法调用后将立即清空所有缓存    例如：<br>@CachEvict(value=”testcache”,allEntries=true)</li><li>beforeInvocation：是否在方法执行前就清空，缺省为 false，如果指定为 true，则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法执行抛出异常，则不会清空缓存    例如：<br>@CachEvict(value=”testcache”，beforeInvocation=true)</li></ul><h2 id="Caching"><a href="#Caching" class="headerlink" title="@Caching"></a>@Caching</h2><p>可以通过@Caching注解将多个注解策略组合到一个方法上<br>@Caching注解可以让我们在一个方法或者类上同时指定多个Spring Cache相关的注解。其拥有三个属性：cacheable、put和evict，分别用于指定@Cacheable、@CachePut和@CacheEvict。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Caching(cacheable = @Cacheable(&quot;users&quot;), evict = &#123; @CacheEvict(&quot;cache2&quot;),</span><br><span class="line">         @CacheEvict(value = &quot;cache3&quot;, allEntries = true) &#125;)</span><br><span class="line">   public User find(Integer id) &#123;</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      Cache 声名式缓存注解
    
    </summary>
    
      <category term="cache" scheme="http://blog.linzhongtai.cn/categories/cache/"/>
    
    
      <category term="cache" scheme="http://blog.linzhongtai.cn/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>GC内存回收</title>
    <link href="http://blog.linzhongtai.cn/2018/02/GC%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/"/>
    <id>http://blog.linzhongtai.cn/2018/02/GC内存回收/</id>
    <published>2018-02-24T02:27:09.000Z</published>
    <updated>2018-02-24T02:27:09.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="Java在内存中的状态"><a href="#Java在内存中的状态" class="headerlink" title="Java在内存中的状态"></a>Java在内存中的状态</h2><ul><li>可达状态：在一个对象创建后，有一个以上的引用变量引用它</li><li>可恢复状态：如果程序中某个对象不再有任何的引用变量引用它，它将先进入可恢复状态。在这个状态下，系统的垃圾回收机制准备回收该对象的所占用的内存，在回收之前，系统会调用finalize()方法进行资源清理，如果资源整理后重新让一个以上引用变量引用该对象，则这个对象会再次变为可达状态；否则就会进入不可达状态</li><li>不可达状态：当对象的所有关联都被切断，且系统调用finalize()方法进行资源清理后依旧没有使该对象变为可达状态，则这个对象将永久性失去引用并且变成不可达状态，系统才会真正的去回收该对象所占用的资源    </li></ul><h2 id="Java对对象的4种引用"><a href="#Java对对象的4种引用" class="headerlink" title="Java对对象的4种引用"></a>Java对对象的4种引用</h2><ul><li>强引用 ：创建一个对象并把这个对象直接赋给一个变量，eg ：Person person = new Person(“sunny”); 不管系统资源有么的紧张，强引用的对象都绝对不会被回收，即使以后不会再用到</li><li>软引用 ：通过SoftReference类实现，eg : SoftReference<person> p = new SoftReference<person>(new Person(“Rain”));,内存非常紧张的时候会被回收，其他时候不会被回收，所以在使用之前要判断是否为null从而判断他是否已经被回收了</person></person></li><li>弱引用 ：通过WeakReference类实现，eg : WeakReference<person> p = new WeakReference<person>(new Person(“Rain”));不管内存是否足够，系统垃圾回收时必定会回收</person></person></li><li>虚引用 ：不能单独使用，主要是用于追踪对象被垃圾回收的状态。通过PhantomReference类和引用队列ReferenceQueue类联合使用实现</li></ul><h2 id="JAVA辣鸡回收机制"><a href="#JAVA辣鸡回收机制" class="headerlink" title="JAVA辣鸡回收机制"></a>JAVA辣鸡回收机制</h2><blockquote><p>内存回收 / 碎片整理</p></blockquote><h3 id="辣鸡回收算法"><a href="#辣鸡回收算法" class="headerlink" title="辣鸡回收算法"></a>辣鸡回收算法</h3><ol><li><p>串行回收（单个CPU）/ 并行回收（多个CPU才有用）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">并行回收的执行效率很高，但复杂度增加，另外也有一些副作用，如内存碎片增加</span><br></pre></td></tr></table></figure></li><li><p>并发执行和应用程序停止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">***应用程序停止，这种方式会导致应用程序的暂停</span><br><span class="line">***并发执行虽然不会导致应用程序暂停，但是需要解决和应用程序的执行冲突</span><br><span class="line">（应用程序可能在回收阶段修改对象等等），所以并发执行这种方式的系统开销</span><br><span class="line">比应用程序停止更高，而且执行起来需要更多的堆内栈</span><br></pre></td></tr></table></figure></li><li><p>压缩/不压缩/复制</p></li></ol><ul><li>支持压缩的垃圾回收器（标记-压缩 = 标记清除+压缩）会把所有的可达对象搬迁到一端，然后直接清理掉端边界以外的内存，减少了内存碎片。</li><li>不压缩的垃圾回收器（标记-清除）要遍历两次，第一次先从跟开始访问所有可达对象，并将他们标记为可达状态，第二次便利整个内存区域，对未标记可达状态的对象进行回收处理。这种回收方式不压缩，不需要额外内存，但要两次遍历，会产生碎片</li><li>复制式的垃圾回收器：将堆内存分成两个相同空间，从根（类似于前面的有向图起始顶点）开始访问每一个关联的可达对象，将空间A的全部可达对象复制到空间B，然后一次性回收空间A。对于该算法而言，因为只需访问所有的可达对象，将所有的可达对象复制走之后就直接回收整个空间，完全不用理会不可达对象，所以遍历空间的成本较小，但需要巨大的复制成本和较多的内存。</li></ul><h3 id="堆内存的分代回收"><a href="#堆内存的分代回收" class="headerlink" title="堆内存的分代回收"></a>堆内存的分代回收</h3><h4 id="分代回收的依据"><a href="#分代回收的依据" class="headerlink" title="分代回收的依据"></a>分代回收的依据</h4><ol><li>对象生存时间的长短：大部分对象在Young期间就被回收</li><li>不同代采取不同的垃圾回收策略：新（生存时间短）老（生存时间长）对象之间很少存在引用</li></ol><h4 id="堆内存的分代"><a href="#堆内存的分代" class="headerlink" title="堆内存的分代"></a>堆内存的分代</h4><ol><li>Young代</li></ol><ul><li>回收机制 ：因为对象数量少，所以采用复制回收</li><li>回收频率：Young代对象大部分很快进入不可达状态，回收频率高且回收速度快</li><li>对象来源：绝大多数对象先分配到Eden区，一些大的对象会直接被分配到Old代中</li></ul><ol start="2"><li>Old代</li></ol><ul><li>回收机制：采用标记压缩算法回收</li><li>对象来源：对象大直接进入老年代 / Young代中生存时间长的可达对象</li><li>回收频率 ：因为很少对象会死掉，所以执行频率不高，而且需要较长时间来完成</li></ul><ol start="3"><li>Permanent代 </li></ol><ul><li>用途 ：用来装载Class，方法等信息，默认为64M，不会被回收</li><li>对象来源 ：eg：对于像Hibernate，Spring这类喜欢AOP动态生成类的框架，往往会生成大量的动态代理类，因此需要更多的Permanent代内存。所以我们经常在调试Hibernate，Spring的时候经常遇到java.lang.OutOfMemoryError:PermGen space的错误，这就是Permanent代内存耗尽所导致的错误。</li><li>回收频率 ：不会被回收</li></ul><h3 id="常见的垃圾回收器"><a href="#常见的垃圾回收器" class="headerlink" title="常见的垃圾回收器"></a>常见的垃圾回收器</h3><h4 id="串行回收器（只使用一个CPU）"><a href="#串行回收器（只使用一个CPU）" class="headerlink" title="串行回收器（只使用一个CPU）"></a>串行回收器（只使用一个CPU）</h4><ul><li>Young代采用串行复制算法；Old代使用串行标记压缩算法（三个阶段：标记mark—清除sweep—压缩compact），回收期间程序会产生暂停</li></ul><h4 id="并行回收器"><a href="#并行回收器" class="headerlink" title="并行回收器"></a>并行回收器</h4><ul><li>对Young代采用的算法和串行回收器一样，只是增加了多CPU并行处理； 对Old代的处理和串行回收器完全一样，依旧是单线程</li></ul><h4 id="并行压缩回收器"><a href="#并行压缩回收器" class="headerlink" title="并行压缩回收器"></a>并行压缩回收器</h4><ul><li>对Young代处理采用与并行回收器完全一样的算法；只是对Old代采用了不同的算法，其实就是划分不同的区域，然后进行标记压缩算法：<br>① 将Old代划分成几个固定区域；<br>② mark阶段（多线程并行），标记可达对象；<br>③ summary阶段（串行执行），从最左边开始检验知道找到某个达到数值（可达对象密度小）的区域时，此区域及其右边区域进行压缩回收，其左端为密集区域<br>④ compact阶段（多线程并行），识别出需要装填的区域，多线程并行的把数据复制到这些区域中。经此过程后，Old代一端密集存在大量活动对象，另一端则存在大块空间</li></ul><h4 id="并发标识—清理回收（CMS）"><a href="#并发标识—清理回收（CMS）" class="headerlink" title="并发标识—清理回收（CMS）"></a>并发标识—清理回收（CMS）</h4><ul><li>对Young代处理采用与并行回收器完全一样的算法；只是对Old代采用了不同的算法，但归根待地还是标记清理算法：<br>① 初始标识（程序暂停）：标记被直接引用的对象(一级对象)；<br>② 并发标识（程序运行）：通过一级对象寻找其他可达对象；<br>③ 再标记（程序暂停）：多线程并行的重新标记之前可能因为并发而漏掉的对象（简单的说就是防遗漏）<br>④ 并发清理（程序运行）</li></ul><h3 id="内存管理小技巧"><a href="#内存管理小技巧" class="headerlink" title="内存管理小技巧"></a>内存管理小技巧</h3><ol><li>尽量使用直接量，eg：String javaStr = “内存回收”</li><li>使用StringBuilder和StringBuffer进行字符串连接等操作</li><li>尽早释放无用对象</li><li>尽量少使用静态变量</li><li>缓存常用的对象:可以使用开源的开源缓存实现，eg：OSCache，Ehcache</li><li>尽量不使用finalize()方法</li><li>在必要的时候可以考虑使用软引用SoftReference</li></ol>]]></content>
    
    <summary type="html">
    
      在Java中，它的内存管理包括两方面：内存分配（创建Java对象的时候）和内存回收，正因为内存管理完全由JVM负责，所以也使Java很多人不再关心内存分配，导致很多程序低效，耗内存......
    
    </summary>
    
      <category term="jvm" scheme="http://blog.linzhongtai.cn/categories/jvm/"/>
    
    
      <category term="小知识" scheme="http://blog.linzhongtai.cn/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
      <category term="GC" scheme="http://blog.linzhongtai.cn/tags/GC/"/>
    
      <category term="jvm" scheme="http://blog.linzhongtai.cn/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Redis安装以及配置</title>
    <link href="http://blog.linzhongtai.cn/2018/01/Redis%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.linzhongtai.cn/2018/01/Redis安装以及配置/</id>
    <published>2018-01-21T06:45:49.000Z</published>
    <updated>2018-01-21T06:45:49.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="http://redis.io/download" target="_blank" rel="noopener">http://redis.io/download</a></p><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p>tar zxvf redis-2.8.17.tar.gz</p><h2 id="编译并安装"><a href="#编译并安装" class="headerlink" title="编译并安装"></a>编译并安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd redis-2.8.17</span><br><span class="line">make </span><br><span class="line">cd src</span><br><span class="line">make install PREFIX=/usr/local/redis</span><br></pre></td></tr></table></figure><ul><li>make编译如果失败，因为没有安装gcc服务<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc---安装gcc</span><br><span class="line">rpm -qa |grep gcc---查看安装是否成功</span><br></pre></td></tr></table></figure></li></ul><h2 id="将配置文件移动到redis安装目录下"><a href="#将配置文件移动到redis安装目录下" class="headerlink" title="将配置文件移动到redis安装目录下"></a>将配置文件移动到redis安装目录下</h2><p>进入redis目录，创建etc文件夹<br>mv redis.conf /usr/local/redis/etc</p><h2 id="启动服务、配置"><a href="#启动服务、配置" class="headerlink" title="启动服务、配置"></a>启动服务、配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf</span><br><span class="line">第一个是启动redis服务器</span><br><span class="line">第二个是启动服务器所需的配置</span><br></pre></td></tr></table></figure><h2 id="设置后台运行"><a href="#设置后台运行" class="headerlink" title="设置后台运行"></a>设置后台运行</h2><p>vim /usr/local/redis/etc/redis.conf<br>将daemonize的值改为yes</p><h2 id="设置开机自启"><a href="#设置开机自启" class="headerlink" title="设置开机自启"></a>设置开机自启</h2><p>vim /etc/rc.local<br>加入<br>/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis-conf</p><h2 id="客户端链接"><a href="#客户端链接" class="headerlink" title="客户端链接"></a>客户端链接</h2><p>/usr/local/redis/bin/redis-cli </p><h2 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h2><p>/usr/local/redis/bin/redis-cli shutdown<br>或者<br>pkill redis-server</p>]]></content>
    
    <summary type="html">
    
      linux 环境安装部署redis
    
    </summary>
    
      <category term="redis" scheme="http://blog.linzhongtai.cn/categories/redis/"/>
    
    
      <category term="redis" scheme="http://blog.linzhongtai.cn/tags/redis/"/>
    
  </entry>
  
</feed>
