<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林林总总</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.linzhongtai.cn/"/>
  <updated>2019-07-06T11:16:30.000Z</updated>
  <id>http://blog.linzhongtai.cn/</id>
  
  <author>
    <name>Soul</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring @Component派生性</title>
    <link href="http://blog.linzhongtai.cn/2019/07/Spring%20@Component%E6%B4%BE%E7%94%9F%E6%80%A7/"/>
    <id>http://blog.linzhongtai.cn/2019/07/Spring @Component派生性/</id>
    <published>2019-07-06T11:16:30.000Z</published>
    <updated>2019-07-06T11:16:30.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>Spring核心部分提供了几种内建模式的注解，如@Component、@Service、@Repository、@Controller、@RestController以及@Configrution，但是Spring Framework并不限于这些内建模式注解，也可以自定义模式注解，Spring模式注解可理解为@Component”派生”注解</p></blockquote><ul><li><strong>Spring Framework 2.x</strong>只支持单层的@Component派生</li><li><strong>Spring Framework 3.0.0.RELEASE 后</strong>开始支持@Component，但是仅仅支持两层@Component派生（AnnotationAttributesReadingVisitor仅支持了两个for循环）</li><li><strong>Spring Framework 4.0.0.RELEASE 后</strong>开始支持多层次的@Component派生（AnnotationAttributesReadingVisitor采用递归） </li></ul><p><strong>ClassPathBeanDefinitionScanner</strong>允许自定义类型过滤规则，因此，Dubbo的@Service在没有标注@Component的情况下，通过scanner.addIncludeFilter(newAnnotationTypeFilter(Service.class))的方式达到了识别@Service所标注类的目的，不过这种方式没有用到@Component的派生性</p>]]></content>
    
    <summary type="html">
    
      Spring模式注解可理解为@Component&quot;派生&quot;注解
    
    </summary>
    
      <category term="JAVA" scheme="http://blog.linzhongtai.cn/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://blog.linzhongtai.cn/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot如何解决项目启动时初始化资源</title>
    <link href="http://blog.linzhongtai.cn/2019/06/SpringBoot%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%97%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E8%B5%84%E6%BA%90/"/>
    <id>http://blog.linzhongtai.cn/2019/06/SpringBoot如何解决项目启动时初始化资源/</id>
    <published>2019-06-24T06:39:04.000Z</published>
    <updated>2019-06-24T06:39:04.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>本文转发自《纯洁的微笑》，原文链接：<a href="http://www.ityouknow.com/springboot/2018/05/03/spring-boot-commandLineRunner.html" target="_blank" rel="noopener">Spring Boot 如何解决项目启动时初始化资源</a></p></blockquote><p>在我们实际工作中，总会遇到这样需求，在项目启动的时候需要做一些初始化的操作，比如初始化线程池，提前加载好加密证书等。今天就给大家介绍一个 Spring Boot 神器，专门帮助大家解决项目启动初始化资源操作。</p><p>这个神器就是 CommandLineRunner，CommandLineRunner 接口的 Component 会在所有 Spring Beans 都初始化之后，SpringApplication.run() 之前执行，非常适合在应用程序启动之初进行一些数据初始化的工作。</p><p>接下来我们就运用案例测试它如何使用，在测试之前在启动类加两行打印提示，方便我们识别 CommandLineRunner 的执行时机。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class CommandLineRunnerApplication &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(&quot;The service to start.&quot;);</span><br><span class="line">SpringApplication.run(CommandLineRunnerApplication.class, args);</span><br><span class="line">System.out.println(&quot;The service has started.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们直接创建一个类继承 CommandLineRunner ，并实现它的 run() 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class Runner implements CommandLineRunner &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run(String... args) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;The Runner start to initialize ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们在 run() 方法中打印了一些参数来看出它的执行时机。完成之后启动项目进行测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">The service to start.</span><br><span class="line"></span><br><span class="line">  .   ____          _            __ _ _</span><br><span class="line"> /\\ / ___&apos;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="line">( ( )\___ | &apos;_ | &apos;_| | &apos;_ \/ _` | \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  &apos;  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class="line"> =========|_|==============|___/=/_/_/_/</span><br><span class="line"> :: Spring Boot ::        (v2.0.0.RELEASE)</span><br><span class="line">...</span><br><span class="line">2018-04-21 22:21:34.706  INFO 27016 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path &apos;&apos;</span><br><span class="line">2018-04-21 22:21:34.710  INFO 27016 --- [           main] com.neo.CommandLineRunnerApplication     : Started CommandLineRunnerApplication in 3.796 seconds (JVM running for 5.128)</span><br><span class="line">The Runner start to initialize ...</span><br><span class="line">The service has started.</span><br></pre></td></tr></table></figure></p><p>根据控制台的打印信息我们可以看出 CommandLineRunner 中的方法会在 Spring Boot 容器加载之后执行，执行完成后项目启动完成。</p><p>如果我们在启动容器的时候需要初始化很多资源，并且初始化资源相互之间有序，那如何保证不同的 CommandLineRunner 的执行顺序呢？Spring Boot 也给出了解决方案。那就是使用 @Order 注解。</p><p>我们创建两个 CommandLineRunner 的实现类来进行测试：</p><p>第一个实现类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Order(1)</span><br><span class="line">public class OrderRunner1 implements CommandLineRunner &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run(String... args) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;The OrderRunner1 start to initialize ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二个实现类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Order(2)</span><br><span class="line">public class OrderRunner2 implements CommandLineRunner &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run(String... args) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;The OrderRunner2 start to initialize ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>添加完成之后重新启动，观察执行顺序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">The service to start.</span><br><span class="line"></span><br><span class="line">  .   ____          _            __ _ _</span><br><span class="line"> /\\ / ___&apos;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="line">( ( )\___ | &apos;_ | &apos;_| | &apos;_ \/ _` | \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  &apos;  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class="line"> =========|_|==============|___/=/_/_/_/</span><br><span class="line"> :: Spring Boot ::        (v2.0.0.RELEASE)</span><br><span class="line">...</span><br><span class="line">2018-04-21 22:21:34.706  INFO 27016 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path &apos;&apos;</span><br><span class="line">2018-04-21 22:21:34.710  INFO 27016 --- [           main] com.neo.CommandLineRunnerApplication     : Started CommandLineRunnerApplication in 3.796 seconds (JVM running for 5.128)</span><br><span class="line">The OrderRunner1 start to initialize ...</span><br><span class="line">The OrderRunner2 start to initialize ...</span><br><span class="line">The Runner start to initialize ...</span><br><span class="line">The service has started.</span><br></pre></td></tr></table></figure></p><p>通过控制台的输出我们发现，添加 @Order 注解的实现类最先执行，并且@Order()里面的值越小启动越早。</p>]]></content>
    
    <summary type="html">
    
      CommandLineRunner
    
    </summary>
    
      <category term="SpringBoot" scheme="http://blog.linzhongtai.cn/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://blog.linzhongtai.cn/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用文件搜索命令</title>
    <link href="http://blog.linzhongtai.cn/2019/06/Linux%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.linzhongtai.cn/2019/06/Linux常用文件搜索命令/</id>
    <published>2019-06-13T02:59:46.000Z</published>
    <updated>2019-06-13T02:59:46.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="最强大的搜索命令：find"><a href="#最强大的搜索命令：find" class="headerlink" title="最强大的搜索命令：find"></a>最强大的搜索命令：find</h2><blockquote><p>首先进行一点说明，find命令是我们在Linux系统中用来进行文件搜索用的最多的命令，功能特别强大。但是我们要说的是尽量少用find命令去执行搜索任务，就算要搜索我们也应该尽量的缩小范围，也不要在服务器使用高峰期进行文件搜索，因为搜索也是很占系统资源的。这就需要我们在进行Linux文件整理的时候，尽量规范化，什么文件放在什么目录下都要有比较好的约定。</p></blockquote><ol><li>命令名称：find</li><li>命令所在路径：/bin/find</li><li>执行权限：所有用户</li><li>功能描述：进行各种花式文件搜索</li><li>语法：find【搜索范围】【匹配条件】</li></ol><p><strong>Linux搜索和windows是有明显区别的，Linux严格区分文件大小写。</strong></p><h3 id="文件或目录名称"><a href="#文件或目录名称" class="headerlink" title="文件或目录名称"></a>文件或目录名称</h3><p>find 【搜索目录】【-name或者-iname】【搜索字符】：-name和-iname的区别一个区分大小写，一个不区分大小写</p><ol><li>find /etc -name init   (精准搜索，名字必须为 init 才能搜索的到)</li><li>find /etc -iname init   (精准搜索，名字必须为 init或者有字母大写也能搜索的到)</li><li>find /etc -name *init  (模糊搜索，以 init 结尾的文件或目录名) </li><li>find /etc -name init??? (模糊搜索，？ 表示单个字符，即搜索到 init___)</li></ol><h3 id="文件大小"><a href="#文件大小" class="headerlink" title="文件大小"></a>文件大小</h3><p>比如：在根目录下查找大于 100M 的文件</p><blockquote><p>find / -size +204800</p></blockquote><p><strong>+n 表示大于，-n 表示小于，n 表示等于</strong><br>1 数据块 == 512 字节 ==0.5KB，也就是1KB等于2数据块<br>100MB == 102400KB==204800数据块</p><h3 id="所有者和所属组"><a href="#所有者和所属组" class="headerlink" title="所有者和所属组"></a>所有者和所属组</h3><ol><li><p>在home目录下查询所属组为 root 的文件</p><blockquote><p>find /home -group root</p></blockquote></li><li><p>在home目录下查询所有者为 root 的文件</p><blockquote><p>find /home -user root</p></blockquote></li></ol><h3 id="时间属性"><a href="#时间属性" class="headerlink" title="时间属性"></a>时间属性</h3><p>find 【路径】【选项】【时间】<br>选项有下面三种：</p><ul><li>-amin  访问时间</li><li>-cmin   文件属性被更改</li><li>-mmin  文件内容被修改</li></ul><p>时间：<strong>+n,-n,n分别表示超过n分钟，n分钟以内和n分钟</strong><br>范例：在 /etc 目录下查找5 分钟内被修改过属性的文件和目录</p><blockquote><p>find /etc -cmin -5</p></blockquote><h3 id="文件类型或i节点"><a href="#文件类型或i节点" class="headerlink" title="文件类型或i节点"></a>文件类型或i节点</h3><p><strong>-type 根据文件类型查找：f表示文件，d表示目录，l表示软链接</strong></p><p>范例：查找 /home 目录下文件类型是目录的   find /home -type l</p><p><strong>-inum 根据i节点查找</strong></p><p>范例：查找 /tmp 目录下i节点为400342的文件或目录  find /tmp -inum 400342</p><h3 id="组合条件"><a href="#组合条件" class="headerlink" title="组合条件"></a>组合条件</h3><ol><li>-a  表示两个条件同时满足（and）</li><li>-o  表示两个条件满足任意一个即可（or）</li></ol><p>范例：查找/etc目录下大于80MB同时小于100MB的文件</p><blockquote><p>find /etc -size +163840 -a -size -204800</p></blockquote><h2 id="在文件资料库中查找文件命令：locate"><a href="#在文件资料库中查找文件命令：locate" class="headerlink" title="在文件资料库中查找文件命令：locate"></a>在文件资料库中查找文件命令：locate</h2><ol><li>命令名称：locate</li><li>命令所在路径：/usr/bin/locate</li><li>执行权限：所有用户</li><li>功能描述：在文件资料库中查找文件</li><li>语法：locate【文件名】<br>-i  不区分大小写</li></ol><blockquote><p><strong>注意</strong>：这里和 find 命令是有区别的，find是全盘检索，而locate 是在文件资料库中进行搜索。所以locate命令的执行要比find命令执行速度快很多。但是这里有个问题，文件资料库是需要不断更新的。我们新创建的文件如果不更新 文件资料库，使用 locate 是查找不到的。</p></blockquote><blockquote><p>updatedb  手动更新资料库，但是对于/tmp目录下的新建文件，是更新不到文件资料库的，因为/tmp目录不属于文件资料库的收录范围。</p></blockquote><h2 id="搜索命令所在的目录及别名信息：which"><a href="#搜索命令所在的目录及别名信息：which" class="headerlink" title="搜索命令所在的目录及别名信息：which"></a>搜索命令所在的目录及别名信息：which</h2><ol><li>命令名称：which</li><li>命令所在路径：/usr/bin/which</li><li>执行权限：所有用户</li><li>功能描述：搜索命令所在的目录及别名信息</li><li>语法：which【命令】</li></ol><p>范例：查询 ls 命令所在目录以及别名信息</p><blockquote><p>which ls</p></blockquote><h2 id="搜索命令所在的目录及帮助文档路径：whereis"><a href="#搜索命令所在的目录及帮助文档路径：whereis" class="headerlink" title="搜索命令所在的目录及帮助文档路径：whereis"></a>搜索命令所在的目录及帮助文档路径：whereis</h2><ol><li>命令名称：whereis</li><li>命令所在路径：/usr/bin/whereis</li><li>执行权限：所有用户</li><li>功能描述：搜索命令所在的目录及帮助文档路径</li><li>语法：whereis【命令】</li></ol><p>范例：查询 ls 命令所在目录以及帮助文档路径</p><blockquote><p>whereis ls</p></blockquote><h2 id="在文件中搜寻字符串匹配的行并输出：grep"><a href="#在文件中搜寻字符串匹配的行并输出：grep" class="headerlink" title="在文件中搜寻字符串匹配的行并输出：grep"></a>在文件中搜寻字符串匹配的行并输出：grep</h2><ol><li>命令名称：grep</li><li>命令所在路径：/bin/grep</li><li>执行权限：所有用户</li><li>功能描述：在文件中搜寻字符串匹配的行并输出</li><li>语法：grep -iv 【指定字符串】【文件】<br>　　　　　　 -i 不区分大小写<br>　　　　　　 -v 排除指定字符串</li></ol><p>范例：查找 /root/install.log 文件中包含 mysql 字符串的行，并输出</p><blockquote><p>grep  mysql  /root/install.log</p></blockquote>]]></content>
    
    <summary type="html">
    
      find/locate/which/whereis/grep
    
    </summary>
    
      <category term="linux" scheme="http://blog.linzhongtai.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://blog.linzhongtai.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>网络IO模型</title>
    <link href="http://blog.linzhongtai.cn/2019/06/%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B/"/>
    <id>http://blog.linzhongtai.cn/2019/06/网络IO模型/</id>
    <published>2019-06-04T04:20:58.000Z</published>
    <updated>2019-06-04T04:20:58.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="网络IO的模型大致包括下面几种"><a href="#网络IO的模型大致包括下面几种" class="headerlink" title="网络IO的模型大致包括下面几种"></a>网络IO的模型大致包括下面几种</h2><ul><li>同步模型（synchronous IO）<ul><li>阻塞IO（bloking IO）</li><li>非阻塞IO（non-blocking IO）</li><li>多路复用IO（multiplexing IO）</li><li>信号驱动式IO（signal-driven IO）</li></ul></li><li>异步IO（asynchronous IO）<ul><li>异步IO</li></ul></li></ul><p>网络IO的本质是socket的读取，socket在linux系统被抽象为流，IO可以理解为对流的操作。对于一次IO访问，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间，所以一般会经历两个阶段：</p><ol><li>等待所有数据都准备好或者一直在等待数据，有数据的时候将数据拷贝到系统内核；</li><li>将内核缓存中数据拷贝到用户进程中；</li></ol><p>对于socket流而言：</p><ol><li>等待网络上的数据分组到达，然后被复制到内核的某个缓冲区；</li><li>把数据从内核缓冲区复制到应用进程缓冲区中；</li></ol><h2 id="同步阻塞IO"><a href="#同步阻塞IO" class="headerlink" title="同步阻塞IO"></a>同步阻塞IO</h2><blockquote><p>在JDK 1.4之前，主要就是同步阻塞IO模型，在Java里叫做<strong>BIO</strong>。</p></blockquote><p>在Java代码里调用IO相关接口，发起IO操作之后，Java程序就会同步等待，这个同步指的是Java程序调用IO API接口的层面而言。<br>而IO API在底层的IO操作是基于阻塞IO来的，向操作系统内核发起IO请求，系统内核会等待数据就位之后，才会执行IO操作，执行完毕了才会返回。</p><h2 id="同步非阻塞NIO"><a href="#同步非阻塞NIO" class="headerlink" title="同步非阻塞NIO"></a>同步非阻塞NIO</h2><blockquote><p>在JDK 1.4之后提供了NIO，概念是同步非阻塞。</p></blockquote><p>如果你调用NIO接口去执行IO操作，其实还是同步等待的，但是在底层的IO操作上 ，会对系统内核发起非阻塞IO请求，以非阻塞的形式来执行IO。<br>也就是说，如果底层数据没到位，那么内核返回异常信息，不会阻塞住，但是NIO接口内部会采用非阻塞方式过一会儿再次调用内核发起IO请求，直到成功为止。<br>但是之所以说是同步非阻塞，这里的“同步”指的就是因为在你的Java代码调用NIO接口层面是同步的，你还是要同步等待底层IO操作真正完成了才可以返回，只不过在执行底层IO的时候采用了非阻塞的方式来执行罢了。</p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>之前的同步非阻塞方式需要用户进程不停的轮询，但是IO多路复用不需要不停的轮询，而是派别人去帮忙循环查询多个任务的完成状态，UNIX/Linux 下的 <strong>select、poll、epoll</strong> 就是干这个的；select调用是内核级别的，select轮询相对非阻塞的轮询的区别在于—前者可以等待多个socket，能实现同时对多个IO端口进行监听，当其中任何一个socket的数据准好了，就能返回进行可读，然后进程再进行recvform系统调用，将数据由内核拷贝到用户进程，当然这个过程是阻塞的。select或poll调用之后，会阻塞进程，与blocking IO阻塞不同在于，此时的select不是等到socket数据全部到达再处理, 而是有了一部分数据（网络上的数据是分组到达的）就会调用用户进程来处理。监视的事情交给了内核，内核负责数据到达的处理。</p><p>以上总结就是：</p><ol><li>对多个socket进行监听，只要任何一个socket数据准备好就返回可读；</li><li>不等一个socket数据全部到达再处理，而是一部分socket的数据到达了就通知用户进程；</li></ol><blockquote><p>其实 select、poll、epoll 的原理就是不断的遍历所负责的所有的socket完成状态，当某个socket有数据到达了，就返回可读并通知用户进程来处理；</p></blockquote><h2 id="AIO以及异步IO"><a href="#AIO以及异步IO" class="headerlink" title="AIO以及异步IO"></a>AIO以及异步IO</h2><blockquote><p>JDK 1.7之后，又支持了AIO，也叫做NIO 2.0，他就支持异步IO模型。</p></blockquote><p>我们先说一下异步IO模型是什么意思。<br>简单来说，就是你的Java程序可以基于AIO API发起一个请求，比如说接收网络数据，AIO API底层会基于异步IO模型来调用操作系统内核。<br>此时不需要去管这个IO是否成功了，AIO接口会直接返回，你的Java程序也会直接返回。<br>因为BIO、NIO都是同步的，你发起IO请求，都必须同步等待IO操作完成。但是这里你发起一个IO请求，直接AIO接口就返回了，你就可以干别的事儿了，纯异步的方式。<br>不过你需要提供一个回调函数给AIO接口，一旦底层系统内核完成了具体的IO请求，比如网络读写之类的，就会回调你提供的回调函数。比如说你要是通过网络读取数据，那么此时AIO接口就会把操作系统异步读取到的数据交给你的回调函数。<br>整个过程如下图：<br><img src="https://upload-images.jianshu.io/upload_images/5937589-f7c8114bf6407354.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20190604123852.jpg"></p>]]></content>
    
    <summary type="html">
    
      同步、异步、阻塞、非阻塞
    
    </summary>
    
      <category term="IO" scheme="http://blog.linzhongtai.cn/categories/IO/"/>
    
    
      <category term="IO" scheme="http://blog.linzhongtai.cn/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 属性加载顺序</title>
    <link href="http://blog.linzhongtai.cn/2019/05/Spring-Boot-%E5%B1%9E%E6%80%A7%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/"/>
    <id>http://blog.linzhongtai.cn/2019/05/Spring-Boot-属性加载顺序/</id>
    <published>2019-05-28T03:48:24.000Z</published>
    <updated>2019-05-28T03:48:24.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><ol><li>在命令行中传入的参数</li><li>SPRING_APPLICATION_JSON 中的属性，SPRING_APPLICATION_JSON 是以JSON格式配置在系统环境变量中的内容</li><li>java:comp/env 中的JNI属性</li><li>Java的系统属性，可以通过System.getProperties()获得的内容</li><li>操作系统的环境变量</li><li>通过random.* 配置的随机属性</li><li><strong>位于当前应用 jar 包之外</strong>，针对不同{profile}环境的配置文件内容；例如application-{profile}.properties或是YAML定义的配置文件</li><li><strong>位于当前应用 jar 包之内</strong>，针对不同{profile}环境的配置文件内容；例如application-{profile}.properties或是YAML定义的配置文件</li><li><strong>位于当前应用 jar 包之外</strong>的application.properties和YAML配置内容</li><li><strong>位于当前应用 jar 包之内</strong>的application.properties和YAML配置内容</li><li>在@Configuration注解修改的类中，通过@PropertiesSource注解定义的属性</li><li>应用默认属性，使用SpringApplication.setDefaultProperties定义的内容</li></ol><blockquote><p>优先级由高到低，数字越小，优先级越高</p></blockquote><p>第7，9都是用应用jar包之外来读取配置文件，因此可以从此处进行切入，指定外部配置文件的加载位置来取代jar包之内的配置内容。</p>]]></content>
    
    <summary type="html">
    
      属性加载顺序
    
    </summary>
    
      <category term="SpringBoot" scheme="http://blog.linzhongtai.cn/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://blog.linzhongtai.cn/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot常用配置</title>
    <link href="http://blog.linzhongtai.cn/2019/05/SpringBoot%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.linzhongtai.cn/2019/05/SpringBoot常用配置/</id>
    <published>2019-05-28T01:42:17.000Z</published>
    <updated>2019-05-28T01:42:17.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="Bean的Scope"><a href="#Bean的Scope" class="headerlink" title="Bean的Scope"></a>Bean的Scope</h2><ul><li>Singleton：一个Spring容器中只有一个Bean的实例，此为Spring的默认配置，全容器共享一个实例</li><li>Prototype：每次调用新建一个Bean的实例</li><li>Request：Web项目中，给每一个http request新建一个Bean实例</li><li>Session：Web项目中，给每一个http session新建一个Bean实例</li><li>GlobalSession：只在portal应用中有用，给每一个global http session新建一个Bean实例</li></ul><h2 id="Spring-EL-和资源调节"><a href="#Spring-EL-和资源调节" class="headerlink" title="Spring EL 和资源调节"></a>Spring EL 和资源调节</h2><p>Spring主要在注解@Value的参数中使用表达式：</p><ol><li>注入普通字符串</li><li>注入操作系统属性</li><li>注入表达式运算结果</li><li>注入其他Bean的属性</li><li>注入文件内容</li><li>注入网址内容</li><li>注入属性文件</li></ol><h2 id="Bean的初始化和销毁"><a href="#Bean的初始化和销毁" class="headerlink" title="Bean的初始化和销毁"></a>Bean的初始化和销毁</h2><blockquote><p>在Bean使用之前或者之后要做些必要的操作，Spring对Bean的生命周期的操作提供了支持</p></blockquote><ol><li>Java配置方式：使用@Bean的initMethod和destoryMethod（相当于xml配置的init-method和destory-method）</li><li>注解方式：利用JSR-250的@PostConstruct和@PreDestory</li></ol><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>使用ThreadPoolTaskExecutor可实现一个基于线程池的TaskExecutor</p><blockquote><p> 在配置类中通过<strong>@EnableAsync</strong>开启对异步任务的支持，并通过在执行方法中使用<strong>@Async</strong>注解赖声明为异步任务</p></blockquote><h2 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h2><blockquote><p>首先在配置类注解<strong>@EnableScheduling</strong>来开启对计划任务的支持，然后在执行计划任务的方法上注解<strong>@Scheduled</strong>，声明为计划任务</p></blockquote><p>@Scheduled支持多种类型的计划任务，包含cron、fixDelay、fixRate等等</p>]]></content>
    
    <summary type="html">
    
      SpringBoot常用配置
    
    </summary>
    
      <category term="SpringBoot" scheme="http://blog.linzhongtai.cn/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://blog.linzhongtai.cn/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>CyclicBarrier、CountDownLatch、Semaphore的用法</title>
    <link href="http://blog.linzhongtai.cn/2019/04/CyclicBarrier%E3%80%81CountDownLatch%E3%80%81Semaphore%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://blog.linzhongtai.cn/2019/04/CyclicBarrier、CountDownLatch、Semaphore的用法/</id>
    <published>2019-04-29T09:49:05.000Z</published>
    <updated>2019-04-29T09:49:05.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="CyclicBarrier回环栅栏"><a href="#CyclicBarrier回环栅栏" class="headerlink" title="CyclicBarrier回环栅栏"></a>CyclicBarrier回环栅栏</h2><blockquote><p>等待至 barrier 状态再全部同时执行<br><strong>可重用</strong></p></blockquote><p>通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier 可以被重用。</p><p>CyclicBarrier 中最重要的方法就是 await 方法，它有 2 个重载版本：</p><ol><li>public int await()：用来挂起当前线程，直至所有线程都到达 barrier 状态再同时执行后续任务；</li><li>public int await(long timeout, TimeUnit unit)：让这些线程等待至一定的时间，如果还有线程没有到达 barrier 状态就直接让到达 barrier 的线程执行后续任务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  int N = 4;</span><br><span class="line">  CyclicBarrier barrier = new CyclicBarrier(N);</span><br><span class="line">  for(int i=0;i&lt;N;i++)</span><br><span class="line">    new Writer(barrier).start();</span><br><span class="line">  &#125;</span><br><span class="line">  static class Writer extends Thread&#123;</span><br><span class="line">    private CyclicBarrier cyclicBarrier;</span><br><span class="line">    public Writer(CyclicBarrier cyclicBarrier) &#123;</span><br><span class="line">      this.cyclicBarrier = cyclicBarrier;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        Thread.sleep(5000); //以睡眠来模拟线程需要预定写入数据操作</span><br><span class="line">        System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;写入数据完毕，等待其他线程写入完毕&quot;);</span><br><span class="line">        cyclicBarrier.await();</span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;catch(BrokenBarrierException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(&quot;所有线程写入完毕，继续处理其他任务，比如数据操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CyclicBarrier(int parties)：参数表示屏障拦截的线程数，每个线程调用await方法告CyclicBarrier已到达屏障，然后阻塞当前线程。</p><h2 id="CounDownLatch线程计数器"><a href="#CounDownLatch线程计数器" class="headerlink" title="CounDownLatch线程计数器"></a>CounDownLatch线程计数器</h2><blockquote><p>任务A，需要等其他四个任务完毕后，才执行。<br><strong>不可重用</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">final CountDownLatch latch = new CountDownLatch(2);</span><br><span class="line">  new Thread()&#123;public void run() &#123;</span><br><span class="line">      System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;正在执行&quot;);</span><br><span class="line">      Thread.sleep(3000);</span><br><span class="line">      System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;执行完毕&quot;);</span><br><span class="line">      latch.countDown();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;.start();</span><br><span class="line">  new Thread()&#123; public void run() &#123;</span><br><span class="line">      System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;正在执行&quot;);</span><br><span class="line">       Thread.sleep(3000);</span><br><span class="line">      System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;执行完毕&quot;);</span><br><span class="line">      latch.countDown();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;.start();</span><br><span class="line">System.out.println(&quot;等待 2 个子线程执行完毕...&quot;);</span><br><span class="line">latch.await();</span><br><span class="line">System.out.println(&quot;2 个子线程已经执行完毕&quot;);</span><br><span class="line">System.out.println(&quot;继续执行主线程&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等待N个线程，调用countDown，N减1，CountDownLatch的await方法会阻塞当前线程，直到N变成0，countDown可以放在线程中，也可以放到执行步骤中。</p><h2 id="SemaPhore信号量"><a href="#SemaPhore信号量" class="headerlink" title="SemaPhore信号量"></a>SemaPhore信号量</h2><blockquote><p>控制同时访问的线程个数.<br>通过acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。</p></blockquote><p>Semaphore 类中比较重要的几个方法：</p><ol><li>public void acquire(): 用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。</li><li>public void acquire(int permits):获取 permits 个许可</li><li>public void release() { } :释放许可。注意，在释放许可之前，必须先获获得许可。</li><li>public void release(int permits) { }:释放 permits 个许可</li></ol><p>上面 4 个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法</p><ol><li>public boolean tryAcquire():尝试获取一个许可，若获取成功，则立即返回 true，若获取失败，则立即返回 false</li><li>public boolean tryAcquire(long timeout, TimeUnit unit):尝试获取一个许可，若在指定的时间内获取成功，则立即返回 true，否则则立即返回 false</li><li>public boolean tryAcquire(int permits):尝试获取 permits 个许可，若获取成功，则立即返回 true，若获取失败，则立即返回 false</li><li>public boolean tryAcquire(int permits, long timeout, TimeUnit unit): 尝试获取 permits个许可，若在指定的时间内获取成功，则立即返回 true，否则则立即返回 false</li><li>还可以通过 availablePermits()方法得到可用的许可数目。</li></ol><p>例子：若一个工厂有5 台机器，但是有8个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过 Semaphore 来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int N = 8; //工人数</span><br><span class="line">Semaphore semaphore = new Semaphore(5); //机器数目</span><br><span class="line">for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">  new Worker(i,semaphore).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class Worker extends Thread&#123;</span><br><span class="line"></span><br><span class="line">private int num;</span><br><span class="line">private Semaphore semaphore;</span><br><span class="line">public Worker(int num,Semaphore semaphore)&#123;</span><br><span class="line">  this.num = num;</span><br><span class="line">  this.semaphore = semaphore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    semaphore.acquire();</span><br><span class="line">    System.out.println(&quot;工人&quot;+this.num+&quot;占用一个机器在生产...&quot;);</span><br><span class="line">    Thread.sleep(2000);</span><br><span class="line">    System.out.println(&quot;工人&quot;+this.num+&quot;释放出机器&quot;);</span><br><span class="line">    semaphore.release();</span><br><span class="line">  &#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      回环栅栏、线程计数器、信号量
    
    </summary>
    
      <category term="JAVA" scheme="http://blog.linzhongtai.cn/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://blog.linzhongtai.cn/tags/JAVA/"/>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>AQS与CAS</title>
    <link href="http://blog.linzhongtai.cn/2019/04/AQS%E4%B8%8ECAS/"/>
    <id>http://blog.linzhongtai.cn/2019/04/AQS与CAS/</id>
    <published>2019-04-29T09:29:16.000Z</published>
    <updated>2019-04-29T09:29:16.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="AQS（AbstractQueueSynchronizer）抽象队列同步器"><a href="#AQS（AbstractQueueSynchronizer）抽象队列同步器" class="headerlink" title="AQS（AbstractQueueSynchronizer）抽象队列同步器"></a>AQS（AbstractQueueSynchronizer）抽象队列同步器</h2><blockquote><p>维护了一个 int state（代表共享资源，volatile修饰）和一个 FIFO 线程等待队列（多线程争用资源被<br>阻塞时会进入此队列）</p></blockquote><h3 id="资源共享方式"><a href="#资源共享方式" class="headerlink" title="资源共享方式"></a>资源共享方式</h3><ul><li>独占—&gt;ReentrantLock</li><li>共享—&gt;Semaphore/CountDownLatch</li><li>独占+共享—&gt;ReentrantReadWriteLock</li></ul><h2 id="CAS（Compare-And-Swap-Set）比较并交换-乐观锁机制-锁自旋"><a href="#CAS（Compare-And-Swap-Set）比较并交换-乐观锁机制-锁自旋" class="headerlink" title="CAS（Compare And Swap/Set）比较并交换-乐观锁机制-锁自旋"></a>CAS（Compare And Swap/Set）比较并交换-乐观锁机制-锁自旋</h2><blockquote><p>当且仅当内存值V等于预期值A，才会将内存值设置为新值N</p></blockquote><ul><li>锁自旋—&gt;AtomicInteger.getAndIncrement</li><li>ABA问题—&gt;版本号解决</li></ul>]]></content>
    
    <summary type="html">
    
      什么是AQS？什么是CAS？
    
    </summary>
    
      <category term="JAVA" scheme="http://blog.linzhongtai.cn/categories/JAVA/"/>
    
    
      <category term="小知识" scheme="http://blog.linzhongtai.cn/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
      <category term="JAVA" scheme="http://blog.linzhongtai.cn/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Redis缓存淘汰策略</title>
    <link href="http://blog.linzhongtai.cn/2019/04/Redis%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/"/>
    <id>http://blog.linzhongtai.cn/2019/04/Redis缓存淘汰策略/</id>
    <published>2019-04-29T09:13:17.000Z</published>
    <updated>2019-04-29T09:13:17.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="常用的淘汰算法"><a href="#常用的淘汰算法" class="headerlink" title="常用的淘汰算法"></a>常用的淘汰算法</h2><ul><li>FIFO：First In First Out，先进先出。判断被存储的时间，离目前最远的数据优先被淘汰。</li><li>LRU：Least Recently Used，最近最少使用。判断最近被使用的时间，目前最远的数据优先被淘汰。</li><li>LFU：Least Frequently Used，最不经常使用。在一段时间内，数据被使用次数最少的，优先被淘汰。</li></ul><h2 id="Redis提供的淘汰策略："><a href="#Redis提供的淘汰策略：" class="headerlink" title="Redis提供的淘汰策略："></a>Redis提供的淘汰策略：</h2><ul><li>noeviction：达到内存限额后返回错误，客户尝试可以导致更多内存使用的命令（大部分写命令，但DEL和一些例外）</li><li>allkeys-lru：为了给新增加的数据腾出空间，驱逐键先试图移除一部分最近使用较少的（LRC）。</li><li>volatile-lru：为了给新增加的数据腾出空间，驱逐键先试图移除一部分最近使用较少的（LRC），但只限于过期设置键。</li><li>allkeys-random: 为了给新增加的数据腾出空间，驱逐任意键</li><li>volatile-random: 为了给新增加的数据腾出空间，驱逐任意键，但只限于有过期设置的驱逐键。</li><li>volatile-ttl: 为了给新增加的数据腾出空间，驱逐键只有秘钥过期设置，并且首先尝试缩短存活时间的驱逐键</li></ul>]]></content>
    
    <summary type="html">
    
      LRU
    
    </summary>
    
      <category term="redis" scheme="http://blog.linzhongtai.cn/categories/redis/"/>
    
    
      <category term="redis" scheme="http://blog.linzhongtai.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis中keys与scan特点</title>
    <link href="http://blog.linzhongtai.cn/2019/04/Redis%E4%B8%ADkeys%E4%B8%8Escan%E7%89%B9%E7%82%B9/"/>
    <id>http://blog.linzhongtai.cn/2019/04/Redis中keys与scan特点/</id>
    <published>2019-04-29T09:06:41.000Z</published>
    <updated>2019-04-29T09:06:41.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="keys缺点"><a href="#keys缺点" class="headerlink" title="keys缺点"></a>keys缺点</h2><ol><li>没有offset、limit参数，不能限制查询个数</li><li>keys是遍历算法，复杂度O(n)，数据量大的时候会导致redis卡顿</li></ol><h2 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h2><ol><li>复杂度O(n)，但是scan是通过游标分步进行，不阻塞</li><li>提供limit，可控制返回结果数</li><li>同keys一样，提供模式匹配</li><li>服务器不需要为游标保存状态，唯一状态是scan返回客户端的游标整数</li><li><strong>返回结果可能重复，需要客户端去重</strong></li><li>如果遍历过程中有数据修改，改动后的数据不保证同步</li><li>单次返回结果是空的，不表示遍历结束，而要看返回的游标值是否为0</li></ol>]]></content>
    
    <summary type="html">
    
      keys VS scan
    
    </summary>
    
      <category term="redis" scheme="http://blog.linzhongtai.cn/categories/redis/"/>
    
    
      <category term="redis" scheme="http://blog.linzhongtai.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之多线程并发：阻塞队列</title>
    <link href="http://blog.linzhongtai.cn/2019/04/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%9A%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>http://blog.linzhongtai.cn/2019/04/重温系列之多线程并发：阻塞队列/</id>
    <published>2019-04-01T11:48:51.000Z</published>
    <updated>2019-04-01T11:48:51.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>在阻塞队列中，线程阻塞有这样的两种情况：</p><ol><li>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放<br>入队列。</li><li>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有<br>空的位置，线程被自动唤醒。</li></ol><h2 id="阻塞队列的主要方法"><a href="#阻塞队列的主要方法" class="headerlink" title="阻塞队列的主要方法"></a>阻塞队列的主要方法</h2><table><thead><tr><th>方法类型</th><th>抛出异常</th><th>特殊值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>插入</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td>移除</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time,unit)</td></tr><tr><td>检查</td><td>element()</td><td>peek()</td><td>不可用</td><td>不可用</td></tr></tbody></table><ul><li>抛出异常：抛出一个异常</li><li>特殊值：返回一个特殊值（null 或 false,视情况而定）</li><li>阻塞：在成功操作之前，一直阻塞线程</li><li>超时：放弃前只在最大的时间内阻塞</li></ul><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><ol><li>public abstract boolean add(E paramE)：将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则抛出IllegalStateException。如果该元素是 NULL，则会抛出 NullPointerException 异常。</li><li>public abstract boolean offer(E paramE)：将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则返回false。</li><li><p>public abstract void put(E paramE) throws InterruptedException： 将指定元素插入此队列中，将等待可用的空间（如果有必要）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void put(E paramE) throws InterruptedException &#123;</span><br><span class="line">  checkNotNull(paramE);</span><br><span class="line">  ReentrantLock localReentrantLock = this.lock;</span><br><span class="line">  localReentrantLock.lockInterruptibly();</span><br><span class="line">  try &#123;</span><br><span class="line">    while (this.count == this.items.length)</span><br><span class="line">    this.notFull.await();//如果队列满了，则线程阻塞等待</span><br><span class="line">    enqueue(paramE);</span><br><span class="line">    localReentrantLock.unlock();</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    localReentrantLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入 BlockingQueue，则返回失败。</p></li></ol><h3 id="获取数据操作-："><a href="#获取数据操作-：" class="headerlink" title="获取数据操作 ："></a>获取数据操作 ：</h3><ol><li>poll(time):取走 BlockingQueue 里排在首位的对象,若不能立即取出,则可以等 time 参数规定的时间,取不到时返回 null;</li><li>poll(long timeout, TimeUnit unit)：从 BlockingQueue 取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则直到时间超时还没有数据可取，返回失败。</li><li>take():取走 BlockingQueue 里排在首位的对象,若 BlockingQueue 为空,阻断进入等待状态直到 BlockingQueue 有新的数据被加入。</li><li>drainTo():一次性从 BlockingQueue 获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。</li></ol><h2 id="Java-中的阻塞队列"><a href="#Java-中的阻塞队列" class="headerlink" title="Java 中的阻塞队列"></a>Java 中的阻塞队列</h2><p><img src="https://blog2019.oss-cn-shenzhen.aliyuncs.com/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.jpg" alt=""></p><h3 id="ArrayBlockingQueue-：由数组结构组成的有界阻塞队列"><a href="#ArrayBlockingQueue-：由数组结构组成的有界阻塞队列" class="headerlink" title="ArrayBlockingQueue ：由数组结构组成的有界阻塞队列"></a>ArrayBlockingQueue ：由数组结构组成的有界阻塞队列</h3><blockquote><p>公平、非公平</p></blockquote><p>用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000,true);</span><br></pre></td></tr></table></figure></p><h3 id="LinkedBlockingQueue-：由链表结构组成的有界阻塞队列。"><a href="#LinkedBlockingQueue-：由链表结构组成的有界阻塞队列。" class="headerlink" title="LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。"></a>LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。</h3><blockquote><p>两个独立锁提高并发</p></blockquote><p>基于链表的阻塞队列，同ArrayListBlockingQueue类似，此队列按照先进先出（FIFO）的原则对元素进行排序。而 LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。<br>LinkedBlockingQueue 会默认一个类似无限大小的容量（Integer.MAX_VALUE）。</p><h3 id="PriorityBlockingQueue-：支持优先级排序的无界阻塞队列。"><a href="#PriorityBlockingQueue-：支持优先级排序的无界阻塞队列。" class="headerlink" title="PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。"></a>PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。</h3><blockquote><p>compareTo 排序实现优先</p></blockquote><p>是一个支持优先级的无界队列。默认情况下元素采取自然顺序升序排列。可以自定义实现compareTo()方法来指定元素进行排序规则，或者初始化 PriorityBlockingQueue 时，指定构造参数 Comparator 来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p><h3 id="DelayQueue：使用优先级队列实现的无界阻塞队列。"><a href="#DelayQueue：使用优先级队列实现的无界阻塞队列。" class="headerlink" title="DelayQueue：使用优先级队列实现的无界阻塞队列。"></a>DelayQueue：使用优先级队列实现的无界阻塞队列。</h3><blockquote><p>缓存失效、定时任务</p></blockquote><p>是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现 Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。我们可以将 DelayQueue 运用在以下应用场景：</p><ol><li>缓存系统的设计：可以用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从 DelayQueue 中获取元素时，表示缓存有效期到了。</li><li>定时任务调度：使用 DelayQueue 保存当天将会执行的任务和执行时间，一旦从DelayQueue 中获取到任务就开始执行，从比如 TimerQueue 就是使用 DelayQueue实现的。</li></ol><h3 id="SynchronousQueue：不存储元素的阻塞队列。"><a href="#SynchronousQueue：不存储元素的阻塞队列。" class="headerlink" title="SynchronousQueue：不存储元素的阻塞队列。"></a>SynchronousQueue：不存储元素的阻塞队列。</h3><blockquote><p>不存储数据、可用于传递数据</p></blockquote><p><strong>是一个不存储元素的阻塞队列。每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素</strong>。SynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合于传递性场景,比如在一个线程中使用的数据，传递给另外一个线程使用，SynchronousQueue的吞吐量高于LinkedBlockingQueue 和ArrayBlockingQueue。</p><h3 id="LinkedTransferQueue：由链表结构组成的无界阻塞队列。"><a href="#LinkedTransferQueue：由链表结构组成的无界阻塞队列。" class="headerlink" title="LinkedTransferQueue：由链表结构组成的无界阻塞队列。"></a>LinkedTransferQueue：由链表结构组成的无界阻塞队列。</h3><p>是 一 个 由 链 表 结 构 组 成 的 无 界 阻 塞 TransferQueue 队 列 。 相 对 于 其 他 阻 塞 队 列 ，LinkedTransferQueue 多了 tryTransfer 和 transfer 方法。</p><ol><li>transfer 方法：如果当前有消费者正在等待接收元素（消费者使用 take()方法或带时间限制的poll()方法时），transfer 方法可以把生产者传入的元素立刻 transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer 方法会将元素存放在队列的 tail 节点，并等到该元素被消费者消费了才返回。</li><li>tryTransfer 方法。则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回 false。和 transfer 方法的区别是 tryTransfer 方法无论消费者是否接收，方法立即返回。而 transfer 方法是必须等到消费者消费了才返回。</li></ol><p>对于带有时间限制的 tryTransfer(E e, long timeout, TimeUnit unit)方法，则是试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回 false，如果在超时时间内消费了元素，则返回 true。</p><h3 id="LinkedBlockingDeque：由链表结构组成的双向阻塞队列"><a href="#LinkedBlockingDeque：由链表结构组成的双向阻塞队列" class="headerlink" title="LinkedBlockingDeque：由链表结构组成的双向阻塞队列"></a>LinkedBlockingDeque：由链表结构组成的双向阻塞队列</h3><p><strong>是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素。</strong><br>双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque 多了 addFirst，addLast，offerFirst，offerLast，peekFirst，peekLast 等方法，以 First 单词结尾的方法，表示插入，获取（peek）或移除双端队列的第一个元素。以 Last 单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素。另外插入方法 add 等同于 addLast，移除方法 remove 等效于 removeFirst。但是 take 方法却等同于 takeFirst，不知道是不是 Jdk 的 bug，使用时还是用带有 First 和 Last 后缀的方法更清楚。<br>在初始化 LinkedBlockingDeque 时可以设置容量防止其过渡膨胀。另外双向阻塞队列可以运用在“工作窃取”模式中。</p>]]></content>
    
    <summary type="html">
    
      阻塞、超时、抛出异常...
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之多线程并发：线程池原理</title>
    <link href="http://blog.linzhongtai.cn/2019/04/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/"/>
    <id>http://blog.linzhongtai.cn/2019/04/重温系列之多线程并发：线程池原理/</id>
    <published>2019-04-01T11:45:59.000Z</published>
    <updated>2019-04-01T11:45:59.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量则<strong>超出数量的线程排队等候</strong>，等其它线程执行完毕，再从队列中取出任务来执行。他的主要特点为：<strong>线程复用、控制最大并发数、管理线程</strong>。</p></blockquote><h2 id="线程复用"><a href="#线程复用" class="headerlink" title="线程复用"></a>线程复用</h2><p>每一个 Thread 的类都有一个 start 方法。 当调用 start 启动线程时 Java 虚拟机会调用该类的 run方法。 那么该类的 run() 方法中就是调用了 Runnable 对象的 run() 方法。 <strong>我们可以继承重写Thread 类，在其 start 方法中添加不断循环调用传递过来的 Runnable 对象</strong>。 这就是线程池的实现原理。<strong>循环方法中不断获取 Runnable 是用 Queue 实现的</strong>，在获取下一个 Runnable 之前可以是阻塞的。</p><h2 id="线程池的组成"><a href="#线程池的组成" class="headerlink" title="线程池的组成"></a>线程池的组成</h2><ol><li>线程池管理器：用于创建并管理线程池</li><li>工作线程：线程池中的线程</li><li>任务接口：每个任务必须实现的接口，用于工作线程调度其运行</li><li>任务队列：用于存放待处理的任务，提供一种缓冲机制</li></ol><p>Java 中的线程池是通过 Executor 框架实现的，该框架中用到了 Executor，Executors，ExecutorService，ThreadPoolExecutor ，Callable 和 Future、FutureTask 这几个类。<br><img src="https://blog2019.oss-cn-shenzhen.aliyuncs.com/1554104383%281%29.jpg" alt=""><br>ThreadPoolExecutor 的构造方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize, long keepAliveTime,</span><br><span class="line">                    TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123;</span><br><span class="line">          this(corePoolSize, maximumPoolSize, keepAliveTime, unit, </span><br><span class="line">                workQueue,Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>corePoolSize：指定了线程池中的线程数量。</li><li>maximumPoolSize：指定了线程池中的最大线程数量。</li><li>keepAliveTime：当前线程池数量超过 corePoolSize 时，多余的空闲线程的存活时间，即多次时间内会被销毁。</li><li>unit：keepAliveTime 的单位。</li><li>workQueue：任务队列，被提交但尚未被执行的任务。</li><li>threadFactory：线程工厂，用于创建线程，一般用默认的即可。</li><li>handler：拒绝策略，当任务太多来不及处理，如何拒绝任务。</li></ol><h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><p>线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。JDK 内置的拒绝策略如下：</p><ol><li>AbortPolicy ： 直接抛出异常，阻止系统正常运行。</li><li>CallerRunsPolicy ： 只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。</li><li>DiscardOldestPolicy ： 丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。</li><li>DiscardPolicy ： 该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方案。</li></ol><p>以上内置拒绝策略均实现了 RejectedExecutionHandler 接口，若以上策略仍无法满足实际需要，完全可以自己扩展 RejectedExecutionHandler 接口。</p><h2 id="Java线程池工作过程"><a href="#Java线程池工作过程" class="headerlink" title="Java线程池工作过程"></a>Java线程池工作过程</h2><ol><li>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</li><li>当调用 execute() 方法添加一个任务时，线程池会做如下判断：<br>a)  如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；<br>b) 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；<br>c)  如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；<br>d) 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常 RejectExecutionException。</li><li>当一个线程完成任务时，它会从队列中取下一个任务来执行。</li><li>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。<br><img src="https://blog2019.oss-cn-shenzhen.aliyuncs.com/java%E7%BA%BF%E7%A8%8B%E6%B1%A0.jpg" alt=""></li></ol>]]></content>
    
    <summary type="html">
    
      线程复用、控制最大并发数、管理线程
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之多线程并发：锁的优化</title>
    <link href="http://blog.linzhongtai.cn/2019/04/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%9A%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>http://blog.linzhongtai.cn/2019/04/重温系列之多线程并发：锁的优化/</id>
    <published>2019-04-01T11:44:49.000Z</published>
    <updated>2019-04-01T11:44:49.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="减少锁持有时间"><a href="#减少锁持有时间" class="headerlink" title="减少锁持有时间"></a>减少锁持有时间</h2><blockquote><p>只用在需要线程安全的方法上加锁</p></blockquote><h2 id="减小锁粒度"><a href="#减小锁粒度" class="headerlink" title="减小锁粒度"></a>减小锁粒度</h2><p>将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是ConcurrentHashMap。</p><h2 id="锁分离"><a href="#锁分离" class="headerlink" title="锁分离"></a>锁分离</h2><p>最常见的锁分离就是读写锁 ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如下面的LinkedBlockingQueue 从头部取出，从尾部放数据<br><img src="https://blog2019.oss-cn-shenzhen.aliyuncs.com/%E9%94%81%E5%88%86%E7%A6%BB.png" alt=""></p><h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。但是，凡事都有一个度，<strong>如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void demoMethod()&#123;  </span><br><span class="line">synchronized(lock)&#123;   </span><br><span class="line">//do sth.  </span><br><span class="line">&#125;  </span><br><span class="line">//做其他不需要的同步的工作，但能很快执行完毕  </span><br><span class="line">synchronized(lock)&#123;   </span><br><span class="line">//do sth.  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况，根据锁粗化的思想，应该合并<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void demoMethod()&#123;  </span><br><span class="line">//整合成一次锁请求 </span><br><span class="line">synchronized(lock)&#123;   </span><br><span class="line">//do sth.   </span><br><span class="line">//做其他不需要的同步的工作，但能很快执行完毕  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然这是有前提的，前提就是中间的那些不需要同步的工作是很快执行完成的。</p><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><blockquote><p>在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作。</p></blockquote><p>也许你会觉得奇怪，既然有些对象不可能被多线程访问，那为什么要加锁呢？写代码时直接不加锁不就好了。<br>但是有时，这些锁并不是程序员所写的，有的是JDK实现中就有锁的，比如Vector和StringBuffer这样的类，它们中的很多方法都是有锁的。当我们在一些不会有线程安全的情况下使用这些类的方法时，达到某些条件时，编译器会将锁消除来提高性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000000</span>; i++) &#123;</span><br><span class="line">createStringBuffer(<span class="string">"JVM"</span>, <span class="string">"Diagnosis"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> bufferCost = System.currentTimeMillis() - start;</span><br><span class="line">System.out.println(<span class="string">"craeteStringBuffer: "</span> + bufferCost + <span class="string">" ms"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">sb.append(s1);</span><br><span class="line">sb.append(s2);</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuffer.append是一个同步操作，但是StringBuffer却是一个局部变量，并且方法也并没有把StringBuffer返回，所以不可能会有多线程去访问它，那么此时StringBuffer中的同步操作就是没有意义的。</p><p>开启锁消除是在JVM参数上设置的，当然需要在server模式下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks</span><br></pre></td></tr></table></figure></p><p>并且要开启<strong><a href="http://www.importnew.com/23150.html" target="_blank" rel="noopener">逃逸分析</a></strong>。<br> 逃逸分析的作用呢，就是看看变量是否有可能逃出作用域的范围：<br>比如上述的StringBuffer，上述代码中craeteStringBuffer的返回是一个String，所以这个局部变量StringBuffer在其他地方都不会被使用。如果将craeteStringBuffer改成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static StringBuffer craeteStringBuffer(String s1, String s2) &#123;</span><br><span class="line">StringBuffer sb = new StringBuffer();</span><br><span class="line">sb.append(s1);</span><br><span class="line">sb.append(s2);</span><br><span class="line">return sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么这个 StringBuffer被返回后，是有可能被任何其他地方所使用的（譬如被主函数将返回结果put进map啊等等）。那么JVM的逃逸分析可以分析出，这个局部变量 StringBuffer逃出了它的作用域。<br>所以基于逃逸分析，JVM可以判断，如果这个局部变量StringBuffer并没有逃出它的作用域，那么可以确定这个StringBuffer并不会被多线程所访问，那么就可以把这些多余的锁给去掉来提高性能</p>]]></content>
    
    <summary type="html">
    
      优化路漫漫
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
      <category term="锁" scheme="http://blog.linzhongtai.cn/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之多线程并发：锁分类</title>
    <link href="http://blog.linzhongtai.cn/2019/04/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%9A%E9%94%81%E5%88%86%E7%B1%BB/"/>
    <id>http://blog.linzhongtai.cn/2019/04/重温系列之多线程并发：锁分类/</id>
    <published>2019-04-01T11:42:35.000Z</published>
    <updated>2019-04-01T11:42:35.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><blockquote><p>可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。在 JAVA 环境下 ReentrantLock 和 synchronized 都是 可重入锁。</p></blockquote><h2 id="ReadWriteLock-读写锁"><a href="#ReadWriteLock-读写锁" class="headerlink" title="ReadWriteLock  读写锁"></a>ReadWriteLock  读写锁</h2><p><strong>为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制</strong>，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。</p><h3 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h3><p>如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁</p><h3 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h3><p>如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁。<br>Java中读写锁有个接口：java.util.concurrent.locks.ReadWriteLock，也有具体的实现ReentrantReadWriteLock。</p><h2 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h2><blockquote><p>java 并发包提供的加锁模式分为独占锁和共享锁</p></blockquote><h3 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h3><p>独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。</p><h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><p>共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。</p><ol><li>AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等待线程的锁获取模式。</li><li>java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，或者被一个 写操作访问，但两者不能同时进行。</li></ol><h2 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h2><h3 id="公平锁（-Fair-）"><a href="#公平锁（-Fair-）" class="headerlink" title="公平锁（ Fair ）"></a>公平锁（ Fair ）</h3><blockquote><p>加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得</p></blockquote><h3 id="非公平锁（-Nonfair-）"><a href="#非公平锁（-Nonfair-）" class="headerlink" title="非公平锁（ Nonfair ）"></a>非公平锁（ Nonfair ）</h3><blockquote><p>加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待</p></blockquote><ol><li>非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个队列</li><li>Java 中的 synchronized 是非公平锁，ReentrantLock 默认的 lock()方法采用的是非公平锁。</li></ol><h2 id="偏向锁-轻量级锁-重量级锁"><a href="#偏向锁-轻量级锁-重量级锁" class="headerlink" title="偏向锁/轻量级锁/重量级锁"></a>偏向锁/轻量级锁/重量级锁</h2><blockquote><p>锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀。<br>【但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级】</p></blockquote><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>使用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td>适用于只有一个线程访问同步块场景。</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度。</td><td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td><td>追求响应时间。同步块执行速度非常快。</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU。</td><td>线程阻塞，响应时间缓慢。</td><td>追求吞吐量。同步块执行速度较长。</td></tr></tbody></table><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。<strong>偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。</strong>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，<strong>而偏向锁只需要在置换ThreadID 的时候依赖一次 CAS 原子指令</strong>（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。上面说过，<strong>轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</strong></p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，<strong>轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。</strong></p><h3 id="重量级锁-Mutex-Lock"><a href="#重量级锁-Mutex-Lock" class="headerlink" title="重量级锁(Mutex Lock)"></a>重量级锁(Mutex Lock)</h3><p>Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为“重量级锁”。JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。</p><h2 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h2><blockquote><p>分段锁并非一种实际的锁，而是一种思想<br>ConcurrentHashMap的segment是学习分段锁的最好实践</p></blockquote><p>HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术。<strong>首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问</strong></p>]]></content>
    
    <summary type="html">
    
      可重入锁/读写锁/共享锁独占锁/公平锁非公平锁/ 偏向锁/轻量级锁/重量级锁...
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
      <category term="锁" scheme="http://blog.linzhongtai.cn/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之多线程并发：AtomicInteger</title>
    <link href="http://blog.linzhongtai.cn/2019/04/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%9AAtomicInteger/"/>
    <id>http://blog.linzhongtai.cn/2019/04/重温系列之多线程并发：AtomicInteger/</id>
    <published>2019-04-01T09:42:33.000Z</published>
    <updated>2019-04-01T09:42:33.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>此处 AtomicInteger，一个提供原子操作的 Integer 的类，常见的还有AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference 等，他们的实现原理相同，区别在与运算对象类型的不同。令人兴奋地，还可以通过 AtomicReference<v>将一个对象的所有操作转化成原子操作。</v></p></blockquote><p><strong>在多线程程序中，诸如++i 或 i++等运算不具有原子性，是不安全的线程操作之一。</strong>通常我们会使用 synchronized 将该操作变成一个原子操作，但JVM为此类操作特意提供了一些同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常AtomicInteger的性能是 ReentrantLock 的好几倍。</p>]]></content>
    
    <summary type="html">
    
      AtomicInteger，一个提供原子操作的 Integer 的类
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之多线程并发：Semaphore信号量</title>
    <link href="http://blog.linzhongtai.cn/2019/04/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%9ASemaphore%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    <id>http://blog.linzhongtai.cn/2019/04/重温系列之多线程并发：Semaphore信号量/</id>
    <published>2019-04-01T09:41:54.000Z</published>
    <updated>2019-04-01T09:41:54.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore 可以用来构建一些对象池，资源池之类的，比如数据库连接池。</p></blockquote><h2 id="实现互斥锁（计数器为-1-）"><a href="#实现互斥锁（计数器为-1-）" class="headerlink" title="实现互斥锁（计数器为 1 ）"></a>实现互斥锁（计数器为 1 ）</h2><blockquote><p>我们也可以创建计数为 1 的 Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个计数阈值为 5 的信号量对象</span><br><span class="line">// 只能 5 个线程同时访问</span><br><span class="line">Semaphore semp = new Semaphore(5);</span><br><span class="line">try &#123;  // 申请许可</span><br><span class="line">  semp.acquire();</span><br><span class="line">  try &#123;</span><br><span class="line">    // 业务逻辑</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    // 释放许可</span><br><span class="line">    semp.release();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Semaphore-与-ReentrantLock"><a href="#Semaphore-与-ReentrantLock" class="headerlink" title="Semaphore  与 ReentrantLock"></a>Semaphore  与 ReentrantLock</h2><p>Semaphore 基本能完成 ReentrantLock 的所有工作，使用方法也与之类似，通过 acquire()与release()方法来获得和释放临界资源。经实测，Semaphone.acquire()方法默认为可响应中断锁，与 ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被Thread.interrupt()方法中断。</p><p>此外，Semaphore 也实现了可轮询的锁请求与定时锁的功能，除了方法名 tryAcquire 与 tryLock不同，其使用方法与 ReentrantLock几乎一致。Semaphore也提供了公平与非公平锁的机制，也可在构造函数中进行设定。</p><p>Semaphore的锁释放操作也由手动进行，因此与 ReentrantLock 一样，为避免线程因抛出异常而无法正常释放锁的情况发生，释放锁的操作也必须在 finally 代码块中完成。</p>]]></content>
    
    <summary type="html">
    
      Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore 可以用来构建一些对象池，资源池之类的，比如数据库连接池。
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
      <category term="锁" scheme="http://blog.linzhongtai.cn/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之多线程并发：ReentrantLock</title>
    <link href="http://blog.linzhongtai.cn/2019/04/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%9AReentrantLock/"/>
    <id>http://blog.linzhongtai.cn/2019/04/重温系列之多线程并发：ReentrantLock/</id>
    <published>2019-04-01T09:41:12.000Z</published>
    <updated>2019-04-01T09:41:12.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>ReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。</p></blockquote><h2 id="Lock接口的主要方法"><a href="#Lock接口的主要方法" class="headerlink" title="Lock接口的主要方法"></a>Lock接口的主要方法</h2><ol><li>void lock(): 执行此方法时, <strong>如果锁处于空闲状态, 当前线程将获取到锁</strong>。相反, 如果锁已经被其他线程持有, 将禁用当前线程, 直到当前线程获取到锁。<strong>获得锁就返回 true，不能的话一直等待获得锁。</strong></li><li>boolean tryLock()：<strong>如果锁可用, 则获取锁, 并立即返回 true, 否则返回 false。</strong>该方法和lock()的区别在于, tryLock()只是”试图”获取锁, 如果锁不可用, 不会导致当前线程被禁用,当前线程仍然继续往下执行代码. 而 lock()方法则是一定要获取到锁, 如果锁不可用, 就一直等待, 在未获得锁之前,当前线程并不继续向下执行.</li><li>void unlock()：执行此方法时, 当前线程将释放持有的锁. 锁只能由持有者释放, 如果线程并不持有锁, 却执行该方法, 可能导致异常的发生.</li><li>Condition newCondition()：条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的 await()方法，而调用后，当前线程将缩放锁。</li><li>getHoldCount() ：查询当前线程保持此锁的次数，也就是执行此线程执行lock方法的次数。</li><li>getQueueLength（）：返回正等待获取此锁的线程估计数，比如启动 10 个线程，1 个线程获得锁，此时返回的是 9</li><li>getWaitQueueLength：（Condition condition）返回等待与此锁相关的给定条件的线程估计数。比如 10 个线程，用同一个 condition 对象，并且此时这 10 个线程都执行了condition 对象的 await 方法，那么此时执行此方法返回 10</li><li>hasWaiters(Condition condition)：查询是否有线程等待与此锁有关的给定条件<br>(condition)，对于指定 contidion 对象，有多少线程执行了 condition.await 方法</li><li>hasQueuedThread(Thread thread)：查询给定线程是否等待获取此锁</li><li>hasQueuedThreads()：是否有线程等待此锁</li><li>isFair()：该锁是否公平锁</li><li>isHeldByCurrentThread()： 当前线程是否保持锁锁定，线程的执行 lock 方法的前后分别是 false 和 true</li><li>isLock()：此锁是否有任意线程占用</li><li>lockInterruptibly（）：如果当前线程未被中断，获取锁</li><li>tryLock（）：尝试获得锁，仅在调用时锁未被线程占用，获得锁</li><li>tryLock(long timeout TimeUnit unit)：如果锁在给定等待时间内没有被另一个线程保持，则获取该锁。</li></ol><h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><p>JVM 按随机、就近原则分配锁的机制则称为不公平锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式，默认为非公平锁。非公平锁实际执行的效率要远远超出公平锁，除非程序有特殊需要，否则最常用非公平锁的分配机制。</p><h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><p>公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式来定义公平锁</p><h2 id="ReentrantLock与Synchronized"><a href="#ReentrantLock与Synchronized" class="headerlink" title="ReentrantLock与Synchronized"></a>ReentrantLock与Synchronized</h2><ol><li>ReentrantLock 通过方法 lock()与 unlock()来进行加锁与解锁操作，与<strong>synchronized 会被 JVM 自动解锁机制不同，ReentrantLock 加锁后需要手动进行解锁</strong>。为了避免程序出现异常而无法正常解锁的情况，使用 ReentrantLock 必须在 finally 控制块中进行解锁操作。</li><li>ReentrantLock 相比 synchronized 的优势是可中断、公平锁、多个锁。这种情况下需要使用 ReentrantLock。</li></ol><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ol><li>都是用来协调多线程对共享对象、变量的访问</li><li>都是可重入锁，同一线程可以多次获得同一个锁</li><li>都保证了可见性和互斥性</li></ol><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ol><li>ReentrantLock 显示的获得、释放锁，synchronized 隐式获得释放锁</li><li>ReentrantLock 可响应中断、可轮回，synchronized 是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性</li><li>ReentrantLock 是 API 级别的，synchronized 是 JVM 级别的</li><li>ReentrantLock 可以实现公平锁</li><li>ReentrantLock 通过 Condition 可以绑定多个条件</li><li>底层实现不一样， synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻塞，采用的是乐观并发策略</li><li>Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现。</li><li>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁。</li><li>Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断。</li><li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li><li>Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等。</li></ol><h2 id="ReentrantLock实现"><a href="#ReentrantLock实现" class="headerlink" title="ReentrantLock实现"></a>ReentrantLock实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MyService &#123;</span><br><span class="line">  private Lock lock = new ReentrantLock();</span><br><span class="line">  //Lock lock=new ReentrantLock(true);//公平锁</span><br><span class="line">  //Lock lock=new ReentrantLock(false);//非公平锁</span><br><span class="line">  private Condition condition=lock.newCondition();//创建 Condition</span><br><span class="line">  public void testMethod() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      lock.lock();//lock 加锁</span><br><span class="line">      //1：wait 方法等待：</span><br><span class="line">      //System.out.println(&quot;开始 wait&quot;);</span><br><span class="line">      condition.await();</span><br><span class="line">      //通过创建 Condition 对象来使线程 wait，必须先执行 lock.lock 方法获得锁</span><br><span class="line">      //:2：signal 方法唤醒</span><br><span class="line">      condition.signal();//condition 对象的 signal 方法可以唤醒 wait 线程</span><br><span class="line">      for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        System.out.println(&quot;ThreadName=&quot; + Thread.currentThread().getName()+ (&quot; &quot; + (i + 1)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;finally&#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Condition-类和-Object-类锁方法区别区别"><a href="#Condition-类和-Object-类锁方法区别区别" class="headerlink" title="Condition 类和 Object 类锁方法区别区别"></a>Condition 类和 Object 类锁方法区别区别</h2><ol><li>Condition 类的 awiat 方法和 Object 类的 wait 方法等效</li><li>Condition 类的 signal 方法和 Object 类的 notify 方法等效</li><li>Condition 类的 signalAll 方法和 Object 类的 notifyAll 方法等效</li><li><strong>ReentrantLock 类可以唤醒指定条件的线程，而 object 的唤醒是随机的</strong></li></ol><h2 id="tryLock-和-lock-和-lockInterruptibly-的区别"><a href="#tryLock-和-lock-和-lockInterruptibly-的区别" class="headerlink" title="tryLock 和 lock 和 lockInterruptibly 的区别"></a>tryLock 和 lock 和 lockInterruptibly 的区别</h2><ol><li>tryLock 能获得锁就返回 true，不能就立即返回 false，tryLock(long timeout,TimeUnit unit)，可以增加时间限制，如果超过该时间段还没获得锁，返回 false</li><li>lock 能获得锁就返回 true，不能的话一直等待获得锁</li><li>lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程，lock 不会抛出异常，而 lockInterruptibly 会抛出异常</li></ol>]]></content>
    
    <summary type="html">
    
      ReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
      <category term="锁" scheme="http://blog.linzhongtai.cn/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之多线程并发：Synchronized同步锁</title>
    <link href="http://blog.linzhongtai.cn/2019/04/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%9ASynchronized%E5%90%8C%E6%AD%A5%E9%94%81/"/>
    <id>http://blog.linzhongtai.cn/2019/04/重温系列之多线程并发：Synchronized同步锁/</id>
    <published>2019-04-01T09:39:47.000Z</published>
    <updated>2019-04-01T09:39:47.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>synchronized 它可以把任意一个非NULL的对象当作锁，属于独占式的悲观锁，同时属于可重入锁。</p></blockquote><h2 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h2><ol><li>作用于方法时，锁住的是对象的实例(this)；</li><li>当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久代PermGen(jdk1.8则是 metaspace)，永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程；</li><li>synchronized 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。</li></ol><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><ol><li>Wait Set：那些调用 wait 方法被阻塞的线程被放置在这里；</li><li>Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；</li><li>Entry List：Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中；</li><li>OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为 OnDeck；</li><li>Owner：当前已经获取到所资源的线程被称为 Owner；</li><li>!Owner：当前释放锁的线程。</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><img src="https://blog2019.oss-cn-shenzhen.aliyuncs.com/synchronized.jpg" alt=""></p><ol><li>JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList 会被大量的并发线程进行 CAS 访问，为了降低对尾部元素的竞争，JVM 会将<br>一部分线程移动到 EntryList 中作为候选竞争线程。</li><li>Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并指定EntryList 中的某个线程为 OnDeck 线程（一般是最先进去的那个线程）。</li><li>Owner 线程并不直接把锁传递给 OnDeck 线程，而是把锁竞争的权利交给 OnDeck，OnDeck需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在JVM 中，也把这种选择行为称之为“竞争切换”。</li><li>OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 EntryList中。如果Owner线程被wait方法阻塞，则转移到WaitSet队列中，直到某个时刻通过notify或者 notifyAll 唤醒，会重新进去 EntryList 中。</li><li>处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux 内核下采用 pthread_mutex_lock 内核函数实现的）。</li><li>Synchronized 是非公平锁。 Synchronized 在线程进入 ContentionList 时，等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁<br>资源。<br>参考：<a href="https://blog.csdn.net/zqz_zqz/article/details/70233767" target="_blank" rel="noopener">https://blog.csdn.net/zqz_zqz/article/details/70233767</a></li><li>每个对象都有个 monitor 对象，加锁就是在竞争 monitor 对象，代码块加锁是在前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的</li><li>synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。</li><li>Java1.6，synchronized 进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。</li><li>锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀；</li><li>JDK 1.6 中默认是开启偏向锁和轻量级锁，可以通过-XX:-UseBiasedLocking 来禁用偏向锁</li></ol>]]></content>
    
    <summary type="html">
    
      synchronized 它可以把任意一个非NULL的对象当作锁，属于独占式的悲观锁，同时属于可重入锁。
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
      <category term="锁" scheme="http://blog.linzhongtai.cn/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之多线程并发：自旋锁</title>
    <link href="http://blog.linzhongtai.cn/2019/03/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%9A%E8%87%AA%E6%97%8B%E9%94%81/"/>
    <id>http://blog.linzhongtai.cn/2019/03/重温系列之多线程并发：自旋锁/</id>
    <published>2019-03-31T05:49:48.000Z</published>
    <updated>2019-03-31T05:49:48.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p></blockquote><p>自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。</p><p>线程自旋是需要消耗cpu的，说白了就是让cpu在做无用功，如果一直获取不到锁，那线程也不能一直占用cpu自旋做无用功，所以需要设定一个自旋等待的最大时间。</p><p>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p><h2 id="自旋锁的优缺点"><a href="#自旋锁的优缺点" class="headerlink" title="自旋锁的优缺点"></a>自旋锁的优缺点</h2><ul><li>优点</li></ul><p>自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换</p><ul><li>缺点</li></ul><p>如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为<strong>自旋锁在获取锁前一直都是占用 cpu 做无用功</strong>，占着茅坑不 拉屎，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要cpu的线程又不能获取到cpu，造成 cpu 的浪费，所以这种情况下我们要关闭自旋锁。</p><h2 id="自旋锁时间阈值-1-6-引入了适应性自旋锁"><a href="#自旋锁时间阈值-1-6-引入了适应性自旋锁" class="headerlink" title="自旋锁时间阈值(1.6 引入了适应性自旋锁)"></a>自旋锁时间阈值(1.6 引入了适应性自旋锁)</h2><p>自旋锁的目的是为了占着 CPU 的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选择额外重要。<br>JVM对于自旋周期的选择，jdk1.5这个限度是一定的写死的，在<strong>1.6引入了适应性自旋锁</strong>，适应性自旋锁意味着自旋的时间不在是固定的了，而是<strong>由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定</strong>，基本认为一个线程上下文切换的时间是最佳的一个时间，同时JVM还针对当前CPU的负荷情况做了较多的优化。</p><ol><li>如果平均负载小于CPUs则一直自旋</li><li>如果有超过(CPUs/2)个线程正在自旋，则后来线程直接阻塞</li><li>如果正在自旋的线程发现Owner发生了变化则延迟自旋时间（自旋计数）或进入阻塞</li><li>如果CPU处于节电模式则停止自旋</li><li>自旋时间的最坏情况是CPU的存储延迟（CPU A存储了一个数据，到CPU B得知这个数据直接的时间差）</li><li>自旋时会适当放弃线程优先级之间的差异</li></ol><h2 id="自旋锁的开启"><a href="#自旋锁的开启" class="headerlink" title="自旋锁的开启"></a>自旋锁的开启</h2><ul><li>JDK1.6中-XX:+UseSpinning开启； </li><li>-XX:PreBlockSpin=10 为自旋次数； </li><li>JDK1.7后，去掉此参数，由jvm控制；</li></ul>]]></content>
    
    <summary type="html">
    
      当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
      <category term="锁" scheme="http://blog.linzhongtai.cn/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>重温系列之多线程并发：乐观锁与悲观锁</title>
    <link href="http://blog.linzhongtai.cn/2019/03/%E9%87%8D%E6%B8%A9%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%9A%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81/"/>
    <id>http://blog.linzhongtai.cn/2019/03/重温系列之多线程并发：乐观锁与悲观锁/</id>
    <published>2019-03-31T05:48:43.000Z</published>
    <updated>2019-03-31T05:48:43.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>悲观锁：适合写操作多的场景，先加锁可以保证写操作时数据正确。<br>乐观锁：适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</p></blockquote><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p><strong>总是假设最好的情况，每次去拿数据的时候都认为不会修改，所以不会上锁，但在更新的时候会判断一下在此期间这个数据有没有更新，可以使用版本号机制和CAS(Compare And Swap)算法实现。</strong><br>乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p><blockquote><p>乐观锁一般会使用版本号机制或CAS算法实现。</p></blockquote><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h4><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p><h4 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h4><ul><li>需要读写的内存值 V</li><li>进行比较的值 A</li><li>要写入的新值 B</li></ul><p><strong>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</strong></p><h3 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a>乐观锁的缺点</h3><ul><li>ABA 问题</li></ul><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。<br>JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值</p><ul><li>循环时间长开销大</li></ul><p><strong>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销</strong></p><ul><li>只能保证一个共享变量的原子操作</li></ul><p><strong>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效</strong>。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起。可以依靠数据库实现，如行锁、读锁和写锁等，都是在操作之前加锁，在Java中，synchronized的思想也是悲观锁。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</p>]]></content>
    
    <summary type="html">
    
      乐观or悲观
    
    </summary>
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="http://blog.linzhongtai.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="重温" scheme="http://blog.linzhongtai.cn/tags/%E9%87%8D%E6%B8%A9/"/>
    
      <category term="锁" scheme="http://blog.linzhongtai.cn/tags/%E9%94%81/"/>
    
  </entry>
  
</feed>
